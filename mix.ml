;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; mix.el                                                          ;;
;; Partial evaluator for mini LOSAK                                ;;
;; Copyright (C) 2004, 2005 by Omar Jarjur                         ;;
;;                                                                 ;;
;; This program is free software; you can redistribute it and/or   ;;
;; modify it under the terms of the GNU General Public License     ;;
;; as published by the Free Software Foundation; either version 2  ;;
;; of the License, or (at your option) any later version.          ;;
;;                                                                 ;;
;; This program is distributed in the hope that it will be useful, ;;
;; but WITHOUT ANY WARRANTY; without even the implied warranty of  ;;
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ;;
;; GNU General Public License for more details.                    ;;
;;                                                                 ;;
;; You should have received a copy of the GNU General Public       ;;
;; License along with this program; if not, write to the Free      ;;
;; Software Foundation, Inc.,                                      ;;
;; 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(let ((list (fn x x))
      (and (let ((rand (fn (rand x . args)
			   (cond ((atom args) x)
				 (x (rand rand . args))))))
	     (fn args (rand rand . args))))
      (or (let ((ror (fn (ror x . args)
			 (cond ((atom args) x)
			       (x 't)
			       ('t (ror ror . args))))))
	     (fn args (ror ror . args))))
      (append
       (let ((rappend (fn (rappend x y)
			  (cond ((atom x) y)
				('t (cons (car x)
					  (rappend rappend (cdr x) y))))))
	     (rseq (fn (rseq arg . args)
		       (cond ((atom args) arg)
			     ('t (rappend rappend arg (rseq rseq . args)))))))
	 (fn args (rseq rseq . args))))
      (eq
       (let ((req (fn (req x y) (cond ((atom x) (= x y))
				      ((atom y) ())
				      ((req req (car x) (car y))
				       (req req (cdr x) (cdr y)))))))
	 (fn args (req req . args))))
      (not (fn (x) (cond (x ()) ('t 't))))
      (sequence
       (let ((rsequence (fn (rsequence arg . args)
			    (cond ((atom args) arg)
				  ('t (append arg
					      (rsequence rsequence
							 . args)))))))
	 (fn args (rsequence rsequence . args))))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Function to print a parse error ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (print_error
       (fn (type)
	   (append "Error: "
		   (cond ((= type 'null)
			  "Unexpected end of input\n\r")
			 ((= type 'parenthesis)
			  "Unexpected parenthesis\n\r")
			 ((= type 'period)
			  "Unexpected period\n\r")
			 ((= type 'no_car)
			  "No car value in pair expression\n\r")
			 ((= type 'no_cdr)
			  "No cdr value in pair expression\n\r")
			 ((= type 'extra_cdrs)
			  "Too many cdrs in pair expression\n\r")
			 ((= type 'extra_periods)
			  "Too many periods in pair expression\n\r")
			 ('t "Unknown Error\n\r")))))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Function to read an s-expression ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (read
       (let ((discard_line
	      (let ((rline (fn (rline chars)
			       (cond ((atom chars) chars)
				     ((= (car chars) 10) (cdr chars))
				     ((= (car chars) 13) (cdr chars))
				     ('t (rline rline (cdr chars)))))))
		(fn args (rline rline . args))))
	     (error (fn (type chars)
			(cons (cons 'error type) (discard_line chars))))

	     ;;; Read in a string ;;;
	     (read_string
	      (let ((esc_str (fn (esc_str rstring chars)
				 (cond ((atom chars) (cons () chars))
				       ((= (car chars) ())
					(esc_str esc_str rstring (cdr chars)))
				       ('t (let ((first (car chars))
						 (rest (cdr chars))
						 ((str . rest)
						  (rstring rstring rest)))
					     (cond ((= first 110)
						    (cons (cons 10 str) rest))
						   ((= first 114)
						    (cons (cons 13 str) rest))
						   ((= first 58)
						    (cons (cons 59 str) rest))
						   ((= first 116)
						    (cons (cons 9 str) rest))
						   ('t (cons
							(cons first str)
							rest))))))))
		    (rstring (fn (rstring chars)
				 (cond ((atom chars) (cons () chars))
				       ((= (car chars) ())
					(rstring rstring (cdr chars)))
				       ((= (car chars) 34)
					(cons () (cdr chars)))
				       ((= (car chars) 92)
					(esc_str esc_str rstring (cdr chars)))
				       ('t (let ((rest (cdr chars))
						 ((str . rest)
						  (rstring rstring rest)))
					     (cons (cons (car chars) str)
						   rest)))))))
		(fn args
		    (let (((str . rest) (rstring rstring . args)))
		      (cons (cons (cons 'symbol "quote") str)
			    rest)))))

	     ;;; Read in a number ;;;
	     (read_number
	      (let ((rnumber
		     (fn (rnumber chars val)
			 (cond ((atom chars) (cons val chars))
			       ((= (car chars) ())
				(rnumber rnumber (cdr chars) val))
			       ((< (car chars) 48) (cons val chars))
			       ((> (car chars) 57) (cons val chars))
			       ('t (rnumber rnumber (cdr chars)
					    (+ (* val 10)
					       (- (car chars) 48))))))))
		(fn (chars)
		    (cond ((= (car chars) 45)
			   (let (((num . rest)
				  (rnumber rnumber (cdr chars) 0)))
			     (cons (- num) rest)))
			  ('t (rnumber rnumber chars 0))))))

	     ;;; Read in a symbol ;;;
	     (read_symbol
	      (let ((is_special_char
		     (fn (char) (cond ((< char 33) 't)
				      ((= char 34) 't)
				      ((= char 35) 't)
				      ((= char 39) 't)
				      ((= char 40) 't)
				      ((= char 41) 't)
				      ((= char 46) 't)
				      ((= char 59) 't))))
		    (rsymbol
		     (fn (rsymbol chars)
			 (cond ((atom chars) (cons () chars))
			       ((= (car chars) ())
				(rsymbol rsymbol (cdr chars)))
			       ((is_special_char (car chars))
				(cons () chars))
			       ('t (let (((expr . rest)
					  (rsymbol rsymbol (cdr chars))))
				     (cons (cons (car chars) expr) rest)))))))
		(fn (chars)
		    (let (((expr . rest) (rsymbol rsymbol chars)))
		      (cons (cons 'symbol expr) rest)))))

	     ;;; Read in a pair ;;;
	     (read_pair
	      (let ((reverse
		     (let ((rrev (fn (rrev expr val)
				     (cond ((= expr ()) val)
					   ('t (rrev rrev (cdr expr)
						     (cons (car expr)
							   val)))))))
		       (fn (expr) (rrev rrev (cdr expr) (car expr)))))
		    (rpair (fn (rpair rread chars curr dotted)
			       (cond ((atom chars) (error 'null chars))
				     ((= (car chars) ())
				      (rpair rpair rread (cdr chars)
					     curr dotted))
				     ((< (car chars) 33)
				      (rpair rpair rread (cdr chars)
					     curr dotted))
				     ((= (car chars) 41)
				      (cond ((= dotted 1)
					     (error 'no_cdr chars))
					    ((= dotted 0)
					     (cons (reverse (cons () curr))
						   (cdr chars)))
					    ('t (cons (reverse curr)
						      (cdr chars)))))
				     ((= (car chars) 46)
				      (cond ((= curr ()) (error 'no_car chars))
					    ((= dotted 0)
					     (rpair rpair rread
						    (cdr chars) curr 1))
					    ('t (error 'extra_periods chars))))
				     ((= dotted 2) (error 'extra_cdrs chars))
				     ('t (let (((expr . chars)
						(rread rread chars))
					       (dotted (cond ((= dotted 0) 0)
							     ('t 2))))
					   (cond ((= (car expr) 'error)
						  (cons expr chars))
						 ('t (rpair rpair rread chars
							    (cons expr curr)
							    dotted)))))))))
		(fn (rread chars) (rpair rpair rread chars () 0))))

	     ;;; Read in an s-expression ;;;
	     (rread
	      (fn (rread chars)
		  (cond ((atom chars) (error 'null chars))
			((= (car chars) ()) (rread rread (cdr chars)))
			((< (car chars) 33) (rread rread (cdr chars)))
			((= (car chars) 34)
			 (read_string (cdr chars)))
			((= (car chars) 35)
			 (rread rread (discard_line chars)))
			((= (car chars) 39)
			 (let (((expr . rest)
				(rread rread (cdr chars))))
			   (cond ((= (car expr) 'error)
				  (cons expr rest))
				 ('t (cons (cons (cons 'symbol "quote") expr)
					   rest)))))
			((= (car chars) 40)
			 (read_pair rread (cdr chars)))
			((= (car chars) 41)
			 (error 'parenthesis chars))
			((= (car chars) 46)
			 (error 'period chars))
			((= (car chars) 59)
			 (rread rread (discard_line chars)))
			((and (> (car chars) 47)
			      (< (car chars) 58))
			 (read_number chars))
			((and (= (car chars) 45)
			      (> (car (cdr chars)) 47)
			      (< (car (cdr chars)) 58))
			 (read_number chars))
			('t (read_symbol chars))))))
	 (fn args (rread rread . args))))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Function to print an s-expression ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (print
       (let ((is_atom (fn (expr) (cond ((atom expr) 't)
				       ((= (car expr) 'symbol) 't))))

	     ;;; Print a number ;;;
	     (print_number
	      (let ((rnumber (fn (rnumber expr chars)
				 (cond ((= expr 0) chars)
				       ('t (rnumber rnumber (/ expr 10)
						    (cons (+ (% expr 10) 48)
							  chars)))))))
		(fn (expr)
		    (cond ((= expr 0) "0")
			  ((< expr 0) (cons 45 (rnumber rnumber (- expr) ())))
			  ('t (rnumber rnumber expr ()))))))

	     ;;; Print a pair ;;;
	     (print_pair
	      (let ((rpair (fn (rpair rprint expr)
			       (cond ((= (cdr expr) ())
				      (append (rprint rprint (car expr))
					      (cons 41 ())))
				     ((is_atom (cdr expr))
				      (append (rprint rprint (car expr))
					      " . "
					      (rprint rprint (cdr expr))
					      (cons 41 ())))
				     ('t (append (rprint rprint (car expr))
						 " "
						 (rpair rpair rprint
							(cdr expr))))))))
		(fn (rprint expr) (cons 40 (rpair rpair rprint expr)))))

	     (print_atom (fn (expr)
			     (cond ((= expr ()) "()")
				   ((number expr) (print_number expr))
				   ((= (car expr) 'symbol) (cdr expr))
				   ('t "Huh...?"))))

	     ;;; Print an s-expression ;;;
	     (rprint (fn (rprint expr)
			 (cond ((is_atom expr) (print_atom expr))
			       ((eq (car expr) (cons 'symbol "quote"))
				(cons 39 (rprint rprint (cdr expr))))
			       ('t (print_pair rprint expr))))))
	 (fn (expr) (rprint rprint expr))))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Functions for handling "atoms" ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (is_function (fn (x) (= (car x) 'function)))
      (is_symbol (fn (x) (= (car x) 'symbol)))
      (is_atom (fn (x) (or (atom x)
			   (is_function x)
			   (is_symbol x))))
      (is_error (fn (expr) (= (car expr) 'error)))
      (mk_symbol (fn (str) (cons 'symbol str)))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Functions to handle primitives ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (quote_symbol (mk_symbol "quote"))
      (cond_symbol (mk_symbol "cond"))
      (let_symbol (mk_symbol "let"))
      (fn_symbol (mk_symbol "fn"))
      (car_symbol (mk_symbol "car"))
      (cdr_symbol (mk_symbol "cdr"))
      (cons_symbol (mk_symbol "cons"))
      (atom_symbol (mk_symbol "atom"))
      (number_symbol (mk_symbol "number"))
      (symbol_symbol (mk_symbol "symbol"))
      (+_symbol (mk_symbol "+"))
      (-_symbol (mk_symbol "-"))
      (*_symbol (mk_symbol "*"))
      (/_symbol (mk_symbol "/"))
      (%_symbol (mk_symbol "%"))
      (=_symbol (mk_symbol "="))
      (>_symbol (mk_symbol ">"))
      (<_symbol (mk_symbol "<"))
      (>>>_symbol (mk_symbol ">>>"))
      (>>_symbol (mk_symbol ">>"))
      (<<_symbol (mk_symbol "<<"))
      (~_symbol (mk_symbol "~"))
      (&_symbol (mk_symbol "&"))
      (|_symbol (mk_symbol "|"))
      (^_symbol (mk_symbol "^"))
      (ccar (fn (x) (cond ((is_atom x) ())
			  ('t (car x)))))
      (ccdr (fn (x) (cond ((is_atom x) ())
			  ('t (cdr x)))))
      (is_sf (fn (x)
		 (cond ((eq x quote_symbol) 't)
		       ((eq x cond_symbol) 't)
		       ((eq x let_symbol) 't)
		       ((eq x fn_symbol) 't))))
      (is_primitive (fn (x)
			(cond ((= x ()) 't)
			      ((number x) 't)
			      ((not (is_atom x)) ())
			      ((is_sf x) 't)
			      ((eq x car_symbol) 't)
			      ((eq x cdr_symbol) 't)
			      ((eq x cons_symbol) 't)
			      ((eq x atom_symbol) 't)
			      ((eq x number_symbol) 't)
			      ((eq x symbol_symbol) 't)
			      ((eq x +_symbol) 't)
			      ((eq x -_symbol) 't)
			      ((eq x *_symbol) 't)
			      ((eq x /_symbol) 't)
			      ((eq x %_symbol) 't)
			      ((eq x >>>_symbol) 't)
			      ((eq x >>_symbol) 't)
			      ((eq x <<_symbol) 't)
			      ((eq x >_symbol) 't)
			      ((eq x <_symbol) 't)
			      ((eq x =_symbol) 't)
			      ((eq x ~_symbol) 't)
			      ((eq x &_symbol) 't)
			      ((eq x |_symbol) 't)
			      ((eq x ^_symbol) 't))))
      (is_variable (fn (expr) (and (is_symbol expr)
				   (not (is_primitive expr)))))
      (rstatic (fn (rstatic expr)
		   (cond ((is_function expr) 't)
			 ((is_primitive expr) 't)
			 ((is_atom expr) ())
			 ((eq (car expr) quote_symbol) 't)
			 ((eq (car expr) fn_symbol) 't)
			 ((rstatic rstatic (car expr))
			  (rstatic rstatic (cdr expr))))))
      (is_static (fn (expr) (rstatic rstatic expr)))
      (true (cons quote_symbol (mk_symbol "t")))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Functions to perform primitive operations ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (apply_cxr (fn (op arg)
		     (cond ((is_primitive arg) ())
			   ((is_function arg) ())
			   ((eq (car arg) fn_symbol) ())
			   ((is_atom arg) (list op arg))
			   ((eq (car arg) quote_symbol)
			    (let ((result (cond ((eq op car_symbol)
						 (ccar (cdr arg)))
						('t (ccdr (cdr arg))))))
			      (cond ((is_primitive result) result)
				    ((is_function result) result)
				    ('t (cons quote_symbol
					      result)))))
			   ((eq (car arg) cons_symbol)
			    (cond ((is_variable (cdr arg))
				   (cond ((eq op car_symbol)
					  (list car_symbol (cdr arg)))
					 ('t (list car_symbol
						   (list cdr_symbol
							 (cdr arg))))))
				  ((is_atom (cdr arg)) ())
				  ((eq op car_symbol)
				   (car (cdr arg)))
				  ((is_variable (cdr (cdr arg)))
				   (list car_symbol
					 (cdr (cdr arg))))
				  ((is_atom (cdr (cdr arg))) ())
				  ('t (car (cdr (cdr arg))))))
			   ((eq (car arg) car_symbol)
			    (list op arg))
			   ((eq (car arg) cdr_symbol)
			    (list op arg))
			   ((is_primitive (car arg)) ())
			   ('t (list op arg)))))
      (apply_cons (fn (arg1 arg2)
		      (cond ((is_primitive arg1)
			     (cond ((is_primitive arg2)
				    (cons quote_symbol
					  (cons arg1 arg2)))
				   ((eq (car arg2) quote_symbol)
				    (cons quote_symbol
					  (cons arg1 (cdr arg2))))
				   ('t (list cons_symbol arg1 arg2))))
			    ((eq (car arg1) quote_symbol)
			     (cond ((is_primitive arg2)
				    (cons quote_symbol
					  (cons (cdr arg1) arg2)))
				   ((eq (car arg2) quote_symbol)
				    (cons quote_symbol
					  (cons (cdr arg1) (cdr arg2))))
				   ('t (list cons_symbol arg1 arg2))))
			    ('t (list cons_symbol arg1 arg2)))))
      (check_for_num (fn (arg)
			 (cond ((number arg) 't)
			       ((is_primitive arg) ())
			       ((is_function arg) ())
			       ((is_atom arg) 't)
			       ((eq (car arg) quote_symbol)
				(number (cdr arg)))
			       ((eq (car arg) cons_symbol) ())
			       ((eq (car arg) atom_symbol) ())
			       ((eq (car arg) number_symbol) ())
			       ((eq (car arg) symbol_symbol) ())
			       ((eq (car arg) =_symbol) ())
			       ((eq (car arg) <_symbol) ())
			       ((eq (car arg) >_symbol) ())
			       ((eq (car arg) fn_symbol) ())
			       ((eq (car arg) ()) ())
			       ((number (car arg)) ())
			       ('t 't))))
      (apply_math (fn (op op_symbol arg1 arg2)
		      (cond ((check_for_num arg1)
			     (cond ((check_for_num arg2)
				    (cond ((and (number arg1)
						(number arg2))
					   (op arg1 arg2))
					  ((and (number arg1)
						(eq (car arg2)
						    quote_symbol))
					   (op arg1 (cdr arg2)))
					  ((and (number arg2)
						(eq (car arg1)
						    quote_symbol))
					   (op (cdr arg1) arg2))
					  ((and (eq (car arg1)
						    quote_symbol)
						(eq (car arg2)
						    quote_symbol))
					   (op (cdr arg1) (cdr arg2)))
					  ('t (list op_symbol
						    arg1 arg2)))))))))
      (apply_= (fn (arg1 arg2)
		   (cond ((eq (ccar arg1) quote_symbol)
			  (cond ((is_atom (ccdr arg1))
				 (cond ((eq (ccar arg2) quote_symbol)
					(cond ((eq (ccdr arg1) (ccdr arg2))
					       true)))
				       ((is_primitive arg2)
					(cond ((eq (ccdr arg1) arg2) true)))
				       ('t (list =_symbol
						 arg1 arg2))))))
			 ((eq (ccar arg2) quote_symbol)
			  (cond ((is_atom (ccdr arg2))
				 (cond ((eq (ccar arg1) quote_symbol)
					(cond ((eq (ccdr arg1) (ccdr arg2))
					       true)))
				       ((is_primitive arg1)
					(cond ((eq arg1 (ccdr arg2)) true)))
				       ('t (list =_symbol
						 arg1 arg2))))))
			 ((and (is_primitive arg1)
			       (is_primitive arg2))
			  (cond ((eq arg1 arg2) true)))
			 ('t (list =_symbol arg1 arg2)))))
      (apply_test (fn (test test_symbol arg1)
		      (cond ((number arg1)
			     (cond ((= test 'symbol) ())
				   ('t true)))
			    ((or (= arg1 ())
				 (and (eq (car arg1) quote_symbol)
				      (= (cdr arg1) ())))
			     (cond ((= test atom) true)))
			    ((is_function arg1)
			     (cond ((= test atom) true)))
			    ((is_atom arg1)
			     (cond ((is_variable arg1)
				    (list test_symbol arg1))
				   ((= test number) ())
				   ('t true)))
			    ((eq (car arg1) fn_symbol)
			     (cond ((= test atom) true)))
			    ((eq (car arg1) quote_symbol)
			     (cond ((= (cdr arg1) ())
				    (cond ((= test atom) true)))
				   ((number (cdr arg1))
				    (cond ((= test 'symbol) ())
					  ('t true)))
				   ((is_atom (cdr arg1))
				    (cond ((= test number) ())
					  ('t true)))))
			    ('t (list test_symbol arg1)))))
      (ap (fn (op arg1 arg2)
	      (cond ((eq op car_symbol) (apply_cxr op arg1))
		    ((eq op cdr_symbol) (apply_cxr op arg1))
		    ((eq op atom_symbol)
		     (apply_test atom op arg1))
		    ((eq op number_symbol)
		     (apply_test number op arg1))
		    ((eq op symbol_symbol)
		     (apply_test 'symbol op arg1))
		    ((eq op cons_symbol)
		     (apply_cons arg1 arg2))
		    ((eq op =_symbol)
		     (apply_= arg1 arg2))
		    ((eq op <_symbol)
		     (apply_math (fn (x y) (cond ((< x y) true)))
				 op arg1 arg2))
		    ((eq op >_symbol)
		     (apply_math (fn (x y) (cond ((> x y) true)))
				 op arg1 arg2))
		    ((eq op >>>_symbol)
		     (apply_math >>> op arg1 arg2))
		    ((eq op >>_symbol)
		     (apply_math >> op arg1 arg2))
		    ((eq op <<_symbol)
		     (apply_math << op arg1 arg2))
		    ((eq op +_symbol)
		     (apply_math + op arg1 arg2))
		    ((eq op *_symbol)
		     (apply_math * op arg1 arg2))
		    ((eq op /_symbol)
		     (apply_math / op arg1 arg2))
		    ((eq op %_symbol)
		     (apply_math % op arg1 arg2))
		    ((eq op &_symbol)
		     (apply_math & op arg1 arg2))
		    ((eq op |_symbol)
		     (apply_math | op arg1 arg2))
		    ((eq op ^_symbol)
		     (apply_math ^ op arg1 arg2))
		    ((eq op ~_symbol)
		     (cond ((check_for_num arg1)
			    (cond ((number arg1) (~ arg1))
				  ('t (list op arg1))))))
		    ((eq op -_symbol)
		     (cond ((check_for_num arg1)
			    (cond ((check_for_num arg2)
				   (apply_math - op arg1 arg2))
				  ((number arg1) (- arg1))
				  ('t (list -_symbol arg1)))))))))
      (get_1st_arg (fn (expr)
		       (cond ((is_variable expr)
			      (list car_symbol expr))
			     ((is_atom expr) ())
			     ('t (car expr)))))
      (get_2nd_arg (fn (expr)
		       (cond ((is_variable expr)
			      (list car_symbol
				    (list car_symbol
					  (list cdr_symbol expr))))
			     ((is_atom expr) ())
			     ((is_variable (cdr expr))
			      (list car_symbol
				    (list car_symbol (cdr expr))))
			     ((is_atom (cdr expr)) ())
			     ((is_variable (car (cdr expr)))
			      (list car_symbol (car (cdr expr))))
			     ((is_atom (car (cdr expr))) ())
			     ((eq (car (car (cdr expr))) quote_symbol)
			      (let ((arg (car (cdr (car (cdr expr))))))
				(cond ((is_primitive arg) arg)
				      ((is_function arg) arg)
				      ('t (cons quote_symbol arg)))))
			     ((eq (car (car (cdr expr))) fn_symbol) ())
			     ((eq (car (car (cdr expr))) cons_symbol)
			      (get_1st_arg (cdr (car (cdr expr)))))
			     ((or (is_sf (car (car (cdr expr))))
				  (eq (car (car (cdr expr))) car_symbol)
				  (eq (car (car (cdr expr))) cdr_symbol)
				  (is_variable (car (car (cdr expr))))
				  (not (is_atom (car (car (cdr expr))))))
			      (list car_symbol (car (cdr expr))))
			     ('t ()))))
      (get_args (fn (args)
		    (cond ((is_primitive args) '(()))
			  ((is_function args) '(()))
			  ((eq (car args) quote_symbol)
			   (let ((arg1 (ccar (cdr args)))
				 (arg2 (ccar (ccdr (cdr args))))
				 (arg1 (cond ((is_primitive arg1) arg1)
					     ((is_function arg1) arg1)
					     ('t (cons quote_symbol
						       arg1))))
				 (arg2 (cond ((is_primitive arg2) arg2)
					     ((is_function arg2) arg2)
					     ('t (cons quote_symbol
						       arg2)))))
			     (cons arg1 arg2)))
			  ((eq (car args) fn_symbol) '(()))
			  ((or (is_atom args)
			       (is_sf (car args))
			       (eq (car args) car_symbol)
			       (eq (car args) cdr_symbol)
			       (not (is_primitive (car args))))
			   (cons (list car_symbol args)
				 (list car_symbol
				       (list cdr_symbol args))))
			  ((eq (car args) cons_symbol)
			   (cons (get_1st_arg (cdr args))
				 (get_2nd_arg (cdr args))))
			  ('t '(())))))
      (apply_primitive (fn (op args)
			   (let (((a1 . a2) (get_args args)))
			     (ap op a1 a2))))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Functions to keep track of the evaluation history ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (empty_logs (fn args ()))
      (update_logs (fn (logs op1 args1)
		       (cond ((is_static args1)
			      (fn (op2 args2)
				  (cond ((and (eq op1 op2)
					      (eq args1 args2)) 't)
					('t (logs op2 args2)))))
			     ('t (fn (op2 args2)
				     (cond ((or (is_static args2)
						(not (eq op1 op2)))
					    (logs op2 args2))
					   ('t 't)))))))
      (check_logs (fn (logs op args) (logs op args)))
      (update_logs (fn (logs op1 args1)
                       (cond ((is_static args1) logs)
                             ('t (fn (op2 args2)
                                     (cond ((eq op1 op2) 't)
                                           ('t (logs op2 args2))))))))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Functions to handle the environment variable ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (empty_env ())
      (rbind_args (fn (rbind_args args env)
		      (cond ((is_variable args) (cons (cons args args) env))
			    ((is_atom args) env)
			    ('t (rbind_args rbind_args (car args)
					    (rbind_args rbind_args
							(cdr args) env))))))
      (bind_args (fn (args env) (rbind_args rbind_args args env)))
      (rbind (fn (rbind var val env)
		 (cond ((is_primitive var) env)
		       ((is_symbol var) (cons (cons var val) env))
		       ((is_atom var) env)
		       ('t (rbind rbind (car var)
				  (apply_primitive car_symbol
						   (list cons_symbol
							 val ()))
				  (rbind rbind (cdr var)
					 (apply_primitive
					  cdr_symbol
					  (list cons_symbol
						val ()))
					 env))))))
      (bind (fn (var val env) (rbind rbind var val env)))
      (rfind (fn (rfind var env)
		 (cond ((is_atom env) ())
		       ((eq var (ccar (ccar env)))
			(ccdr (ccar env)))
		       ('t (rfind rfind var (cdr env))))))
      (find (fn (var env) (rfind rfind var env)))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Functions to handle special forms ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (rcond (fn (rcond reval cases env logs)
		 (cond ((is_atom cases) ())
		       ('t (let ((test
				  (reval reval (ccar (car cases)) env logs))
				 (case1 (ccar (ccdr (car cases))))
				 (cases (cdr cases)))
			     (cond ((or (= test ())
					(and (eq (car test)
						 quote_symbol)
					     (= (cdr test) ())))
				    (rcond rcond reval cases env logs))
				   ((or (is_primitive test)
					(is_function test)
					(eq (car test) fn_symbol)
					(eq (car test) quote_symbol))
				    (reval reval case1 env logs))
				   ('t (let ((c1 (reval reval case1 env logs))
					     (c2 (rcond rcond reval cases
							   env logs)))
					 (list cond_symbol
					       (list test c1)
					       (list (cons quote_symbol
							   (mk_symbol "t"))
						     c2))))))))))
      (eval_cond (fn (reval cases env logs)
		     (rcond rcond reval cases env logs)))
      (rlet (fn (rlet reval vars expr env logs)
		(cond ((is_atom vars)
		       (reval reval expr env logs))
		      ('t (let ((var (ccar (car vars)))
				(val (ccar (ccdr (car vars))))
				(val (reval reval val env logs))
				(env (bind var val env)))
			    (rlet rlet reval (cdr vars) expr env logs))))))
      (eval_let (fn (reval expr env logs)
		    (rlet rlet reval (ccar expr)
			  (ccar (ccdr expr)) env logs)))
      (eval_sf (fn (reval op expr env logs)
		   (cond ((eq op quote_symbol)
			  (cond ((is_primitive expr) expr)
				((is_function expr) expr)
				('t (cons op expr))))
			 ((eq op cond_symbol)
			  (eval_cond reval expr env logs))
			 ((eq op let_symbol)
			  (eval_let reval expr env logs))
			 ((eq op fn_symbol)
			  (let ((args (ccar expr))
				(body (ccar (ccdr expr))))
			    (list 'function
				  (list args (reval reval body
						    (bind_args args env)
						    logs))
				  . env))))))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Functions to partially evaluate an expression ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (rlist (fn (rlist reval exprs env logs)
		 (cond ((is_atom exprs)
			(reval reval exprs env logs))
		       ('t (apply_primitive
			    cons_symbol
			    (list cons_symbol
				  (reval reval (car exprs) env logs)
				  (list cons_symbol
					(rlist rlist reval (cdr exprs)
					       env logs)
					())))))))
      (apply (fn (reval op args logs)
		 (cond ((is_primitive op)
			(apply_primitive op args))
		       ((check_logs logs op args)
			(cond ((is_atom args) (cons op args))
			      ('t (list let_symbol
					(list (list (cons (mk_symbol "op")
							  (mk_symbol "args"))
						    (list cons_symbol
							  op args)))
					(cons (mk_symbol "op")
					      (mk_symbol "args"))))))
		       ((is_function op)
			(let ((arg_list (ccar (ccar (cdr op))))
			      (expr (ccar (ccdr (ccar (cdr op)))))
			      (env (ccdr (cdr op)))
			      (env (bind arg_list args env))
			      (logs (update_logs logs op args)))
			  (reval reval expr env logs)))
		       ((is_atom args) (cons op args))
		       ('t (list let_symbol
				 (list (list (cons (mk_symbol "op")
						   (mk_symbol "args"))
					     (list cons_symbol
						   op args)))
				 (cons (mk_symbol "op")
				       (mk_symbol "args")))))))
      (eval_pair (fn (reval op expr env logs)
		     (cond ((is_sf op)
			    (eval_sf reval op expr env logs))
			   ('t (let ((args (rlist rlist reval expr env logs)))
				 (apply reval op args logs))))))
      (reval (fn (reval expr env logs)
		 (cond ((is_primitive expr) expr)
		       ((is_function expr) expr)
		       ((is_atom expr) (find expr env))
		       ('t (let ((op (reval reval (car expr) env logs)))
			     (eval_pair reval op (cdr expr) env logs))))))
      (eval (fn (expr env) (reval reval expr env empty_logs)))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Functions to convert s-expressions into a displayable form ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (display_function
       (fn (rdisplay expr)
	   (let ((args (ccar (ccar (cdr expr))))
		 (body (ccar (ccdr (ccar (cdr expr))))))
	     (list fn_symbol args
		   (rdisplay rdisplay body)))))
      (rdisplay (fn (rdisplay expr)
		    (cond ((is_function expr) (display_function rdisplay expr))
			  ((is_atom expr) expr)
			  ('t (cons (rdisplay rdisplay (car expr))
				    (rdisplay rdisplay (cdr expr)))))))
      (display (fn (expr) (rdisplay rdisplay expr))))

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;; End of delcarations section ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  (let ((prompt_str "\n\r> ")
        (prompt_str "\n\r\:\:Generated Source Code\n\r")
        (format (fn (str) (append str prompt_str)))
	(repl (fn (repl out in)
		  (cond ((atom out)
			 (let (((expr . rest) (read in)))
			   (cond ((is_error expr)
				  (repl repl (format (print_error expr))
					rest))
				 ((eq expr (mk_symbol "exit")) "Bye.\n\r")
				 ('t (let ((expr (eval expr empty_env))
					   (result (display expr))
					   (output (format (print result))))
				       (repl repl output rest))))))
			('t (cons (car out)
				  (repl repl (cdr out) in)))))))
    (fn input (cons (car "\:")
                    (cons (car "\n")
		          (cons (car "\r")
			        (repl repl () (cdr input))))))))