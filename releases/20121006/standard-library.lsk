;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Losak compiler                                                  ;;
;;                                                                 ;;
;; This front-end to the compiler adds standard library functions. ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Copyright (C) 2004 - 2012 by Omar Jarjur                        ;;
;;                                                                 ;;
;; This program is free software; you can redistribute it and/or   ;;
;; modify it under the terms of version 2 of the GNU General       ;;
;; Public License as published by the Free Software Foundation.    ;;
;;                                                                 ;;
;; This program is distributed in the hope that it will be useful, ;;
;; but WITHOUT ANY WARRANTY; without even the implied warranty of  ;;
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ;;
;; GNU General Public License for more details.                    ;;
;;                                                                 ;;
;; You should have received a copy of the GNU General Public       ;;
;; License along with this program; if not, write to the Free      ;;
;; Software Foundation, Inc.,                                      ;;
;; 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define base-standard-library-definitions
  '((define (caar x) (car (car x)))
    (define (cdar x) (cdr (car x)))
    (define (cadr x) (car (cdr x)))
    (define (cddr x) (cdr (cdr x)))
    (define (caaar x) (car (car (car x))))
    (define (caadr x) (car (car (cdr x))))
    (define (cadar x) (car (cdr (car x))))
    (define (caddr x) (car (cdr (cdr x))))
    (define (cdaar x) (cdr (car (car x))))
    (define (cdadr x) (cdr (car (cdr x))))
    (define (cddar x) (cdr (cdr (car x))))
    (define (cdddr x) (cdr (cdr (cdr x))))
    (define (caaaar x) (car (car (car (car x)))))
    (define (caaadr x) (car (car (car (cdr x)))))
    (define (caadar x) (car (car (cdr (car x)))))
    (define (caaddr x) (car (car (cdr (cdr x)))))
    (define (cadaar x) (car (cdr (car (car x)))))
    (define (cadadr x) (car (cdr (car (cdr x)))))
    (define (caddar x) (car (cdr (cdr (car x)))))
    (define (cadddr x) (car (cdr (cdr (cdr x)))))
    (define (cdaaar x) (cdr (car (car (car x)))))
    (define (cdaadr x) (cdr (car (car (cdr x)))))
    (define (cdadar x) (cdr (car (cdr (car x)))))
    (define (cdaddr x) (cdr (car (cdr (cdr x)))))
    (define (cddaar x) (cdr (cdr (car (car x)))))
    (define (cddadr x) (cdr (cdr (car (cdr x)))))
    (define (cdddar x) (cdr (cdr (cdr (car x)))))
    (define (cddddr x) (cdr (cdr (cdr (cdr x)))))

    (define (id x) x)
    (define (list . args) args)
    (define (apply op args) (op . args))
    (define (recurse op)
      ((fn (this) (op (fn args ((this this) . args))))
       (fn (this) (op (fn args ((this this) . args))))))
    (define (_walk head tail test merge ret)
      (fn (tree)
          (if (test tree)
              (ret tree)
              (merge (head tree)
                     ((_walk head tail test merge ret)
                      (tail tree))))))
    (define (_rreverse list result return)
      (if (pair? list)
          (_rreverse (cdr list) (cons (car list) result) return)
          (return result)))
    (define (reverse list) (_rreverse list '() id))
    (define (foldl merge end)
      (fn (list)
          (if (pair? list)
              ((foldl merge (merge (car list) end)) (cdr list))
              end)))
    (define (foldr merge end)
      (fn (list) (_rreverse list '() (foldl merge end))))
    (define (append . args) ((foldr (fn (x xs)
                                        (if (null? xs)
                                            x
                                            ((foldr cons xs) x)))
                                    '()) args))
    (define (equal x y)
      (if (pair? x)
          (if (pair? y)
              (if (equal (car x) (car y))
                  (equal (cdr x) (cdr y))
                  '())
              '())
          (= x y)))
    (define (map op list) ((foldr (fn (x xs) (cons (op x) xs)) '()) list))
    (define (or . args) ((foldr (fn (t ts) (if t t ts)) '()) args))
    (define (and . args) ((foldr (fn (t ts) (if t ts '())) 't) args))
    (define not null?)
    (define (member item list)
      (if (pair? list)
          (if (equal item (car list))
              list
              (member item (cdr list)))
          '()))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Helper functions for parsing ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (define (_escape-char char)
      (if (= char 116)
          9
          (if (= char 114)
              13
              (if (= char 110)
                  10
                  char))))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Expression parser(s)                                              ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Each parser takes a return continuation, an error continuation,   ;;
    ;; and a current line number. They implement a function that takes   ;;
    ;; input one character at a time (in curried form), parses the input ;;
    ;; string, and passes the tree and updated line number to the        ;;
    ;; return, or "fails" and passes a message to the error.             ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; ReaderResult :: T=>(T|Reader<T>)
    ;; Reader :: T=>Char->ReaderResult<T>
    ;; ParserError :: T=>(String,Int)->Reader<T>
    ;; ParserReturn :: V,T=>(V,Int)->ReaderResult<T>
    ;; Parser :: V,T=>(ParserReturn<V,T>,ParserError<T>,Int)->Reader<T>
    (define (_parse-escaped-string chars return error line)
      (fn (char)
          (if (not char)
              (_parse-escaped-string chars return error line)
              (if (= char 0)
                  (error "End of input" line)
                  (_parse-string (cons (_escape-char char) chars)
                                 return error
                                 (if (= char 10)
                                     (+ line 1)
                                     line))))))
    (define (_parse-string chars return error line)
      (fn (char)
          (if (not char)
              (_parse-string chars return error line)
              (if (= char 0)
                  (error "End of input" line)
                  (if (= char 34)
                      (return (list 'quote (reverse chars)) line)
                      (if (= char 92)
                          (_parse-escaped-string chars return error line)
                          (_parse-string (cons char chars)
                                         return error
                                         (if (= char 10)
                                             (+ line 1)
                                             line))))))))
    (define (_skip-line parser return error line)
      (fn (char)
          (if (= char 0)
              (error "End of input" line)
              (if (= char 10)
                  (parser return error (+ line 1))
                  (_skip-line parser return error line)))))
    (define (_parse-number value return error line)
      (fn (char)
          (if (not char)
              (_parse-number value return error line)
              (if (< char 33)
                  (return value (if (= char 10) (+ line 1) line))
                  (if (and (> char 47) (< char 58))
                      (_parse-number (+ (* value 10) (- char 48))
                                     return error line)
                      ((return value line) char))))))
    (define (_parse-symbol chars return error line)
      (fn (char)
          (if (not char)
              (_parse-symbol chars return error line)
              (if (< char 33)
                  (return (string->symbol (reverse chars))
                          (if (= char 10)
                              (+ line 1)
                              line))
                  (if (or (and (> char 38) (< char 42))
                          (= char 46)
                          (= char 59))
                      ((return (string->symbol (reverse chars)) line) char)
                      (_parse-symbol (cons char chars)
                                     return error line))))))
    (define (_parse-paren return error line)
      (fn (char)
          (if (= char 0)
              (error "End of input" line)
              (if (= char 10)
                  (_parse-paren return error (+ line 1))
                  (if (or (not char) (< char 33))
                      (_parse-paren return error line)
                      (if (= char 41)
                          (return char line)
                          (if (= char 59)
                              (_skip-line _parse-paren return error line)
                              (error "Too many tail expressions" line))))))))
    (define (_parse-tail-cont return error line)
      (fn (head line)
          (_parse-tail (fn (tail line) (return (cons head tail) line))
                       error line)))
    (define (_parse-tail return error line)
      (fn (char)
          (if (= char 0)
              (error "End of input" line)
              (if (= char 10)
                  (_parse-tail return error (+ line 1))
                  (if (or (not char) (< char 33))
                      (_parse-tail return error line)
                      (if (= char 41)
                          (return '() line)
                          (if (= char 46)
                              (parse-expr (fn (tail line)
                                              (_parse-paren (fn (paren line)
                                                                (return tail
                                                                        line))
                                                            error line))
                                          error line)
                              (if (= char 59)
                                  (_skip-line _parse-tail return error line)
                                  ((parse-expr (_parse-tail-cont return error
                                                                 line)
                                               error line)
                                   char)))))))))
    (define (_parse-pair return error line)
      (fn (char)
          (if (= char 0)
              (error "End of input" line)
              (if (= char 10)
                  (_parse-pair return error (+ line 1))
                  (if (or (not char) (< char 33))
                      (_parse-pair return error line)
                      (if (= char 41)
                          (return '() line)
                          (if (= char 59)
                              (_skip-line _parse-pair return error line)
                              ((parse-expr (_parse-tail-cont return error line)
                                           error line)
                               char))))))))
    (define (parse-expr return error line)
      (fn (char)
          (if (= char 0)
              (error "End of input" line)
              (if (or (not char) (< char 33))
                  (parse-expr return error (if (= char 10) (+ line 1) line))
                  (if (= char 34)
                      (_parse-string "" return error line)
                      (if (= char 39)
                          (parse-expr (fn (expr line) (return (list 'quote expr) line))
                                      error line)
                          (if (= char 40)
                              (_parse-pair return error line)
                              (if (= char 41)
                                  (error "Unexpected closing parenthesis" line)
                                  (if (= char 44)
                                      (parse-expr (fn (expr line) (return (list 'unquote expr) line))
                                                  error line)
                                      (if (= char 46)
                                          (error "Unexpected period" line)
                                          (if (= char 96)
                                              (parse-expr (fn (expr line)
                                                              (return (list 'quasiquote expr) line))
                                                          error line)
                                              (if (= char 59)
                                                  (_skip-line parse-expr return
                                                              error line)
                                                  (if (and (> char 47)
                                                           (< char 58))
                                                      (_parse-number (- char 48)
                                                                     return
                                                                     error
                                                                     line)
                                                      (_parse-symbol (list char)
                                                                     return
                                                                     error
                                                                     line))))))))))))))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Functions to print s-expressions ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (define (_build-num-str num)
      ((_walk (fn (n) (% n 10))
              (fn (n) (/ n 10))
              (fn (n) (= n 0))
              (fn (d op) (fn (str) (op (cons (+ d 48) str))))
              (fn (x) id))
       num))
    (define (number->string num)
      (if (= num 0)
          "0"
          (if (< num 0)
              (cons 45 ((_build-num-str (- num)) ""))
              ((_build-num-str num) ""))))
    (define (_print-tail expr suffix)
      (if expr
          (if (pair? expr)
              (append " " (_print-with-suffix (car expr)
                                              (_print-tail (cdr expr) suffix)))
              (append " . " (_print-with-suffix expr (append ")" suffix))))
          (append ")" suffix)))
    (define (_print-with-suffix expr suffix)
      (if (pair? expr)
          (append "(" (_print-with-suffix (car expr)
                                          (_print-tail (cdr expr) suffix)))
          (append (print expr) suffix)))
    (define (print expr)
      (if (null? expr)
          "()"
          (if (number? expr)
              (number->string expr)
              (if (symbol? expr)
                  (symbol->string expr)
                  (if (pair? expr)
                      (_print-with-suffix expr "")
                      (if (function? expr)
                          "<FUNCTION>"
                          "<INTERNAL ERROR>"))))))))

;;;;;;;;;;;;;;;;;;;;
;; Error handling ;;
;;;;;;;;;;;;;;;;;;;;
(define map-to-stderr
  (foldr (fn (char output) (cons (list (cons 2 char)) output)) ()))
(define (print-error msg) (map-to-stderr (append "Error; "msg "\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for escaping symbols ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define supported-builtins
  '(cons car cdr = < > + - * / % ~ & | ^ >> >>> <<
         null? number? pair? function?
         symbol? symbol->string string->symbol))
(define (escape-symbols expr)
  (if (pair? expr)
      (cons (escape-symbols (car expr))
            (escape-symbols (cdr expr)))
      (if (symbol? expr)
          (let ((symbol-string (symbol->string expr)))
            (if (= (car symbol-string) 95)
                (string->symbol (cons 95 symbol-string))
                expr))
          expr)))
(define (escape-statement-list statements)
  (if (pair? statements)
      (cons (escape-statement (car statements))
            (escape-statement-list (cdr statements)))
      (escape-statement statements)))
(define (escape-statement expr)
  (cond ((null? expr) expr)
        ((number? expr) expr)
        ((symbol? expr) (escape-symbols expr))
        ((= (car expr) 'quote) expr)
        ((= (car expr) 'if)
         `(if ,(escape-statement (cadr expr))
              ,(escape-statement (caddr expr))
              ,(escape-statement (cadr (cddr expr)))))
        ((= (car expr) 'fn)
         `(fn ,(escape-symbols (cadr expr)) ,(escape-statement (caddr expr))))
        ((= (car expr) 'define)
         `(define ,(escape-symbols (get-name expr))
            ,(escape-statement (get-body expr))))
        ('t (escape-statement-list expr))))

;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the input ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (get-name definition)
  (if (pair? (cadr definition))
      (caadr definition)
      (cadr definition)))
(define (get-body definition)
  (if (pair? (cadr definition))
      (list 'fn (cdr (cadr definition)) (caddr definition))
      (caddr definition)))
(define (find-definition name definitions)
  (cond ((null? definitions) '())
        ((= name (get-name (car definitions)))
         (car definitions))
        ('t (find-definition name (cdr definitions)))))
(define (flatten input-tree output-list)
  (cond ((null? input-tree) output-list)
        ((symbol? input-tree) (cons input-tree output-list))
        ((number? input-tree) (cons input-tree output-list))
        ('t (flatten (car input-tree)
                     (flatten (cdr input-tree) output-list)))))
(define (args-required-globals args declared-globals definitions)
  (if (pair? args)
      (append (required-globals (car args) declared-globals definitions)
              (args-required-globals (cdr args)
                                     declared-globals
                                     definitions))
      (required-globals args declared-globals definitions)))
(define (required-globals expr declared-globals definitions)
  (cond ((symbol? expr)
         (if (member expr declared-globals)
             '()
             (if (member expr supported-builtins)
                 '()
                 (let ((definition (find-definition expr definitions))
                       (declared-globals (cons expr declared-globals)))
                   (cons expr (required-globals definition
                                                declared-globals
                                                definitions))))))
        ((null? expr) '())
        ((number? expr) '())
        ((= (car expr) 'quote) '())
        ((= (car expr) 'define)
         (required-globals (get-body expr) declared-globals definitions))
        ((= (car expr) 'fn)
         (required-globals (caddr expr)
                           (flatten (cadr expr) declared-globals)
                           definitions))
        ('t (args-required-globals expr declared-globals definitions))))
(define (extract-required-definitions required-globals definitions return)
  (if (null? definitions)
      (return '() '())
      (extract-required-definitions
       required-globals
       (cdr definitions)
       (if (member (get-name (car definitions)) required-globals)
           (fn (required-definitions remaining-definitions)
               (return (cons (car definitions)
                             required-definitions)
                       remaining-definitions))
           (fn (required-definitions remaining-definitions)
               (return required-definitions
                       (cons (car definitions)
                             remaining-definitions)))))))
(define (process expr declared-globals remaining-definitions return)
  (let ((expr-globals (required-globals expr
                                        declared-globals
                                        remaining-definitions)))
    (extract-required-definitions
     expr-globals remaining-definitions
     (fn (required-definitions remaining-definitions)
         ((foldr (fn (definition tail)
                     (append (print `(define ,(get-name definition)
                                       ,(get-body definition)))
                             tail))
                 (append (print expr)
                         (return remaining-definitions)))
          required-definitions)))))
(define (read-expr cont line-number)
  (parse-expr cont (fn (error-message end-line)
                       (print-error (append "Parse error, line "
                                            (print end-line)
                                            ": " error-message "\n")))
              line-number))
(define (main-loop declared-globals remaining-definitions)
  (fn (value end-line-number)
      (cond ((not value) "")
            ((not (= (car value) 'define))
             (process (escape-statement value)
                      declared-globals
                      remaining-definitions
                      (fn (remaining-definitions) "")))
            ('t (let ((name (get-name value))
                      (declared-globals (cons name declared-globals)))
                  (process (escape-statement value)
                           declared-globals
                           remaining-definitions
                           (fn (remaining-definitions)
                               (read-expr (main-loop declared-globals
                                                     remaining-definitions)
                                          end-line-number))))))))

(define (build-globals library)
  `(define (standard-library name return error)
     ,((foldl (fn (def globals-code)
                  (let ((definition-name (get-name def)))
                    (if (= (car (symbol->string definition-name)) 95)
                        globals-code
                       `(if (= name ,(list 'quote definition-name))
                            (return ,definition-name)
                            ,globals-code))))
              `(if (= name 'standard-library)
                   (return standard-library)
                   (error)))
       library)))
(define standard-library-definitions
  (cons (build-globals base-standard-library-definitions)
        base-standard-library-definitions))
(fn (size arguments)
    (read-expr (main-loop '() standard-library-definitions) 1))
