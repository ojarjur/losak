		Lisp Operating System, Abstraction Kernel
		Programming Language Description
		Copyright (C) 2004 - 2008 by Omar Jarjur

Overview:
    The language implemented by the system is a purely functional 
dialect of Lisp. It uses static scope and an eager evaluation
strategy. It also provides fixed precision integer arithmetic
operations. The mainstream dialect that it most closely resembles is
probably Scheme.
    A losak program is repeatedly evaluated with the result being used
for I/O. Specifically, if a program evaluates to a function then the
next input event (or null if no such events are available) is passed to
this function as a parameter and evaluation continues. Otherwise, if a
program evaluates to a pair, the head of the pair is executed as an
output event, and the tail of the pair is evaluated as the remainder of
the computation.

Kernel Parameters:
    The first input event is a two item list representing the kernel
parameters. The first element of the parameters list is the number of
available cons cells, and the second is a string of parameters. The
parameter string is a list of integers, with each integer representing
the ascii value of a character in the string.

System Input:
    Each of the rest of the input events have the following form. If 
it is (), then no new input is available yet. If it is a number, then it 
is a keycode received from the keyboard. Otherwise, it should be a pair
of numbers, where the first number is an I/O port and the second number
is the value in that port.

    Examples:
    Input = ((1024 ()) 35 18 38 () 38 24 () 28 ...)
        [1024 cons cells available, an empty parameter string, and the
        keycodes 35 18 38 38 24 28 have been received from the keyboard]
    Input = ((1024 (107 101 121 98 111 97 114 100 61 113 119 101 114 116 121)) 35 18 38 38 24 28 ...)
        [1024 cons cells available, parameter string of
        "keyboard=qwerty" passed in, and the keycodes 35 18 38 
        38 24 28 ("hello\r" for qwerty) have been received from 
        the keyboard]

System Output:
    Each output event generated by the program is interpreted as 
follows: If it is a number, then it is the next ascii value to be 
written to the screen. If it is a pair of numbers then the first number
is an I/O port and the second number is a value to be written to that 
port. If it is a list of one number, then it is a request to poll that 
numbered I/O port. If it is a list of two numbers, then the first number 
is a memory location (less than 1 megabyte) and the second number is
a (8-bit) value to be written to that memory location.

Language Constructs:
  A program consists of zero or more define statements followed by an
expression. Any malformed expressions evaluate to (). Each primitive is a
function except for define, quote, fn, cond, and let. Each parameter to a
function is evaluated before that function is applied to it. Pattern
matching is used both in let expressions and in function application.
For example ((fn ((a . b) c) (cons a c)) '(1 . 2) 3) returns (1 . 3).
Syntactic sugar is provided for defining quoted expressions 
and for quoted lists of integers. '<X> is equivalent to
(quote <X>), and "<X><Y><Z>" is equivalent to (quote (<#X> 
<#Y> <#Z>)) where <#X> is the ascii value of the character <X>. 
So "hello" will be parse as (quote (104 101 108 108 111)).

  (define (<NAME> . <ARGS>) <BODY>) : Add a new function with the name
        <NAME>, arg list of <ARGS>, and body of <BODY> to the global
        definitions. This is only allowed at the top level; anywhere else
        it will simply evaluate to ().
  (define <NAME> <EXPR>) : Evaluate <EXPR> and add it to the global
        definitions with the name <NAME>. This is only allowed at the top
        level; anywhere else it will simply evaluate to ().
  (quote <X>) or '<X> : Return <X> without evaluating it.
  (cons <X> <Y>) : Return the pair (<X> . <Y>)
  (car <X>) : If <X> is a pair return its first element. Otherwise return ().
  (cdr <X>) : If <X> is a pair return its second element. Otherwise return ().
  (atom <X>) : If <X> is an atom return a non-nil value. Otherwise return ().
  (number <X>) : If <X> is a number return a non-nil value. Otherwise
        return ().
  (function <X>) : If <X> is a function return a non-nil value. Otherwise
        return ().
  (= <X> <Y>) : Return a non-nil value if <X> and <Y> are the same number or
        the same symbol. Otherwise return ().
  (< <X> <Y>) : Return a non-nil value if <X> and <Y> are numbers and <X> is
        less than <Y>, or if <X> and <Y> are symbols and <X> 
		alphabetically precedes <Y> (In terms of ASCII characters).
		Otherwise return ().
  (> <X> <Y>) : Return a non-nil value if <X> and <Y> are numbers and <X> is
        greater than <Y>, or if <X> and <Y> are symbols and <X> 
		alphabetically follows <Y> (In terms of ASCII characters).
		Otherwise return ().
  (+ <X> <Y>) : Return the sum of the two numbers <X> and <Y>.
  (- <X>) : Return the negation of <X>.
  (- <X> <Y>) : Return the difference of the two numbers <X> and <Y>.
  (* <X> <Y>) : Return the product of the two numbers <X> and <Y>.
  (/ <X> <Y>) : Return the integer quotient of <X> divided by <Y>.
  (% <X> <Y>) : Return the integer remainder of <X> divided by <Y>.
  (>> <X> <Y>) : Signed right shift of <X> by <Y> places.
  (>>> <X> <Y>) : Unsigned right shift of <X> by <Y> places.
  (<< <X> <Y>) : Left shift of <X> by <Y> places.
  (& <X> <Y>) : Return the bitwise and of <X> and <Y>.
  (| <X> <Y>) : Return the bitwise or of <X> and <Y>.
  (^ <X> <Y>) : Return the bitwise xor of <X> and <Y>.
  (~ <X>) : Return the bitwise negation of <X>.
  (fn <ARGS> <EXPR>) : Return a static scoped function with the argument
		list <ARGS> and the value <EXPR>.
  (cond (<T1> <E1>) (<T2> <E2>) ...) : Repeatedly evaluate a <TN> until 
		one of them returns a value other than (). At that 
		point evaluate the corresponding <EN> and return its 
		value. If every <TN> returns (), then return ().
  (let ((<VAR1> <VAL1>) (<VAR2> <VAL2>) ... ) <EXPR>):
		Evaluate each <VALN> and bind its value to the 
		corresponding <VARN>. Then evaluate <EXPR> in the new
		environment and return its value.
  (<FN> . <ARGS>) : If <FN> is a function then evaluate 
		<ARGS> and apply the function to it. Otherwise 
		return ().
