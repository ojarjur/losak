;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Losak compiler                                                  ;;
;;                                                                 ;;
;; This intermediated-stage of the compiler builds a compile-time  ;;
;; symbol table and adds primitives for converting between symbols ;;
;; and strings. The actual primitives that are defined here are:   ;;
;;   symbol?                                                       ;;
;;   symbol->string                                                ;;
;;   string->symbol                                                ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Copyright (C) 2004 - 2012 by Omar Jarjur                        ;;
;;                                                                 ;;
;; This program is free software; you can redistribute it and/or   ;;
;; modify it under the terms of version 2 of the GNU General       ;;
;; Public License as published by the Free Software Foundation.    ;;
;;                                                                 ;;
;; This program is distributed in the hope that it will be useful, ;;
;; but WITHOUT ANY WARRANTY; without even the implied warranty of  ;;
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ;;
;; GNU General Public License for more details.                    ;;
;;                                                                 ;;
;; You should have received a copy of the GNU General Public       ;;
;; License along with this program; if not, write to the Free      ;;
;; Software Foundation, Inc.,                                      ;;
;; 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(load "src/error-handling.lsk")

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for maintaining the symbol table ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (generate-unused-symbol-name symbols initial-symbol-name)
  (if (member (string->symbol initial-symbol-name) symbols)
      (generate-unused-symbol-name symbols
                                   (append "_" initial-symbol-name))
      initial-symbol-name))
(define (build-string->symbol-cases symbols symbol-tag)
  (if (null? symbols)
      `(cons ',symbol-tag chars)
      (let ((next-symbol (car symbols))
            (next-symbol-string (print next-symbol)))
        `(if (equal chars ',next-symbol-string)
             ',next-symbol
           ,(build-string->symbol-cases (cdr symbols) symbol-tag)))))
(define (build-string->symbol symbols symbol-tag)
  (print `(define string->symbol
            (fn (chars)
                ,(build-string->symbol-cases symbols symbol-tag)))))
(define (build-symbol->string-cases symbols)
  (if (null? symbols)
      ''()
      (let ((next-symbol (car symbols))
            (next-symbol-string (print next-symbol)))
        `(if (= symbol ',next-symbol)
             ',next-symbol-string
           ,(build-symbol->string-cases (cdr symbols))))))
(define (build-symbol->string symbols symbol-tag)
  (print `(define symbol->string
            (fn (symbol)
                (if (pair? symbol)
                    (if (equal (car symbol) ',symbol-tag)
                        (cdr symbol)
                      '())
                  ,(build-symbol->string-cases symbols))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to insert symbol-handling ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (escape-args args)
  (if (pair? args)
      (cons (escape-symbols (car args))
            (escape-args (cdr args)))
      (escape-symbols args)))
(define (escape-symbols expr)
  (cond ((null? expr) expr)
        ((number? expr) expr)
        ((= expr '=) '_=)
        ((= expr 'equal) '_equal)
        ((= expr 'symbol?) '_symbol?)
        ((= expr 'pair?) '_pair?)
        ((symbol? expr)
         (let ((symbol-string (symbol->string expr)))
           (if (= (car symbol-string) 95) ;; Underscore
               (string->symbol (cons 95 symbol-string))
               expr)))
        ((= (car expr) 'quote) expr)
        ('t (escape-args expr))))
(define (list-symbols expression result)
  (cond ((pair? expression)
         (list-symbols (car expression)
                       (list-symbols (cdr expression) result)))
        ((symbol? expression)
         (if (member expression result)
             result
             (cons expression result)))
        ('t result)))
(define (find-quoted-symbols expressions result)
  (cond ((not (pair? expressions)) result)
        ((= (car expressions) 'quote)
         (list-symbols (cadr expressions) result))
        ('t ((foldr (fn (expression result)
                        (find-quoted-symbols expression result))
                    result)
             expressions))))
(define (compile definitions expr symbols)
  (if (or (member 'symbol->string symbols)
          (member 'string->symbol symbols)
          (member 'symbol? symbols))
      (let ((symbol-tag-name (generate-unused-symbol-name symbols "symbol-tag"))
            (symbol-tag (string->symbol symbol-tag-name))
            (quoted-symbols (find-quoted-symbols (cons expr definitions) '())))
        (append "(define equal\n"
                "  (fn (x y)\n"
                "    (if (pair? x)\n"
                "        (if (pair? y)\n"
                "            (if (equal (car x) (car y))\n"
                "                (equal (cdr x) (cdr y))\n"
                "                '())\n"
                "            '())\n"
                "        (= x y))))\n"
                (build-symbol->string quoted-symbols symbol-tag)
                "\n"
                (build-string->symbol quoted-symbols symbol-tag)
                "\n"
                "(define _symbol?\n"
                "  (fn (expr)\n"
                "    (if (null? expr)\n"
                "        '()\n"
                "        (if (number? expr)\n"
                "            '()\n"
                "            (if (function? expr)\n"
                "                '()\n"
                "                (if (pair? expr)\n"
                "                    (if (= (car expr) '" symbol-tag-name ")\n"
                "                        't\n"
                "                        '())\n"
                "                    't))))))\n"
                "(define _pair?\n"
                "  (fn (expr)\n"
                "    (if (pair? expr)\n"
                "        (if (= (car expr) '" symbol-tag-name ")\n"
                "            '()\n"
                "            't)\n"
                "        '())))\n"
                "(define _=\n"
                "  (fn (x y)\n"
                "    (if (_pair? x)\n"
                "        '()\n"
                "        (equal x y))))\n"
                (apply append (map print
                                   (map escape-symbols definitions)))
                (print (escape-symbols expr))))
      (append (apply append (map print definitions))
              (print expr))))

;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the input ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (read-expr cont line-number)
  (parse-expr cont (fn (error-message end-line)
                       (print-error (append "Parse error, line "
                                            (print end-line)
                                            ": " error-message "\n")))
              line-number))
(define (compile-source definitions start-line-number symbols)
  (fn (value end-line-number peeked-char)
      (cond ((not value)
             (print-error "No main expression"))
            ((not (= (car value) 'define))
             (compile (reverse definitions)
                      value
                      (list-symbols value symbols)))
            ((not (or (symbol? (cadr value)) (symbol? (caadr value))))
             (print-error "Malformed define statement"))
            ('t ((read-expr (compile-source (cons value definitions)
                                            end-line-number
                                            (list-symbols value symbols))
                            end-line-number)
                 peeked-char)))))
(fn (size arguments) (read-expr (compile-source '() 1 '()) '() 1))
