;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This program takes as input a highly structured subset of ;;
;; the LOSAK language, and generates equivalent C programs.  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Input language:                                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; <PROGRAM> ::= (<DEFINITION>)* <EXPR>                                   ;;
;; <DEFINITION> ::= '(' 'define' <VAR> <EXPR> ')'                         ;;
;; <EXPR> ::= <LET> | <APP> | <IF> | <VAL>                                ;;
;; <LET> ::= '(' 'let' '(' (<BINDING>)* ')' <EXPR> ')'                    ;;
;; <BINDING> ::= '(' <VAR> <VAL> ')'                                      ;;
;; <APP> ::= '(' <VAL> . <VAL> ')'                                        ;;
;; <IF> ::= '(' 'if' <VAL> <EXPR> <EXPR> ')'                              ;;
;; <VAL> ::= <VAR> | <LITERAL> | <PRIMITIVE>                              ;;
;; <LITERAL> ::= <NUMBER> | '(' 'quote' <S-EXPR> ')'                      ;;
;; <PRIMITIVE> ::=                                                        ;;
;;    <UNARY_PRIMITIVE> | <BINARY_PRIMITIVE> | <LAMBDA> | <LIFTED_LAMBDA> ;;
;; <UNARY_PRIMITIVE> ::= '(' <UNARY_OP> <VAL> ')'                         ;;
;; <BINARY_PRIMITIVE> ::= '(' <BINARY_OP> <VAL> <VAL> ')'                 ;;
;; <LIFTED_LAMBDA> ::= '(' <VAR> . <VAR> ')'                              ;;
;; <LAMBDA> ::= '(' 'fn' <VAR> <EXPR> ')'                                 ;;
;; <UNARY_OP> ::=                                                         ;;
;;    'null?' | 'pair?' | 'symbol?' | 'function?' | 'number?' |           ;;
;;    'serialized-size' | 'car' | 'cdr' | '-' | '~'                       ;;
;; <BINARY_OP> ::=                                                        ;;
;;    'cons' | '=' | '<' | '>' | '+' | '-' | '*' | '/' | '%' |            ;;
;;    '&' | '|' | '^' | '>>' | '>>>' | '<<'                               ;;
;;                                                                        ;;
;; There are some important constraints on the input language that must   ;;
;; enforced by the preceding compilation passes in order for this pass    ;;
;; to produce correct code. These are:                                    ;;
;;  1. The only non-tail calls allowed are to global methods which        ;;
;;     immediately return a function closure.                             ;;
;;  2. The only free variable in a function is the one bound by the       ;;
;;     parameter of the immediately enclosing function.                   ;;
;;  3. There are no duplicate variable bindings within a single scope.    ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;
;; Output handling ;;
;;;;;;;;;;;;;;;;;;;;;
(define print-error
  (foldr (fn (char output) (cons (list (cons 2 char)) output)) ()))
(define (escape-char char chars)
  (cond ((= char 99) (append "c" (print char) chars))
        ((and (> char 96) (< char 123)) (cons char chars))
        ((and (> char 64) (< char 91)) (cons char chars))
        ((= char 65) (cons char chars))
        ('t (append "c" (print char) chars))))
(define (escape-symbol-name symbol)
  ((foldr escape-char "") (symbol->string symbol)))
(define (print-symbol symbol)
  (if (symbol? symbol)
      (append "s_" (escape-symbol-name symbol))
      "nil()"))

;;;;;;;;;;;;;;;;;;;;;;;
;; Output formatting ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (format-code code indent suffix)
  (cond ((null? code) suffix)
        ((function? code) (code indent suffix))
        ('t (append indent code "\n" suffix))))
(define (format-code-parts code-parts indent suffix)
  (if (null? code-parts)
      suffix
    (format-code (car code-parts)
                 indent
                 (format-code-parts (cdr code-parts)
                                    indent
                                    suffix))))
(define (code-block . code-parts)
  (fn (indent suffix)
      (format-code-parts code-parts indent suffix)))
(define (indent . code-parts)
  (fn (indent suffix)
      (format-code-parts code-parts (append "  " indent) suffix)))
(define (no-code indent suffix) suffix)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile-time symbol table ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Trie :: V,R=>([Char],V,TrieReturn<V,R>)->R
;; TrieReturn :: V,R=>(V,Trie<V,R>)->R
;; TrieChildren :: V,R=>(Char,[Char],V,TrieChildrenReturn<V,R>)->R
;; TrieChildrenReturn :: V,R=>(V,TrieChildren<V,R>)->R
(define (empty-trie-node children)
  (fn (string default-value return)
      (if (null? string)
          (return default-value
                  (trie-node default-value children))
          (children (car string) (cdr string) default-value
                    (fn (found-value children)
                        (return found-value
                                (empty-trie-node children)))))))
(define (trie-node value children)
  (fn (string default-value return)
      (if (null? string)
          (return value (trie-node value children))
          (children (car string) (cdr string) default-value
                    (fn (found-value children)
                        (return found-value
                                (trie-node value children)))))))
(define (empty-trie-children char remaining-chars default-value return)
  (empty-trie remaining-chars default-value
              (fn (found-value child-trie)
                  (return found-value
                          (add-trie-node char child-trie
                                         empty-trie-children)))))
(define (add-trie-node key trie-node trie-nodes)
  (fn (char remaining-chars default-value return)
      (if (= char key)
          (trie-node remaining-chars default-value
                     (fn (found-value trie-node)
                         (return found-value
                                 (add-trie-node key trie-node trie-nodes))))
          (trie-nodes char remaining-chars default-value
                      (fn (found-value trie-nodes)
                          (return found-value
                                  (add-trie-node key trie-node
                                                 trie-nodes)))))))
(define empty-trie (empty-trie-node empty-trie-children))

(define (make-symbol-table trie next-symbol-id)
  (fn (symbol return)
      (let ((string (symbol->string symbol)))
        (trie string next-symbol-id
              (fn (symbol-id trie)
                  (let ((is-new (= symbol-id next-symbol-id))
                        (next-symbol-id (if is-new
                                            (+ next-symbol-id 1)
                                            next-symbol-id))
                        (symbol-table (make-symbol-table trie
                                                         next-symbol-id)))
                    (return symbol-id symbol-table is-new)))))))
(define initial-symbol-table (make-symbol-table empty-trie 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compilation context (next label, symbol table, declared globals, etc) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (compiler-context next-label symbol-table
                          declared-globals declarations methods
                          next-body-number next-local-var)
  (fn (op) (op next-label symbol-table declared-globals
               declarations methods next-body-number next-local-var)))
(define (lookup-symbol symbol context return)
  (context
   (fn (next-label symbol-table declared-globals declarations
                   methods next-body-number next-local-var)
       (symbol-table symbol
                     (fn (symbol-id symbol-table is-new)
                         (return symbol-id
                                 (compiler-context next-label
                                                   symbol-table
                                                   declared-globals
                                                   declarations
                                                   methods
                                                   next-body-number
                                                   next-local-var)))))))
(define (get-next-label context return)
  (context (fn (next-label symbol-table declared-globals declarations
                           methods next-body-number next-local-var)
               (return next-label
                       (compiler-context (+ next-label 1)
                                         symbol-table
                                         declared-globals
                                         declarations
                                         methods
                                         next-body-number
                                         next-local-var)))))
(define (get-next-local-variable context)
  (context (fn (next-label symbol-table declared-globals declarations
                           methods next-body-number next-local-var)
               (list next-local-var
                     (compiler-context next-label
                                       symbol-table
                                       declared-globals
                                       declarations
                                       methods
                                       next-body-number
                                       (+ next-local-var 1))))))
(define (get-next-body-number context return)
  (context (fn (next-label symbol-table declared-globals declarations
                           methods next-body-number next-local-var)
               (return next-body-number
                       (compiler-context next-label
                                         symbol-table
                                         declared-globals
                                         declarations
                                         methods
                                         (+ next-body-number 1)
                                         next-local-var)))))
(define (declare name context)
  (context (fn (next-label symbol-table declared-globals declarations
                           methods next-body-number next-local-var)
               (declared-globals
                name
                (fn (global-id declared-globals is-new)
                    (if is-new
                        (compiler-context next-label
                                          symbol-table
                                          declared-globals
                                          (code-block (append "pointer "
                                                              (print-symbol name)
                                                              ";")
                                                      declarations)
                                          methods
                                          next-body-number
                                          next-local-var)
                        context))))))
(define (method-declaration method-name)
  (append "function_addr " method-name "(void);"))
(define (method-code method-name param closed-var body)
  (code-block (append "function_addr " method-name "(void) {")
              (indent "target = return_location;"
                      (if (symbol? closed-var)
                          (append "pointer "
                                  (print-symbol closed-var)
                                  " = env;")
                        no-code)
                      (if (symbol? param)
                          (append "pointer "
                                  (print-symbol param)
                                  " = args;")
                        no-code)
                      body
                      "return target;")
              "}"))
(define (add-method param closed-var body context return)
  (context (fn (next-label symbol-table declared-globals declarations
                           methods next-body-number next-local-var)
               (let ((method-name (append "f_" (print next-label)))
                     (next-label (+ next-label 1))
                     (method (method-code method-name param closed-var body)))
                 (return method-name
                         (compiler-context next-label symbol-table
                                           declared-globals
                                           (code-block (method-declaration method-name)
                                                       declarations)
                                           (code-block method methods)
                                           next-body-number
                                           next-local-var))))))
(define (extract-context context return)
  (context (fn (next-label symbol-table declared-globals declarations
                           methods next-body-number next-local-var)
               (let ((context (compiler-context next-label symbol-table
                                                declared-globals '() '()
                                                next-body-number
                                                next-local-var))
                     (cont (return context)))
                 (format-code declarations ""
                              (format-code methods "" cont))))))
(define initial-compiler-context
  (compiler-context 0 initial-symbol-table initial-symbol-table "" "" 0 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Tracking bound local variables ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (empty-env op) (op '() '()))
(define (bind var env)
  (env (fn (outermost-binding bindings)
           (fn (op) (op var (cons var bindings))))))
(define (bind-let var env)
  (env (fn (outermost-binding bindings)
           (fn (op) (op outermost-binding (cons var bindings))))))
(define (bound? var env)
  (env (fn (outermost-binding bindings)
           (member var bindings))))
(define (outermost-binding env)
  (env (fn (outermost-binding bindings)
           outermost-binding)))

;;;;;;;;;;;;;;;;;;;;
;; Value compiler ;;
;;;;;;;;;;;;;;;;;;;;
(define (compile-literal expr suffix compiler-context return)
  (cond ((number? expr)
         (return (append "new_number(" (print expr) ")" suffix)
                 compiler-context))
        ((symbol? expr)
         (lookup-symbol expr compiler-context
                        (fn (symbol-id compiler-context)
                            (return (append "new_symbol("
                                            (print symbol-id)
                                            ")"
                                            suffix)
                                    compiler-context))))
        ((pair? expr)
         (let (((tail-code compiler-context)
                (compile-literal (cdr expr)
                                 (append ")" suffix)
                                 compiler-context list))
               ((head-code compiler-context)
                (compile-literal (car expr)
                                 (append ", " tail-code)
                                 compiler-context list)))
           (return (append "cons(" head-code)
                   compiler-context)))
        ('t (return (append "nil()" suffix) compiler-context))))
(define (compile-boolean test-code destination)
  (append destination " = (" test-code ")?new_number(1):nil();"))
(define (unary-numeric op-code arg-var destination)
  (append destination " = (is_number(" arg-var "))?new_number("
          op-code
          " value(" arg-var ")):nil();"))
(define (binary-numeric op-code arg1-var arg2-var destination)
  (append destination
          " = (is_number(" arg1-var ") & is_number(" arg2-var "))?"
          "new_number(value(" arg1-var ") "
          op-code
          " value(" arg2-var ")):nil();"))
;; TODO; detect chains of numeric operations and generate the code
;; so it does not box/unbox the intermediate values.
(define (compile-unary-primitive op arg env compiler-context destination return)
  (let (((arg1-var-id compiler-context)
         (get-next-local-variable compiler-context))
        (arg1-var (append "arg" (print arg1-var-id)))
        ((arg-code compiler-context)
         (compile-value arg env compiler-context arg1-var list))
        (op-code (cond ((= op '-)
                        (unary-numeric "-" arg1-var destination))
                       ((= op '~)
                        (unary-numeric "~" arg1-var destination))
                       ((= op 'serialized-size)
                        (append destination
                                " = new_number(serialized_size("
                                arg1-var "));"))
                       ((= op 'car)
                        (append "increment_count(" destination
                                " = car(" arg1-var "));"))
                       ((= op 'cdr)
                        (append "increment_count(" destination
                                " = cdr(" arg1-var "));"))
                       ((= op 'null?)
                        (compile-boolean (append "is_nil(" arg1-var ")")
                                         destination))
                       ((= op 'pair?)
                        (compile-boolean (append "is_pair(" arg1-var ")")
                                         destination))
                       ((= op 'symbol?)
                        (compile-boolean (append "is_symbol(" arg1-var ")")
                                         destination))
                       ((= op 'number?)
                        (compile-boolean (append "is_number(" arg1-var ")")
                                         destination))
                       ('t (compile-boolean (append "is_function(" arg1-var ")")
                                            destination)))))
    (return (code-block "{"
                        (indent (append "pointer " arg1-var ";")
                                arg-code
                                op-code
                                (append "decrement_count(" arg1-var ");"))
                        "}")
            compiler-context)))
(define (compile-binary-primitive op arg1 arg2 env compiler-context
                                  destination return)
  (let (((arg1-var-id compiler-context)
         (get-next-local-variable compiler-context))
        (arg1-var (append "arg" (print arg1-var-id)))
        ((arg2-var-id compiler-context)
         (get-next-local-variable compiler-context))
        (arg2-var (append "arg" (print arg2-var-id)))
        ((arg1-code compiler-context)
         (compile-value arg1 env compiler-context arg1-var list))
        ((arg2-code compiler-context)
         (compile-value arg2 env compiler-context arg2-var list))
        (op-code (cond ((= op 'cons)
                        (code-block (append "increment_count(" arg1-var ");")
                                    (append "increment_count(" arg2-var ");")
                                    (append destination " = cons(" arg1-var
                                            ", " arg2-var ");")))
                       ((= op '=)
                        (compile-boolean (append "eq(" arg1-var
                                                 ", " arg2-var ")")
                                         destination))
                       ((= op '<)
                        (compile-boolean (append "(is_number(" arg1-var
                                                 ") & is_number(" arg2-var
                                                 ") & (value(" arg1-var
                                                 ") < value(" arg2-var ")))")
                                         destination))
                       ((= op '>)
                        (compile-boolean (append "(is_number(" arg1-var
                                                 ") & is_number(" arg2-var
                                                 ") & (value(" arg1-var
                                                 ") > value(" arg2-var ")))")
                                         destination))
                       ((= op '+)
                        (binary-numeric "+" arg1-var arg2-var destination))
                       ((= op '-)
                        (binary-numeric "-" arg1-var arg2-var destination))
                       ((= op '*)
                        (binary-numeric "*" arg1-var arg2-var destination))
                       ((= op '/)
                        (binary-numeric "/" arg1-var arg2-var destination))
                       ((= op '%)
                        (binary-numeric "%" arg1-var arg2-var destination))
                       ((= op '&)
                        (binary-numeric "&" arg1-var arg2-var destination))
                       ((= op '|)
                        (binary-numeric "|" arg1-var arg2-var destination))
                       ((= op '^)
                        (binary-numeric "^" arg1-var arg2-var destination))
                       ((= op '>>)
                        (binary-numeric ">>" arg1-var arg2-var destination))
                       ((= op '<<)
                        (binary-numeric "<<" arg1-var arg2-var destination))
                       ('t (append destination " = new_number(((sign_mask >> "
                                   "value(arg2) - 1) ^ -1) & "
                                   "(value(arg1) >> value(arg2)));")))))
    (return (code-block "{"
                        (indent (append "pointer " arg1-var ";")
                                (append "pointer " arg2-var ";")
                                arg1-code
                                arg2-code
                                op-code
                                (append "decrement_count(" arg1-var ");")
                                (append "decrement_count(" arg2-var ");"))
                        "}")
            compiler-context)))
(define (compile-fn param body env compiler-context destination return)
  (let (((body-code compiler-context)
         (compile-expr body (bind param env) compiler-context list))
        (closed-var (outermost-binding env))
        ((method-name compiler-context)
         (add-method param closed-var body-code compiler-context list)))
    (return (if (null? closed-var)
                (append destination
                        " = wrap_function(&"
                        method-name
                        ", nil());")
                (code-block (append "increment_count("
                                    (print-symbol closed-var) ");")
                            (append destination
                                    " = wrap_function(&"
                                    method-name ", "
                                    (print-symbol closed-var) ");")))
            compiler-context)))
(define (compile-lifted-lambda op arg env compiler-context destination return)
  (let ((compiler-context (declare op compiler-context))
        ((code compiler-context)
         (compile-value arg env compiler-context "args" list)))
    (return (code-block "args_backup = args;"
                        code
                        (append "temp_target = function_target("
                                (print-symbol op) ", &end_function);")
                        "env_backup = env;"
                        "env = nil();"
                        "(*((closure_target)temp_target))();"
                        (append destination " = val;")
                        "decrement_count(args);"
                        "args = args_backup;"
                        "env = env_backup;")
            compiler-context)))
(define (compile-value val env compiler-context destination return)
  (cond ((null? val)
         (return (append destination " = nil();") compiler-context))
        ((number? val)
         (return (append destination " = new_number(" (print val) ");")
                 compiler-context))
        ((symbol? val)
         (return (append "increment_count(" destination
                         " = " (print-symbol val) ");")
                 (if (bound? val env)
                     compiler-context
                     (declare val compiler-context))))
        ((= (car val) 'quote)
         (compile-literal (cadr val) ";"
                          compiler-context
                          (fn (code compiler-context)
                              (return (append destination " = " code)
                                      compiler-context))))
        ((= (car val) 'fn)
         (compile-fn (cadr val) (caddr val) env
                     compiler-context destination return))
        ((symbol? (cdr val))
         (compile-lifted-lambda (car val) (cdr val) env
                                compiler-context destination return))
        ((null? (cddr val))
         (compile-unary-primitive (car val) (cadr val) env
                                  compiler-context destination return))
        ('t (compile-binary-primitive (car val) (cadr val) (caddr val)
                                      env compiler-context
                                      destination return))))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Expression compiler ;;
;;;;;;;;;;;;;;;;;;;;;;;;;
(define (compile-if test then else env compiler-context return)
  (let (((return-label compiler-context) (get-next-label compiler-context list))
        ((else-code compiler-context)
         (compile-expr else env compiler-context list))
        ((then-code compiler-context)
         (compile-expr then env compiler-context list))
        ((test-code compiler-context)
         (compile-value test env compiler-context "test" list)))
    (return (code-block test-code
                        "if (is_nil(test)) {"
                        (append "  goto e_" (print return-label) ";")
                        "} else {"
                        "  decrement_count(test);"
                        "  test = nil();"
                        "}"
                        then-code
                        (append "goto r_" (print return-label) ";")
                        (append "\ne_" (print return-label) ":")
                        else-code
                        (append "\nr_" (print return-label) ":"))
            compiler-context)))
(define (compile-let-bindings bindings body env compiler-context return)
  (if (pair? bindings)
      (let ((var (caar bindings))
            (var-name (print-symbol var))
            ((body-code compiler-context)
             (compile-let-bindings (cdr bindings) body (bind-let var env)
                                   compiler-context list))
            ((binding-code compiler-context)
             (compile-value (cadar bindings) env
                            compiler-context var-name list)))
        (return (code-block (append "pointer " var-name ";")
                            binding-code
                            body-code
                            (append "decrement_count(" var-name ");"))
                compiler-context))
    (compile-expr body env compiler-context return)))
(define (compile-let bindings body env compiler-context return)
  (compile-let-bindings bindings body env compiler-context
                        (fn (code compiler-context)
                            (return (code-block "{"
                                                (indent code)
                                                "}")
                                    compiler-context))))
(define (compile-application op args env compiler-context return)
  (if (= (car op) 'fn)
      (compile-let `((,(cadr op) ,args)) (caddr op) env compiler-context return)
      (let (((op-code compiler-context)
             (compile-value op env compiler-context "val" list)))
        (compile-value args env compiler-context "args"
                       (fn (args-code compiler-context)
                           (return (code-block "temp = args;"
                                               args-code
                                               "decrement_count(temp);"
                                               op-code
                                               "decrement_count(env);"
                                               "increment_count(env = function_environment(val));"
                                               "target = function_target(val, &end_function);"
                                               "decrement_count(val);")
                                   compiler-context))))))
(define primitives
  '(cons car cdr = < > + - * / % ~ & | ^ >> >>> <<
         null? number? pair? function? serialized-size))
(define (compile-pair op args env compiler-context return)
  (cond ((= op 'let)
         (compile-let (car args) (cadr args) env compiler-context return))
        ((= op 'if)
         (compile-if (car args) (cadr args) (caddr args) env
                     compiler-context return))
        ((member op primitives)
         (compile-value (cons op args) env compiler-context "val" return))
        ((or (= op 'fn) (= op 'quote))
         (compile-value (cons op args) env compiler-context "val" return))
        ('t (compile-application op args env compiler-context return))))
(define (compile-expr expr env compiler-context return)
  (if (pair? expr)
      (compile-pair (car expr) (cdr expr) env compiler-context return)
      (compile-value expr env compiler-context "val" return)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Generated-code prefix ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define prefix
  (append "#ifdef BARE_HARDWARE\n"
          "#include \"multiboot.h\"\n"
          "#else\n"
          "#include <stdlib.h>\n"
          "#endif\n"
          "#define DEFINE_FUNCTION_HELPERS\n"
          "#include \"mem.h\"\n"
          "#include \"io.h\"\n"
          "typedef function_addr (*closure_target)(void);"
          "pointer make_string(char* str) {\n"
          "  pointer r = nil();\n"
          "  int i = 0;\n"
          "  while ((str > 0) && (str[i] != '\\0')) {\n"
          "    i++;\n"
          "  }\n"
          "  while (i > 0) {\n"
          "    i--;\n"
          "    r = cons(new_number(str[i]), r);\n"
          "  }\n"
          "  return r;\n"
          "}\n"
          "int build_sign_mask() {\n"
          "  int sign_mask;\n"
          "  int t = sign_mask = -1;\n"
          "  while (t < 0) {\n"
          "    sign_mask = t;\n"
          "    t = t << 1;\n"
          "  }\n"
          "  return sign_mask;\n"
          "}\n"
          "pointer val, env, arg1, arg2, args, temp, test, true,\n"
          "  arg1_stack, arg2_stack, args_backup, env_backup, arguments;\n"
          "function_addr target, temp_target, return_location;\n"
          "  int sign_mask;\n"
          "function_addr end_function() {\n"
          "  int return_value;\n"
          "  if (is_number(args)) {\n"
          "    return_value = value(args);\n"
          "  } else {\n"
          "    return_value = 0;\n"
          "  }\n"
          "  decrement_count(args);\n"
          "  decrement_count(env);\n"
          "#ifdef BARE_HARDWARE\n"
          "  if (return_value == 1) {\n"
          "    reboot();\n"
          "  } else {\n"
          "    halt();\n"
          "  }\n"
          "#else\n"
          "  exit(return_value);\n"
          "#endif\n"
          "  // This won't actually happen, but\n"
          "  // we include it for completeness.\n"
          "  return &end_function;\n"
          "}\n"
          "function_addr perform_io() {\n"
          "  while (is_pair(val)) {\n"
          "    execute(car(val));\n"
          "    increment_count(temp = cdr(val));\n"
          "    decrement_count(val);\n"
          "    val = temp;\n"
          "  }\n"
          "  if (is_function(val)) {\n"
          "    decrement_count(env);\n"
          "    target = function_target(val, &end_function);\n"
          "    increment_count(env = function_environment(val));\n"
          "    decrement_count(val);\n"
          "    args = get_input();\n"
          "  } else {\n"
          "    target = &end_function;\n"
          "  }\n"
          "  return target;\n"
          "}\n"
          "function_addr apply_main() {\n"
          "  decrement_count(env);\n"
          "  if (is_function(val)) {\n"
          "    increment_count(env=function_environment(val));\n"
          "    args = cons(free_memory_size(),\n"
          "                cons(arguments,nil()));\n"
          "    target = function_target(val, &end_function);\n"
          "    decrement_count(val);\n"
          "    return_location = &perform_io;\n"
          "  } else {\n"
          "    error(ERR_NO_OS);\n"
          "    env = nil();\n"
          "    target = &end_function;\n"
          "  }\n"
          "  return target;\n"
          "}\n"
          "function_addr body_0(void);\n"
          "#ifdef BARE_HARDWARE\n"
          "pointer get_cmd(unsigned long flags, char* command) {\n"
          "  pointer r = nil();\n"
          "  if (getFlag(flags,2) != 0) {\n"
          "    r = make_string(command);\n"
          "  }\n"
          "  return r;\n"
          "}\n"
          "void main(unsigned long magic,\n"
          "          multiboot_data* boot_data) {\n"
          "#else\n"
          "int main(int argc, char** argv) {\n"
          "#endif\n"
          "  sign_mask = build_sign_mask();\n"
          "#ifdef BARE_HARDWARE\n"
          "  int i = 0;\n"
          "  if ((magic != BOOT_MAGIC) ||\n"
          "      !getFlag(boot_data->flags, 0)) {\n"
          "    error(ERR_BAD_BOOT);\n"
          "    return;\n"
          "  }\n"
          ;; The makefile specifies that the binary should
          ;; start at 0x100000, so the start address for
          ;; the heap should be greater than the size of
          ;; the binary - 0x100000, and the memory size
          ;; should be reduced by the amount of space
          ;; reserved for the binary.
          "  init_mem((void*)0x500000,\n"
          "           ((boot_data->mem_upper*1024) - 0x400000));\n"
          "  init_io();\n"
          "  arguments = get_cmd(\n"
          "    boot_data->flags,\n"
          "    (char*)(boot_data->cmd_line));\n"
          "#else\n"
          "  long int memory_limit = 256 * 1024 * 1024;\n"
          "  void* memory = malloc(memory_limit);\n"
          "  init_mem(memory, memory_limit);\n"
          "  init_io();\n"
          "  arguments = nil();\n"
          "  int i;\n"
          "  for (i = argc - 1; i >= 0; i--) {\n"
          "    arguments = cons(make_string(argv[i]),\n"
          "                     arguments);\n"
          "  }\n"
          "#endif\n"
          "  true = new_number(1);\n"
          "  env = arg1 = arg2 = args = arg1_stack = arg2_stack = temp = test = nil();\n"
          "  closure_target initial_target = &body_0;\n"
          "  target = initial_target;\n"
          "  while (1) {\n"
          "    target = (*((closure_target)target))();\n"
          "  }\n"
          "}\n"))

;;;;;;;;;;;;;;;
;; Main loop ;;
;;;;;;;;;;;;;;;
(define (read-expr cont line-number)
  (parse-expr cont (fn (error-message end-line)
                       (print-error (append "Parse error, line "
                                            (print end-line)
                                            ": " error-message "\n")))
              line-number))
(define suffix (append "  return target;\n"
                       "}\n"))
(define (compile-definition name expr line-number compiler-context peeked-char)
  (let ((label (print-symbol name))
        (compiler-context (declare name compiler-context))
        ((body-number compiler-context)
         (get-next-body-number compiler-context list))
        (method-name (append "body_" (print body-number)))
        (cont-name (append "body_" (print (+ body-number 1))))
        ((def-label compiler-context)
         (get-next-label compiler-context list))
        (def-name (append "def_" (print def-label)))
        (prefix (append "function_addr " cont-name "(void);\n"
                        "function_addr " def-name "() {\n"
                        "  " label " = val;\n"
                        "  return &" cont-name ";\n"
                        "}\n"
                        "function_addr " method-name "(void) {\n"
                        "  target = return_location = &" def-name ";\n"))
        ((expr-code compiler-context)
         (compile-expr expr empty-env compiler-context list)))
    (extract-context compiler-context
                     (fn (context)
                         (append prefix
                                 (format-code expr-code
                                              "  "
                                              (append suffix
                                                      (main line-number
                                                            context
                                                            peeked-char))))))))
(define (compile-main expr compiler-context)
  (let (((body-number compiler-context)
         (get-next-body-number compiler-context list))
        (method-name (append "body_" (print body-number)))
        (prefix (append "function_addr " method-name "(void) {\n"
                        "  target = return_location = &apply_main;\n"))
        ((expr-code compiler-context)
         (compile-expr expr empty-env compiler-context list)))
    (extract-context compiler-context
                     (fn (context)
                         (append prefix (format-code expr-code
                                                     "  "
                                                     suffix))))))
(define (compile start-line compiler-context)
  (fn (expr line-number peeked-char)
      (append "/* line number: " (print start-line) " */\n"
              (if (= (car expr) 'define)
                  (compile-definition (cadr expr) (caddr expr)
                                      line-number compiler-context peeked-char)
                  (compile-main expr compiler-context)))))
(define (main line-number compiler-context peeked-char)
  ((read-expr (compile line-number compiler-context) line-number) peeked-char))
(fn (space args) (append prefix (main 0 initial-compiler-context '())))
