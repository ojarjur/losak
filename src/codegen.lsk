;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This program takes as input a highly structured subset of ;;
;; the LOSAK language, and generates equivalent C programs.  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Input language:                                                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; <PROGRAM> ::= (<DEFINITION>)* <EXPR>                                   ;;
;; <DEFINITION> ::= '(' 'define' <VAR> <EXPR> ')'                         ;;
;; <EXPR> ::= <LET> | <APP> | <IF> | <VAL>                                ;;
;; <LET> ::= '(' 'let' '(' (<BINDING>)* ')' <EXPR> ')'                    ;;
;; <BINDING> ::= '(' <VAR> <VAL> ')'                                      ;;
;; <APP> ::= '(' <VAL> . <VAL> ')'                                        ;;
;; <IF> ::= '(' 'if' <VAL> <EXPR> <EXPR> ')'                              ;;
;; <VAL> ::= <VAR> | <LITERAL> | <PRIMITIVE>                              ;;
;; <LITERAL> ::= <NUMBER> | '(' 'quote' <S-EXPR> ')'                      ;;
;; <PRIMITIVE> ::=                                                        ;;
;;    <UNARY_PRIMITIVE> | <BINARY_PRIMITIVE> | <LAMBDA> | <LIFTED_LAMBDA> ;;
;; <UNARY_PRIMITIVE> ::= '(' <UNARY_OP> <VAL> ')'                         ;;
;; <BINARY_PRIMITIVE> ::= '(' <BINARY_OP> <VAL> <VAL> ')'                 ;;
;; <LIFTED_LAMBDA> ::= '(' <VAR> . <VAR> ')'                              ;;
;; <LAMBDA> ::= '(' 'fn' <VAR> <EXPR> ')'                                 ;;
;; <UNARY_OP> ::=                                                         ;;
;;    'null?' | 'pair?' | 'symbol?' | 'function?' | 'number?' |           ;;
;;    'serialized-size' | 'car' | 'cdr' | '-' | '~'                       ;;
;; <BINARY_OP> ::=                                                        ;;
;;    'cons' | '=' | '<' | '>' | '+' | '-' | '*' | '/' | '%' |            ;;
;;    '&' | '|' | '^' | '>>' | '>>>' | '<<'                               ;;
;;                                                                        ;;
;; There are some important constraints on the input language that must   ;;
;; enforced by the preceding compilation passes in order for this pass    ;;
;; to produce correct code. These are:                                    ;;
;;  1. The only non-tail calls allowed are to global methods which        ;;
;;     immediately return a function closure.                             ;;
;;  2. The only free variable in a function is the one bound by the       ;;
;;     parameter of the immediately enclosing function.                   ;;
;;  3. There are no duplicate variable bindings within a single scope.    ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;
;; Output handling ;;
;;;;;;;;;;;;;;;;;;;;;
(define print-error
  (foldr (fn (char output) (cons (list (cons 2 char)) output)) ()))
(define (escape-char char chars)
  (cond ((= char 99) (append "c" (print char) chars))
        ((and (> char 96) (< char 123)) (cons char chars))
        ((and (> char 64) (< char 91)) (cons char chars))
        ((= char 65) (cons char chars))
        ('t (append "c" (print char) chars))))
(define (escape-symbol-name symbol)
  ((foldr escape-char "") (symbol->string symbol)))
(define (print-symbol symbol)
  (if (symbol? symbol)
      (append "s_" (escape-symbol-name symbol))
      "nil()"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile-time symbol table ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Trie :: V,R=>([Char],V,TrieReturn<V,R>)->R
;; TrieReturn :: V,R=>(V,Trie<V,R>)->R
;; TrieChildren :: V,R=>(Char,[Char],V,TrieChildrenReturn<V,R>)->R
;; TrieChildrenReturn :: V,R=>(V,TrieChildren<V,R>)->R
(define (empty-trie-node children)
  (fn (string default-value return)
      (if (null? string)
          (return default-value
                  (trie-node default-value children))
          (children (car string) (cdr string) default-value
                    (fn (found-value children)
                        (return found-value
                                (empty-trie-node children)))))))
(define (trie-node value children)
  (fn (string default-value return)
      (if (null? string)
          (return value (trie-node value children))
          (children (car string) (cdr string) default-value
                    (fn (found-value children)
                        (return found-value
                                (trie-node value children)))))))
(define (empty-trie-children char remaining-chars default-value return)
  (empty-trie remaining-chars default-value
              (fn (found-value child-trie)
                  (return found-value
                          (add-trie-node char child-trie
                                         empty-trie-children)))))
(define (add-trie-node key trie-node trie-nodes)
  (fn (char remaining-chars default-value return)
      (if (= char key)
          (trie-node remaining-chars default-value
                     (fn (found-value trie-node)
                         (return found-value
                                 (add-trie-node key trie-node trie-nodes))))
          (trie-nodes char remaining-chars default-value
                      (fn (found-value trie-nodes)
                          (return found-value
                                  (add-trie-node key trie-node
                                                 trie-nodes)))))))
(define empty-trie (empty-trie-node empty-trie-children))

(define (make-symbol-table trie next-symbol-id)
  (fn (symbol return)
      (let ((string (symbol->string symbol)))
        (trie string next-symbol-id
              (fn (symbol-id trie)
                  (let ((is-new (= symbol-id next-symbol-id))
                        (next-symbol-id (if is-new
                                            (+ next-symbol-id 1)
                                            next-symbol-id))
                        (symbol-table (make-symbol-table trie
                                                         next-symbol-id)))
                    (return symbol-id symbol-table is-new)))))))
(define initial-symbol-table (make-symbol-table empty-trie 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compilation context (next label, symbol table, declared globals, etc) ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (compiler-context next-label symbol-table
                          declared-globals declarations methods
                          next-body-number next-local-var)
  (fn (op) (op next-label symbol-table declared-globals
               declarations methods next-body-number next-local-var)))
(define (lookup-symbol symbol context return)
  (context
   (fn (next-label symbol-table declared-globals declarations
                   methods next-body-number next-local-var)
       (symbol-table symbol
                     (fn (symbol-id symbol-table is-new)
                         (return symbol-id
                                 (compiler-context next-label
                                                   symbol-table
                                                   declared-globals
                                                   declarations
                                                   methods
                                                   next-body-number
                                                   next-local-var)))))))
(define (get-next-label context return)
  (context (fn (next-label symbol-table declared-globals declarations
                           methods next-body-number next-local-var)
               (return next-label
                       (compiler-context (+ next-label 1)
                                         symbol-table
                                         declared-globals
                                         declarations
                                         methods
                                         next-body-number
                                         next-local-var)))))
(define (get-next-local-variable context)
  (context (fn (next-label symbol-table declared-globals declarations
                           methods next-body-number next-local-var)
               (list next-local-var
                     (compiler-context next-label
                                       symbol-table
                                       declared-globals
                                       declarations
                                       methods
                                       next-body-number
                                       (+ next-local-var 1))))))
(define (get-next-body-number context return)
  (context (fn (next-label symbol-table declared-globals declarations
                           methods next-body-number next-local-var)
               (return next-body-number
                       (compiler-context next-label
                                         symbol-table
                                         declared-globals
                                         declarations
                                         methods
                                         (+ next-body-number 1)
                                         next-local-var)))))
(define (declare name context)
  (context (fn (next-label symbol-table declared-globals declarations
                           methods next-body-number next-local-var)
               (declared-globals
                name
                (fn (global-id declared-globals is-new)
                    (if is-new
                        (compiler-context next-label
                                          symbol-table
                                          declared-globals
                                          (append "pointer "
                                                  (print-symbol name)
                                                  ";\n"
                                                  declarations)
                                          methods
                                          next-body-number
                                          next-local-var)
                        context))))))
(define (add-method param closed-var body context return)
  (context (fn (next-label symbol-table declared-globals declarations
                           methods next-body-number next-local-var)
               (let ((method-name (append "f_" (print next-label)))
                     (next-label (+ next-label 1)))
                 (return method-name
                         (compiler-context next-label symbol-table
                                           declared-globals
                                           (append "function_addr "
                                                   method-name
                                                   "(void);\n"
                                                   declarations)
                                           (cons (list method-name param
                                                       closed-var body)
                                                 methods)
                                           next-body-number
                                           next-local-var))))))
(define (append-method (method-name param closed-var body) cont)
  (append "function_addr "
          method-name
          "(void) {\n"
          "  return_location = &perform_io;\n"
          (if (symbol? param)
              (append "  pointer " (print-symbol param) " = args;\n")
              "")
          (if (symbol? closed-var)
              (append "  pointer " (print-symbol closed-var) " = env;\n")
              "")
          body cont))
(define (extract-context context return)
  (context (fn (next-label symbol-table declared-globals declarations
                           methods next-body-number next-local-var)
               (let ((context (compiler-context next-label symbol-table
                                                declared-globals '() '()
                                                next-body-number
                                                next-local-var))
                     (cont (return context))
                     (cont ((foldl append-method cont) methods)))
                 (append declarations cont)))))
(define initial-compiler-context
  (compiler-context 0 initial-symbol-table initial-symbol-table "" "" 0 0))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Tracking bound local variables ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define empty-env '())
(define (bind var env) (cons var env))
(define (bound? var env) (member var env))
(define (outermost-binding env) (car env))

;;;;;;;;;;;;;;;;;;;;
;; Value compiler ;;
;;;;;;;;;;;;;;;;;;;;
(define (compile-literal expr suffix compiler-context return)
  (cond ((number? expr)
         (return (append "new_number(" (print expr) ")" suffix)
                 compiler-context))
        ((symbol? expr)
         (lookup-symbol expr compiler-context
                        (fn (symbol-id compiler-context)
                            (return (append "new_symbol("
                                            (print symbol-id)
                                            ")"
                                            suffix)
                                    compiler-context))))
        ((pair? expr)
         (let (((tail-code compiler-context)
                (compile-literal (cdr expr)
                                 (append ")" suffix)
                                 compiler-context list))
               ((head-code compiler-context)
                (compile-literal (car expr)
                                 (append ", " tail-code)
                                 compiler-context list)))
           (return (append "cons(" head-code)
                   compiler-context)))
        ('t (return (append "nil()" suffix) compiler-context))))
(define (compile-boolean test-code suffix destination)
  (append "  " destination " = (" test-code ")?new_number(1):nil();\n" suffix))
(define (unary-numeric op-code arg-var suffix destination)
  (append "  " destination " = (is_number(" arg-var "))?new_number("
          op-code
          " value(" arg-var ")):nil();\n"
          suffix))
(define (binary-numeric op-code arg1-var arg2-var suffix destination)
  (append "  " destination
          " = (is_number(" arg1-var ") & is_number(" arg2-var "))?"
          "new_number(value(" arg1-var ") "
          op-code
          " value(" arg2-var ")):nil();\n"
          suffix))
;; TODO; detect chains of numeric operations and generate the code
;; so it does not box/unbox the intermediate values.
(define (compile-unary-primitive op arg env suffix compiler-context
                                 destination return)
  (let (((arg1-var-id compiler-context)
         (get-next-local-variable compiler-context))
        (arg1-var (append "arg" (print arg1-var-id)))
        (suffix (append "  decrement_count(" arg1-var ");\n"
                        "  }\n"
                        suffix)))
    (compile-value arg env
                   (cond ((= op '-)
                          (unary-numeric "-" arg1-var suffix destination))
                         ((= op '~)
                          (unary-numeric "~" arg1-var suffix destination))
                         ((= op 'serialized-size)
                          (append "  " destination
                                  " = new_number(serialized_size(" arg1-var "));\n"
                                  suffix))
                         ((= op 'car)
                          (append "  increment_count(" destination
                                  " = car(" arg1-var "));\n"
                                  suffix))
                         ((= op 'cdr)
                          (append "  increment_count(" destination
                                  " = cdr(" arg1-var "));\n"
                                  suffix))
                         ((= op 'null?)
                          (compile-boolean (append "is_nil(" arg1-var ")")
                                           suffix destination))
                         ((= op 'pair?)
                          (compile-boolean (append "is_pair(" arg1-var ")")
                                           suffix destination))
                         ((= op 'symbol?)
                          (compile-boolean (append "is_symbol(" arg1-var ")")
                                           suffix destination))
                         ((= op 'number?)
                          (compile-boolean (append "is_number(" arg1-var ")")
                                           suffix destination))
                         ('t (compile-boolean (append "is_function(" arg1-var ")")
                                              suffix destination)))
                   compiler-context arg1-var
                   (fn (arg-code compiler-context)
                       (return (append "  {\n"
                                       "  pointer " arg1-var ";\n"
                                       arg-code)
                               compiler-context)))))
(define (compile-binary-primitive op arg1 arg2 env suffix compiler-context
                                  destination return)
  (let (((arg1-var-id compiler-context)
         (get-next-local-variable compiler-context))
        (arg1-var (append "arg" (print arg1-var-id)))
        ((arg2-var-id compiler-context)
         (get-next-local-variable compiler-context))
        (arg2-var (append "arg" (print arg2-var-id)))
        (suffix (append "  decrement_count(" arg1-var ");\n"
                        "  decrement_count(" arg2-var ");\n"
                        "  }\n"
                        suffix))
        ((arg2-code compiler-context)
         (compile-value arg2 env 
                        (cond ((= op 'cons)
                               (append "  increment_count(" arg1-var ");\n"
                                       "  increment_count(" arg2-var ");\n"
                                       "  " destination " = cons(" arg1-var ", " arg2-var ");\n"
                                       suffix))
                              ((= op '=)
                               (compile-boolean (append "eq(" arg1-var ", " arg2-var ")")
                                                suffix destination))
                              ((= op '<)
                               (compile-boolean (append "(is_number(" arg1-var
                                                        ") & is_number(" arg2-var
                                                        ") & (value(" arg1-var
                                                        ") < value(" arg2-var ")))")
                                                suffix destination))
                              ((= op '>)
                               (compile-boolean (append "(is_number(" arg1-var
                                                        ") & is_number(" arg2-var
                                                        ") & (value(" arg1-var
                                                        ") > value(" arg2-var ")))")
                                                suffix destination))
                              ((= op '+)
                               (binary-numeric "+" arg1-var arg2-var
                                               suffix destination))
                              ((= op '-)
                               (binary-numeric "-" arg1-var arg2-var
                                               suffix destination))
                              ((= op '*)
                               (binary-numeric "*" arg1-var arg2-var
                                               suffix destination))
                              ((= op '/)
                               (binary-numeric "/" arg1-var arg2-var
                                               suffix destination))
                              ((= op '%)
                               (binary-numeric "%" arg1-var arg2-var
                                               suffix destination))
                              ((= op '&)
                               (binary-numeric "&" arg1-var arg2-var
                                               suffix destination))
                              ((= op '|)
                               (binary-numeric "|" arg1-var arg2-var
                                               suffix destination))
                              ((= op '^)
                               (binary-numeric "^" arg1-var arg2-var
                                               suffix destination))
                              ((= op '>>)
                               (binary-numeric ">>" arg1-var arg2-var
                                               suffix destination))
                              ((= op '<<)
                               (binary-numeric "<<" arg1-var arg2-var
                                               suffix destination))
                              ('t (append "  " destination " = new_number(((sign_mask >> \n"
                                          "                     value(arg2) - 1) ^ -1) & \n"
                                          "                   (value(arg1) >> \n"
                                          "                    value(arg2)));\n"
                                          suffix)))
                        compiler-context arg2-var list)))
    (compile-value arg1 env arg2-code compiler-context arg1-var
                   (fn (arg-code compiler-context)
                       (return (append "  {\n"
                                       "  pointer " arg1-var ", " arg2-var ";\n"
                                       arg-code)
                               compiler-context)))))
(define (compile-fn param body env suffix compiler-context destination return)
  (let (((body-code compiler-context)
         (compile-expr body (bind param env)
                       (append "  return return_location;\n"
                               "}\n")
                       compiler-context list))
        (closed-var (outermost-binding env))
        ((method-name compiler-context)
         (add-method param closed-var body-code compiler-context list)))
    (return (if (null? closed-var)
                (append "  " destination " = wrap_function(&"
                        method-name ", nil());\n"
                        suffix)
                (append "  increment_count(" (print-symbol closed-var) ");\n"
                        "  " destination " = wrap_function(&"
                        method-name ", " (print-symbol closed-var) ");\n"
                        suffix))
            compiler-context)))
(define (compile-lifted-lambda op arg env suffix compiler-context
                               destination return)
  (let ((compiler-context (declare op compiler-context))
        (suffix (append "  target = function_target(" (print-symbol op) ",\n"
                        "                           &end_function);\n"
                        "  env_backup = env;\n"
                        "  env = nil();\n"
                        "  (*((closure_target)target))();\n"
                        "  " destination " = val;\n"
                        "  decrement_count(args);\n"
                        "  args = args_backup;\n"
                        "  env = env_backup;\n"
                        suffix)))
    (compile-value arg env suffix compiler-context "args"
                   (fn (code compiler-context)
                       (return (append "  args_backup = args;\n"
                                       code)
                               compiler-context)))))
(define (compile-value val env suffix compiler-context destination return)
  (cond ((null? val)
         (return (append "  " destination " = nil();\n" suffix)
                 compiler-context))
        ((number? val)
         (return (append "  " destination
                         " = new_number(" (print val) ");\n"
                         suffix)
                 compiler-context))
        ((symbol? val)
         (return (append "  increment_count(" destination
                         " = " (print-symbol val) ");\n"
                         suffix)
                 (if (bound? val env)
                     compiler-context
                     (declare val compiler-context))))
        ((= (car val) 'quote)
         (compile-literal (cadr val) (append ";\n" suffix)
                          compiler-context
                          (fn (code compiler-context)
                              (return (append "  " destination " = " code)
                                      compiler-context))))
        ((= (car val) 'fn)
         (compile-fn (cadr val) (caddr val) env suffix
                     compiler-context destination return))
        ((symbol? (cdr val))
         (compile-lifted-lambda (car val) (cdr val) env suffix
                                compiler-context destination return))
        ((null? (cddr val))
         (compile-unary-primitive (car val) (cadr val) env suffix
                                  compiler-context destination return))
        ('t (compile-binary-primitive (car val) (cadr val) (caddr val)
                                      env suffix compiler-context
                                      destination return))))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Expression compiler ;;
;;;;;;;;;;;;;;;;;;;;;;;;;
(define (compile-if test then else env suffix compiler-context return)
  (let (((return-label compiler-context) (get-next-label compiler-context list))
        ((else-code compiler-context)
         (compile-expr else env
                       (append "r_" (print return-label) ":\n" suffix)
                       compiler-context list))
        ((then-code compiler-context)
         (compile-expr then env
                       (append "  goto r_" (print return-label) ";\n"
                               "e_" (print return-label) ":\n"
                               else-code)
                       compiler-context list)))
    (compile-value test env
                   (append "  if (is_nil(test)) {\n"
                           "    goto e_" (print return-label) ";\n"
                           "  } else {\n"
                           "    decrement_count(test);\n"
                           "    test = nil();\n"
                           "  }\n"
                           then-code)
                   compiler-context "test" return)))
(define (compile-let bindings body env suffix compiler-context return)
  (if (pair? bindings)
      (let ((var (caar bindings))
            (var-name (print-symbol var))
            ((body-code compiler-context)
             (compile-let (cdr bindings) body (bind var env)
                          (append "  decrement_count(" var-name ");\n"
                                  "  }\n"
                                  suffix)
                          compiler-context list)))
        (compile-value (cadar bindings) env body-code compiler-context var-name
                       (fn (code compiler-context)
                           (return (append "  {\n"
                                           "  pointer " var-name ";\n" code)
                                   compiler-context))))
    (compile-expr body env suffix compiler-context return)))
(define (compile-operator op env suffix compiler-context return)
  (compile-value op env
                 (append "  decrement_count(env);\n"
                         "  increment_count(env = function_environment(val));\n"
                         "  return_location = function_target(\n"
                         "    val, &end_function);\n"
                         "  decrement_count(val);\n"
                         suffix)
                 compiler-context "val" return))
(define (compile-application op args env suffix compiler-context return)
  (if (= (car op) 'fn)
      (compile-let `((,(cadr op) ,args)) (caddr op) env
                    suffix compiler-context return)
      (let (((op-code compiler-context)
             (compile-operator op env suffix compiler-context list)))
        (compile-value args env op-code compiler-context "args" return))))
(define primitives
  '(cons car cdr = < > + - * / % ~ & | ^ >> >>> <<
         null? number? pair? function? serialized-size))
(define (compile-pair op args env suffix compiler-context return)
  (cond ((= op 'let)
         (compile-let (car args) (cadr args) env
                      suffix compiler-context return))
        ((= op 'if)
         (compile-if (car args) (cadr args) (caddr args) env
                     suffix compiler-context return))
        ((member op primitives)
         (compile-value (cons op args) env suffix
                        compiler-context "val" return))
        ((or (= op 'fn) (= op 'quote))
         (compile-value (cons op args) env suffix
                        compiler-context "val" return))
        ('t (compile-application op args env suffix compiler-context return))))
(define (compile-expr expr env suffix compiler-context return)
  (if (pair? expr)
      (compile-pair (car expr) (cdr expr) env suffix compiler-context return)
      (compile-value expr env suffix compiler-context "val" return)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Generated-code prefix ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define prefix
  (append "#ifdef BARE_HARDWARE\n"
          "#include \"multiboot.h\"\n"
          "#else\n"
          "#include <stdlib.h>\n"
          "#endif\n"
          "#define DEFINE_FUNCTION_HELPERS\n"
          "#include \"mem.h\"\n"
          "#include \"io.h\"\n"
          "typedef function_addr (*closure_target)(void);"
          "pointer make_string(char* str) {\n"
          "  pointer r = nil();\n"
          "  int i = 0;\n"
          "  while ((str > 0) && (str[i] != '\\0')) {\n"
          "    i++;\n"
          "  }\n"
          "  while (i > 0) {\n"
          "    i--;\n"
          "    r = cons(new_number(str[i]), r);\n"
          "  }\n"
          "  return r;\n"
          "}\n"
          "int build_sign_mask() {\n"
          "  int sign_mask;\n"
          "  int t = sign_mask = -1;\n"
          "  while (t < 0) {\n"
          "    sign_mask = t;\n"
          "    t = t << 1;\n"
          "  }\n"
          "  return sign_mask;\n"
          "}\n"
          "pointer val, env, arg1, arg2, args, temp, test, true,\n"
          "  arg1_stack, arg2_stack, args_backup, env_backup, arguments;\n"
          "function_addr target, return_location;\n"
          "  int sign_mask;\n"
          "function_addr end_function() {\n"
          "  int return_value;\n"
          "  if (is_number(args)) {\n"
          "    return_value = value(args);\n"
          "  } else {\n"
          "    return_value = 0;\n"
          "  }\n"
          "  decrement_count(args);\n"
          "  decrement_count(env);\n"
          "#ifdef BARE_HARDWARE\n"
          "  if (return_value == 1) {\n"
          "    reboot();\n"
          "  } else {\n"
          "    halt();\n"
          "  }\n"
          "#else\n"
          "  exit(return_value);\n"
          "#endif\n"
          "  // This won't actually happen, but\n"
          "  // we include it for completeness.\n"
          "  return &end_function;\n"
          "}\n"
          "function_addr perform_io() {\n"
          "  while (is_pair(val)) {\n"
          "    execute(car(val));\n"
          "    increment_count(temp = cdr(val));\n"
          "    decrement_count(val);\n"
          "    val = temp;\n"
          "  }\n"
          "  if (is_function(val)) {\n"
          "    decrement_count(env);\n"
          "    target = function_target(val, &end_function);\n"
          "    increment_count(env = function_environment(val));\n"
          "    decrement_count(val);\n"
          "    args = get_input();\n"
          "  } else {\n"
          "    target = &end_function;\n"
          "  }\n"
          "  return target;\n"
          "}\n"
          "function_addr apply_main() {\n"
          "  decrement_count(env);\n"
          "  if (is_function(val)) {\n"
          "    increment_count(env=function_environment(val));\n"
          "    env = cons(cons(free_memory_size(),\n"
          "                    cons(arguments,nil())),\n"
          "               env);\n"
          "    target = function_target(val, &end_function);\n"
          "    decrement_count(val);\n"
          "    return_location = &perform_io;\n"
          "  } else {\n"
          "    error(ERR_NO_OS);\n"
          "    env = nil();\n"
          "    target = &end_function;\n"
          "  }\n"
          "  return target;\n"
          "}\n"
          "function_addr body_0(void);\n"
          "#ifdef BARE_HARDWARE\n"
          "pointer get_cmd(unsigned long flags, char* command) {\n"
          "  pointer r = nil();\n"
          "  if (getFlag(flags,2) != 0) {\n"
          "    r = make_string(command);\n"
          "  }\n"
          "  return r;\n"
          "}\n"
          "void main(unsigned long magic,\n"
          "          multiboot_data* boot_data) {\n"
          "#else\n"
          "int main(int argc, char** argv) {\n"
          "#endif\n"
          "  sign_mask = build_sign_mask();\n"
          "#ifdef BARE_HARDWARE\n"
          "  int i = 0;\n"
          "  if ((magic != BOOT_MAGIC) ||\n"
          "      !getFlag(boot_data->flags, 0)) {\n"
          "    error(ERR_BAD_BOOT);\n"
          "    return;\n"
          "  }\n"
          ;; The makefile specifies that the binary should
          ;; start at 0x100000, so the start address for
          ;; the heap should be greater than the size of
          ;; the binary - 0x100000, and the memory size
          ;; should be reduced by the amount of space
          ;; reserved for the binary.
          "  init_mem((void*)0x500000,\n"
          "           ((boot_data->mem_upper*1024) - 0x400000));\n"
          "  init_io();\n"
          "  arguments = get_cmd(\n"
          "    boot_data->flags,\n"
          "    (char*)(boot_data->cmd_line));\n"
          "#else\n"
          "  long int memory_limit = 128 * 1024 * 1024;\n"
          "  void* memory = malloc(memory_limit);\n"
          "  init_mem(memory, memory_limit);\n"
          "  init_io();\n"
          "  arguments = nil();\n"
          "  int i;\n"
          "  for (i = argc - 1; i >= 0; i--) {\n"
          "    arguments = cons(make_string(argv[i]),\n"
          "                     arguments);\n"
          "  }\n"
          "#endif\n"
          "  true = new_number(1);\n"
          "  env = arg1 = arg2 = args = arg1_stack = arg2_stack = temp = test = nil();\n"
          "  closure_target initial_target = &body_0;\n"
          "  target = initial_target;\n"
          "  while (1) {\n"
          "    target = (*((closure_target)target))();\n"
          "  }\n"
          "}\n"))

;;;;;;;;;;;;;;;
;; Main loop ;;
;;;;;;;;;;;;;;;
(define (read-expr cont line-number)
  (parse-expr cont (fn (error-message end-line)
                       (print-error (append "Parse error, line "
                                            (print end-line)
                                            ": " error-message "\n")))
              line-number))
(define suffix (append "  return return_location;\n"
                       "}\n"))
(define (compile-definition name expr line-number compiler-context peeked-char)
  (let ((label (print-symbol name))
        (compiler-context (declare name compiler-context))
        ((body-number compiler-context)
         (get-next-body-number compiler-context list))
        (method-name (append "body_" (print body-number)))
        (cont-name (append "body_" (print (+ body-number 1))))
        ((def-label compiler-context)
         (get-next-label compiler-context list))
        (def-name (append "def_" (print def-label)))
        (prefix (append "function_addr " cont-name "(void);\n"
                        "function_addr " def-name "() {\n"
                        "  " label " = val;\n"
                        "  return &" cont-name ";\n"
                        "}\n"
                        "function_addr " method-name "(void) {\n"
                        "  return_location = &" def-name ";\n")))
    (compile-expr expr empty-env suffix compiler-context
                  (fn (expr-code compiler-context)
                      (extract-context compiler-context
                                       (fn (context)
                                           (append prefix expr-code
                                                   (main line-number
                                                         context
                                                         peeked-char))))))))
(define (compile-main expr compiler-context)
  (let (((body-number compiler-context)
         (get-next-body-number compiler-context list))
        (method-name (append "body_" (print body-number)))
        (prefix (append "function_addr " method-name "(void) {\n"
                        "  return_location = &apply_main;\n")))
    (compile-expr expr empty-env suffix compiler-context
                  (fn (expr-code compiler-context)
                      (extract-context compiler-context
                                       (fn (context)
                                           (append prefix expr-code)))))))
(define (compile start-line compiler-context)
  (fn (expr line-number peeked-char)
      (append "/* line number: " (print start-line) " */\n"
              (if (= (car expr) 'define)
                  (compile-definition (cadr expr) (caddr expr)
                                      line-number compiler-context peeked-char)
                  (compile-main expr compiler-context)))))
(define (main line-number compiler-context peeked-char)
  ((read-expr (compile line-number compiler-context) line-number) peeked-char))
(fn (space args) (append prefix (main 0 initial-compiler-context '())))
