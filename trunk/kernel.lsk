;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; kernel.lsk : Operating System Written in Lisp                   ;;
;; Copyright (C) 2004 - 2008 by Omar Jarjur                        ;;
;;                                                                 ;;
;; This program is free software; you can redistribute it and/or   ;;
;; modify it under the terms of version 2 of the GNU General       ;;
;; Public License as published by the Free Software Foundation.    ;;
;;                                                                 ;;
;; This program is distributed in the hope that it will be useful, ;;
;; but WITHOUT ANY WARRANTY; without even the implied warranty of  ;;
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ;;
;; GNU General Public License for more details.                    ;;
;;                                                                 ;;
;; You should have received a copy of the GNU General Public       ;;
;; License along with this program; if not, write to the Free      ;;
;; Software Foundation, Inc.,                                      ;;
;; 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (caar x) (car (car x)))
(define (cdar x) (cdr (car x)))
(define (cadr x) (car (cdr x)))
(define (cddr x) (cdr (cdr x)))
(define (id x) x)
(define (list . args) args)
(define (apply op args) (op . args))
(define (recurse op)
  ((fn (this) (op (fn args ((this this) . args))))
   (fn (this) (op (fn args ((this this) . args))))))
(define (equal x y)
        (cond ((atom x) (= x y))
              ((atom y) '())
              ((equal (car x) (car y)) (equal (cdr x) (cdr y)))
              ('t '())))
(define (walk head tail test merge ret)
  (fn (tree)
      (cond ((test tree) (ret tree))
            ('t (merge (head tree)
                       ((walk head tail test merge ret)
                        (tail tree)))))))
(define (fold merge end) (walk car cdr atom merge (fn (val) end)))
(define (foldl merge end)
  (fn (expr)
    (((walk car cdr atom
            (fn (x op) (fn (xs) (op (merge x xs))))
            (fn (x) id))
      expr) end)))
(define (or . args) ((fold (fn (t ts) (cond (t t) ('t ts))) '()) args))
(define (and . args) ((fold (fn (t ts) (cond (t ts) ('t '()))) 't) args))
(define (not test) (cond (test '()) ('t 't)))
(define (append . args) ((fold (fn (x xs) (cond ((= xs '()) x)
                                                ('t ((fold cons xs) x))))
                               '()) args))
(define (length list) ((fold (fn (x y) (+ 1 y)) 0) list))
(define (add . args) ((fold + 0) args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for maintaining the symbol table ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (is_symbol expr) (= (car expr) 'symb))
(define (make-symbol id str) (cons 'symb (fn (op) (op id str))))
(define (symbol->id symbol) ((cdr symbol) (fn (id str) id)))
(define (symbol->string symbol) ((cdr symbol) (fn (id str) str)))
(define (lookup string curr table count return)
  (cond ((atom curr) (return count (cons (cons string count) table)))
        ((equal (caar curr) string) (return (cdar curr) table))
        ('t (lookup string (cdr curr) table (+ count 1) return))))
(define (get-symbol string table return)
  (lookup string table table 0
          (fn (id new-table) (return (make-symbol id string) new-table))))

(define (is_atom expr)
  (cond ((atom expr) 't)
        ((is_symbol expr) 't)
        ('t '())))
(define (is_primitive expr) (atom expr))
(define (is_equal x y)
  (cond ((atom x) (= x y))
        ((atom y) '())
        ((is_symbol x)
         (cond ((is_symbol y) (= (symbol->id x) (symbol->id y)))
               ('t '())))
        ((is_symbol y) '())
        ((is_equal (car x) (car y))
         (is_equal (cdr x) (cdr y)))
        ('t '())))
(define (ccar x) (cond ((is_atom x) ()) ('t (car x))))
(define (ccdr x) (cond ((is_atom x) ()) ('t (cdr x))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper functions for parsing ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (end_of_line chars)
  (or (atom chars)
      (= (car chars) 10)
      (= (car chars) 13)))
(define (discard_line arg) ((walk car cdr end_of_line (fn (c cs) cs) cdr) arg))

(define (escape_char char return rest symbols)
  (return (cond ((= char 116) 9)
                ((= char 114) 13)
                ((= char 110) 10)
                ('t char))
          rest symbols))
(define (build_num chars return rest symbols)
  (return ((foldl (fn (c n) (+ (* 10 n) (- c 48))) 0) chars) rest symbols))
(define (drop_first pair return rest symbols)
  (return (cdr pair) rest symbols))
(define (drop_second pair return rest symbols)
  (return (car pair) rest symbols))
(define (quote-value expr return rest symbols)
  (return (list 'quote expr) rest symbols))
(define (make_symbol chars return rest symbols)
  (cond ((equal chars "cond") (return 'cond rest symbols))
        ((equal chars "let") (return 'let rest symbols))
        ((equal chars "fn") (return 'fn rest symbols))
        ((equal chars "quote") (return 'quote rest symbols))
        ((equal chars "cons") (return 'cons rest symbols))
        ((equal chars "car") (return 'car rest symbols))
        ((equal chars "cdr") (return 'cdr rest symbols))
        ((equal chars "atom") (return 'atom rest symbols))
        ((equal chars "number") (return 'number rest symbols))
        ((equal chars "function") (return 'function rest symbols))
        ((equal chars "=") (return '= rest symbols))
        ((equal chars "<") (return '< rest symbols))
        ((equal chars ">") (return '> rest symbols))
        ((equal chars "+") (return '+ rest symbols))
        ((equal chars "-") (return '- rest symbols))
        ((equal chars "*") (return '* rest symbols))
        ((equal chars "/") (return '/ rest symbols))
        ((equal chars "%") (return '% rest symbols))
        ((equal chars "~") (return '~ rest symbols))
        ((equal chars "&") (return '& rest symbols))
        ((equal chars "|") (return '| rest symbols))
        ((equal chars "^") (return '^ rest symbols))
        ((equal chars ">>") (return '>> rest symbols))
        ((equal chars ">>>") (return '>>> rest symbols))
        ((equal chars "<<") (return '<< rest symbols))
        ((equal chars "define") (return 'define rest symbols))
        ('t (get-symbol chars symbols
                        (fn (id new-symbols)
                          (return id rest new-symbols))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Parser combinators that simplify the process of writting an LL(1) ;;
;; grammar.                                                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Each parser takes a return continuation, an error continuation,   ;;
;; an input string, and a symbol table. They implement a function    ;;
;; that parses the string, and passes the tree, remaining chars, and ;;
;; new symbol table to the return, or "fails" and passes a message,  ;;
;; the remaining chars, and new symbol table to the error.           ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (fail return error input symbols) (error input symbols))
(define (done return error input symbols) (return () input symbols))
(define (check test)
  (fn (return error input symbols)
    (cond ((test (car input)) (return (car input) (cdr input) symbols))
          ('t (error input symbols)))))
(define (pop return error input symbols)
  (cond ((atom input) (error input symbols))
        ('t (return (car input) (cdr input) symbols))))
(define (match char) (check (fn (val) (= val char))))
(define (default parser) (fn (else) parser))
(define (case test then)
  (fn (else)
    (fn (return error input symbols)
      (test (fn (val rest symbols) (then return error rest symbols))
            (fn (rest symbols) (else return error input symbols))
            input symbols))))
(define (choice . args) ((fold (fn (c cs) (c cs)) fail) args))
(define (post-process parser op)
  (fn (return error input symbols)
    (parser (fn (val rest symbols) (op val return rest symbols))
            error input symbols)))
(define (seq parser1 parser2)
  (fn (return error input symbols)
    (parser1 (fn (head next symbols)
                 (parser2 (fn (tail rest symbols)
                              (return (cons head tail) rest symbols))
                          error next symbols))
             error input symbols)))
(define (escape parser) (seq (post-process pop escape_char) parser))
(define (use parser) (seq pop parser))
(define (peek parser)
  (fn (return error input symbols)
    (parser (fn (val rest symbols) (return val input symbols))
            error input symbols)))
(define (interval start end)
  (check (fn (val) (and (> val (- start 1)) (< val (+ end 1))))))
(define (skip parser) (post-process (use parser) drop_first))
(define (first parser1 parser2)
  (post-process (seq parser1 parser2) drop_second))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to parse an s-expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (parse-num . args)
  (apply (choice (case (peek (interval 48 57)) (use parse-num))
                 (default done))
         args))
(define (read-num . args) (apply (post-process parse-num build_num) args))
(define (parse-symbol . args)
  (apply (choice (case (match ()) done)
                 (case (peek (interval 0 32)) done)
                 (case (peek (interval 39 41)) done)
                 (case (peek (match 46)) done)
                 (case (peek (match 59)) done)
                 (default (use parse-symbol)))
         args))
(define (read-symbol . args)
  (apply (post-process parse-symbol make_symbol) args))
(define (parse-string . args)
  (apply (choice (case (match 34) done)
                 (case (match 92) (escape parse-string))
                 (default (use parse-string)))
         args))
(define (quote-parser parser) (post-process parser quote-value))
(define (comment parser)
  (recurse (fn (this) (choice (case (match 10) parser)
                              (case (match 13) parser)
                              (default (skip this))))))
(define (parse-paren . args)
  (apply (choice (case (interval 0 32) parse-paren)
                 (case (match 59) (comment parse-paren))
                 (case (match 41) done))
         args))
(define (parse-pair parser)
  (recurse (fn (this)
               (choice (case (interval 0 32) this)
                       (case (match 59) (comment this))
                       (case (match 41) done)
                       (case (match 46) (first parser parse-paren))
                       (default (seq parser this))))))
(define (parse-expr . args)
  (apply (choice (case (interval 0 32) parse-expr)
                 (case (match 34) (quote-parser parse-string))
                 (case (match 39) (quote-parser parse-expr))
                 (case (match 40) (parse-pair parse-expr))
                 (case (match 41) fail)
                 (case (match 46) fail)
                 (case (match 59) (comment parse-expr))
                 (case (peek (interval 48 57)) read-num)
                 (default read-symbol))
         args))
(define (read chars cont symbol-table)
  (parse-expr cont
              (fn (rest symbols) (cont (err "Parse error") rest symbols))
              chars symbol-table))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to perform error handling ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (err msg) (list 'error msg))
(define (is_error expr) (= (car expr) 'error))
(define (print_error msg) (append "Error: " msg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to print s-expressions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (build_num_str num)
  ((walk (fn (n) (% n 10))
         (fn (n) (/ n 10))
         (fn (n) (= n 0))
         (fn (d op) (fn (str) (op (cons (+ d 48) str))))
         (fn (x) id))
   num))
(define (print_num num)
  (cond ((< num 0) (cons 45 ((build_num_str (- num)) "")))
        ((= num 0) "0")
        ('t ((build_num_str num) ""))))
(define (print_atom expr)
  (cond ((number expr) (print_num expr))
        ((is_symbol expr) (symbol->string expr))
        ((= expr quote) "quote")
        ((= expr car) "car")
        ((= expr cdr) "cdr")
        ((= expr number) "number")
        ((= expr function) "function")
        ((= expr atom) "atom")
        ((= expr cons) "cons")
        ((= expr cond) "cond")
        ((= expr let) "let")
        ((= expr fn) "fn")
        ((= expr >>>) ">>>")
        ((= expr >>) ">>")
        ((= expr <<) "<<")
        ((= expr <) "<")
        ((= expr >) ">")
        ((= expr =) "=")
        ((= expr +) "+")
        ((= expr -) "-")
        ((= expr *) "*")
        ((= expr /) "/")
        ((= expr %) "%")
        ((= expr &) "&")
        ((= expr |) "|")
        ((= expr ^) "^")
        ((= expr ~) "~")
        ((= expr 'define) "define")
        ('t "<INTERNAL ERROR>")))
(define (format_tail_str tail_str)
  (cond ((= (car tail_str) 40)
         (cond ((= (car (cdr tail_str)) 41) (cdr tail_str))
               ('t (cons 32 (cdr tail_str)))))
        ('t (append " . " tail_str ")"))))
(define (print_pair print)
  (fn (head tail_str)
      (append "(" ((print (format_tail_str tail_str)) head))))
(define (append_print tail_str)
  (fn (expr)
      (cond ((= expr ()) (append "()" tail_str))
            ((function expr) (append "<FUNCTION>" tail_str))
            ((is_atom expr) (append (print_atom expr) tail_str))
            ('t ((walk car cdr is_atom
                       (print_pair append_print)
                       (append_print tail_str))
                 expr)))))
(define (print expr) ((append_print "") expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper functions for memory bounded evaluation of an      ;;
;; s-expression                                              ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This evaluator works by passing around size constraints   ;;
;; for each of the data objects being manipulated. Since the ;;
;; data is in the form of trees, the size constraints also   ;;
;; must be trees. Each size constraint tree is either an     ;;
;; integer (representing the size of an atom), or it is a    ;;
;; pair of an integer and a pair of size constraint trees.   ;;
;; In the second case, the integer represents the total size ;;
;; of the tree, and the two integer constraint subtrees are  ;;
;; for the car and cdr of the data tree.                     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (wrap_expr expr size) (cons expr size))
(define (extract_expr wrapped_expr) (car wrapped_expr))
(define (extract_size wrapped_expr) (cdr wrapped_expr))
(define (bounds size) (cond ((number size) size)
                            ((atom size) 0)
                            ('t (car size))))
(define (car_bounds size) (cond ((atom size) 0) ('t (cadr size))))
(define (cdr_bounds size) (cond ((atom size) 0) ('t (cddr size))))
(define (cons_bounds s1 s2)
  (cons (add 1 (bounds s1) (bounds s2)) (cons s1 s2)))
(define (CONS wrapped_expr1 wrapped_expr2)
  (wrap_expr (cons (extract_expr wrapped_expr1)
                   (extract_expr wrapped_expr2))
             (cons_bounds (extract_size wrapped_expr1)
                          (extract_size wrapped_expr2))))
(define (CAR wrapped_expr)
  (wrap_expr (ccar (extract_expr wrapped_expr))
             (car_bounds (extract_size wrapped_expr))))
(define (CDR wrapped_expr)
  (wrap_expr (ccdr (extract_expr wrapped_expr))
             (cdr_bounds (extract_size wrapped_expr))))
(define (ATOM wrapped_expr) (is_atom (extract_expr wrapped_expr)))
(define (EQ expr1 expr2)
  (and (ATOM expr1) (ATOM expr2)
       (is_equal (extract_expr expr1) (extract_expr expr2))))
(define (size . args)
  ((fold (fn (arg total_size)
             (+ total_size (bounds (extract_size arg))))
         0)
   args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper functions for single step evaluation of an ;;
;; s-expression                                      ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (pause cont val) (list 'running (fn () (cont val))))
(define (eval_primitive op args)
  (cond ((= op 'cons) (CONS (CAR args) (CAR (CDR args))))
        ((= op 'car) (CAR (CAR args)))
        ((= op 'cdr) (CDR (CAR args)))
        ((= op 'atom) (ATOM (CAR args)))
        ((= op '=) (EQ (CAR args) (CAR (CDR args))))
        ('t (let ((args_expr (extract_expr args)))
              (wrap_expr (op . args_expr) 1)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Interpreter for lambda-calculus expressions             ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Processes are compiled into these expressions and it is ;;
;; the lambda-calculus interpreter that enforces the rules ;;
;; of memory protection/cooperative multitasking.          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (closure body env)
  (fn (arg mem ret) (cond ((< mem (size arg env)) (err "Out of memory"))
                          ('t (body (CONS arg env) mem ret)))))
(define (FN body env) (wrap_expr (closure body env) (+ (size env) 1)))
(define (ROOT env mem cont) (pause cont env))
(define (HD lookup) (fn (env mem cont)
                        (pause (fn (env) (lookup env mem cont))
                               (CAR env))))
(define (TL lookup) (fn (env mem cont)
                        (pause (fn (env) (lookup env mem cont))
                               (CDR env))))
(define (LIT val) (fn (env mem cont) (pause cont (wrap_expr val 1))))
(define (PRIMITIVE op)
  (LIT (fn (args mem return)
           (let ((result (eval_primitive op args)))
             (cond ((< mem (size result)) (err "Out of memory"))
                   ('t (pause return result)))))))
(define (IF test then else)
  (fn (env mem cont)
      (test env (- mem 1)
            (fn (result) (pause (fn (expr) (expr env mem cont))
                                (cond ((extract_expr result) then)
                                      ('t else)))))))
(define (LAMBDA body)
  (fn (env mem cont) (cond ((< mem 0) (err "Out of memory"))
                           ('t (pause cont (FN body env))))))
(define (APPLY op arg)
  (fn (env mem_limit cont)
      (op env mem_limit
          (fn (op_val) (let ((func (extract_expr op_val))
                             (ret (fn (args) (func args mem_limit cont)))
                             (next (fn (mem) (arg env mem ret))))
                         (pause next (- mem_limit (size op_val))))))))
(define (PAIR arg1 arg2)
  (fn (env mem cont)
      (cond ((< mem 0) (err "Out of memory"))
            ('t (let ((ret (fn (tl) (fn (hd) (pause cont (CONS hd tl))))))
                  (arg2 env mem (fn (tl) (arg1 env (- mem (+ 1 (size tl)))
                                               (ret tl)))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compiler from s-expressions to lambda terms ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (ccaar expr) (ccar (ccar expr)))
(define (ccadr expr) (ccar (ccdr expr)))
(define (ccadar expr) (ccadr (ccar expr)))
(define (ccaddr expr) (ccadr (ccdr expr)))
(define (compile_var var env ret empty)
  (cond ((is_atom env) (cond ((is_equal var env) (ret ROOT))
                             ('t (empty))))
        ('t (compile_var var (ccar env) (fn (e) (ret (HD e)))
                         (fn () (compile_var var (ccdr env)
                                             (fn (e) (ret (TL e)))
                                             empty))))))
(define (compile_find var env) (compile_var var env id (fn () (LIT ()))))
(define (compile_cond compile env)
  (walk ccar ccdr is_atom
        (fn (case else) (IF (compile (ccar case) env)
                            (compile (ccadr case) env)
                            else))
        (fn (body) (LIT ()))))
(define (compile_let compile bindings body env)
  (compile ((walk ccar ccdr is_atom
                  (fn (binding expr)
                      (list (list 'fn (list (ccar binding)) expr)
                            (ccadr binding)))
                  (fn (bindings) body))
            bindings)
           env))
(define (compile_args compile env)
  (walk ccar ccdr is_atom
        (fn (arg arg_list) (PAIR (compile arg env) arg_list))
        (fn (args) (compile args env))))
(define (compile expr env)
  (cond ((= expr ()) (LIT ()))
        ((number expr) (LIT expr))
        ((is_primitive expr) (PRIMITIVE expr))
        ((is_atom expr) (compile_find expr env))
        ((= (car expr) 'cond) ((compile_cond compile env) (cdr expr)))
        ((= (car expr) 'let)
         (compile_let compile (ccadr expr) (ccaddr expr) env))
        ((= (car expr) 'fn)
         (LAMBDA (compile (ccaddr expr) (cons (ccadr expr) env))))
        ((= (car expr) 'quote) (LIT (ccadr expr)))
        ('t (APPLY (compile (car expr) env)
                   ((compile_args compile env) (cdr expr))))))
(define (return_cont result) (list 'done (extract_expr result)))
(define (process expr mem env)
  ((compile expr ()) (wrap_expr () 0) mem return_cont))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to perform process management ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (print_result id status value report)
  (append "\n\r" (print id) ": "
          (cond ((= status 'done) (print value))
                ('t (print_error value)))
          report))
(define (start_process id expr)
  (cons id (process expr 4000 (wrap_expr () 0))))
(define (add_process id status expr (running_procs report))
  (cond ((= status 'running)
         (list (cons (start_process id expr) running_procs) report))
        ('t (list running_procs (print_result id status expr report)))))
(define (check_processes (running_procs report))
  (cons (list running_procs "") report))
(define (schedule (process_list report))
  ((fold (fn ((id status result) (running_procs report))
             (cond ((= status 'running)
                    (list (cons (cons id (result)) running_procs) report))
                   ('t (list running_procs
                             (print_result id status result report)))))
         (list () report))
   process_list))
(define initial_processes (list () ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to perform system I/O ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (qwerty key shift)
  (cond ((or (= key 170) (= key 182)) (cons () ()))
        ((or (= key 42) (= key 54)) (cons () 't))
        ((= key 1) (cons 'escape shift))
        ((= key 2) (cons (cond (shift 33) ('t 49)) shift))
        ((= key 3) (cons (cond (shift 64) ('t 50)) shift))
        ((= key 4) (cons (cond (shift 35) ('t 51)) shift))
        ((= key 5) (cons (cond (shift 36) ('t 52)) shift))
        ((= key 6) (cons (cond (shift 37) ('t 53)) shift))
        ((= key 7) (cons (cond (shift 94) ('t 54)) shift))
        ((= key 8) (cons (cond (shift 38) ('t 55)) shift))
        ((= key 9) (cons (cond (shift 42) ('t 56)) shift))
        ((= key 10) (cons (cond (shift 40) ('t 57)) shift))
        ((= key 11) (cons (cond (shift 41) ('t 48)) shift))
        ((= key 12) (cons (cond (shift 95) ('t 45)) shift))
        ((= key 13) (cons (cond (shift 43) ('t 61)) shift))
        ((= key 14) (cons 'backspace shift))
        ((= key 15) (cons 'tab shift))
        ((= key 16) (cons (cond (shift 81) ('t 113)) shift))
        ((= key 17) (cons (cond (shift 87) ('t 119)) shift))
        ((= key 18) (cons (cond (shift 69) ('t 101)) shift))
        ((= key 19) (cons (cond (shift 82) ('t 114)) shift))
        ((= key 20) (cons (cond (shift 84) ('t 116)) shift))
        ((= key 21) (cons (cond (shift 89) ('t 121)) shift))
        ((= key 22) (cons (cond (shift 85) ('t 117)) shift))
        ((= key 23) (cons (cond (shift 73) ('t 105)) shift))
        ((= key 24) (cons (cond (shift 79) ('t 111)) shift))
        ((= key 25) (cons (cond (shift 80) ('t 112)) shift))
        ((= key 26) (cons (cond (shift 123) ('t 91)) shift))
        ((= key 27) (cons (cond (shift 125) ('t 93)) shift))
        ((or (= key 28) (= key 86)) (cons 'enter shift))
        ((or (= key 29) (= key 87)) (cons 'control shift))
        ((= key 30) (cons (cond (shift 65) ('t 97)) shift))
        ((= key 31) (cons (cond (shift 83) ('t 115)) shift))
        ((= key 32) (cons (cond (shift 68) ('t 100)) shift))
        ((= key 33) (cons (cond (shift 70) ('t 102)) shift))
        ((= key 34) (cons (cond (shift 71) ('t 103)) shift))
        ((= key 35) (cons (cond (shift 72) ('t 104)) shift))
        ((= key 36) (cons (cond (shift 74) ('t 106)) shift))
        ((= key 37) (cons (cond (shift 75) ('t 107)) shift))
        ((= key 38) (cons (cond (shift 76) ('t 108)) shift))
        ((= key 39) (cons (cond (shift 58) ('t 59)) shift))
        ((= key 40) (cons (cond (shift 34) ('t 39)) shift))
        ((= key 41) (cons (cond (shift 126) ('t 96)) shift))
        ((= key 43) (cons (cond (shift 124) ('t 92)) shift))
        ((= key 44) (cons (cond (shift 90) ('t 122)) shift))
        ((= key 45) (cons (cond (shift 88) ('t 120)) shift))
        ((= key 46) (cons (cond (shift 67) ('t 99)) shift))
        ((= key 47) (cons (cond (shift 86) ('t 118)) shift))
        ((= key 48) (cons (cond (shift 66) ('t 98)) shift))
        ((= key 49) (cons (cond (shift 78) ('t 110)) shift))
        ((= key 50) (cons (cond (shift 77) ('t 109)) shift))
        ((= key 51) (cons (cond (shift 60) ('t 44)) shift))
        ((= key 52) (cons (cond (shift 62) ('t 46)) shift))
        ((= key 53) (cons (cond (shift 63) ('t 47)) shift))
        ((= key 55) (cons 42 shift))
        ((or (= key 56) (= key 89)) (cons 'alt shift))
        ((= key 57) (cons 32 shift))
        ((= key 58) (cons 'caps shift))
        ((= key 59) (cons 'F1 shift))
        ((= key 60) (cons 'F2 shift))
        ((= key 61) (cons 'F3 shift))
        ((= key 62) (cons 'F4 shift))
        ((= key 63) (cons 'F5 shift))
        ((= key 64) (cons 'F6 shift))
        ((= key 65) (cons 'F7 shift))
        ((= key 66) (cons 'F8 shift))
        ((= key 67) (cons 'F9 shift))
        ((= key 68) (cons 'F10 shift))
        ((= key 69) (cons 'pause shift))
        ((= key 70) (cons 'scroll_lock shift))
        ((= key 71) (cons (cond (shift 'home) ('t 55)) shift))
        ((= key 72) (cons (cond (shift 'up) ('t 56)) shift))
        ((= key 73) (cons (cond (shift 'pgup) ('t 57)) shift))
        ((= key 74) (cons 45 shift))
        ((= key 75) (cons (cond (shift 'left) ('t 52)) shift))
        ((= key 76) (cons 53 shift))
        ((= key 77) (cons (cond (shift 'right) ('t 54)) shift))
        ((= key 78) (cons 43 shift))
        ((= key 79) (cons (cond (shift 'end) ('t 49)) shift))
        ((= key 80) (cons (cond (shift 'down) ('t 50)) shift))
        ((= key 81) (cons (cond (shift 'pgdn) ('t 51)) shift))
        ((= key 82) (cons (cond (shift 'insert) ('t 48)) shift))
        ((= key 83) (cons (cond (shift 'delete) ('t 46)) shift))
        ((= key 84) (cons 'F11 shift))
        ((= key 85) (cons 'F12 shift))
        ((= key 88) (cons 47 shift))
        ((= key 90) (cons 'num_lock shift))
        ((= key 91) (cons 'home shift))
        ((= key 92) (cons 'up shift))
        ((= key 93) (cons 'pgup shift))
        ((= key 94) (cons 'left shift))
        ((= key 95) (cons 'right shift))
        ((= key 96) (cons 'end shift))
        ((= key 97) (cons 'down shift))
        ((= key 98) (cons 'pgdn shift))
        ((= key 99) (cons 'insert shift))
        ((= key 100) (cons 'delete shift))
        ('t (cons () shift))))
(define (no_keymap key shift)
  (cond ((= key 8) (cons 'backspace shift))
        ((= key 10) (cons 'enter shift))
        ((= key 13) (cons 'enter shift))
        ('t (cons key shift))))
(define keymap qwerty)
(define (trunc chars depth)
  (cond ((atom chars) (cons chars depth))
        ((atom (cdr chars))
         (cond ((= (car chars) 40) (cons () (- depth 1)))
               ((= (car chars) 41) (cons () (+ depth 1)))
               ((= (car chars) 13) (cons chars depth))
               ((= (car chars) 10) (cons chars depth))
               ('t (cons () depth))))
        ('t (let (((cs . depth) (trunc (cdr chars) depth)))
              (cons (cons (car chars) cs) depth)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to perform the main loop of the Operating System ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (run_cmd curr_id cmd shift processes symbol-table)
  (cond ((equal cmd ":q") 0) ;; Shutdown
        ((equal cmd ":r") 1) ;; Reboot
        ((equal cmd ":l")
         (prompt curr_id gpl_str shift processes symbol-table))
        ('t (prompt curr_id help_str shift processes symbol-table))))
(define (prompt curr_id out shift processes symbol-table)
  (cond ((atom out)
         (let (((processes . results) (check_processes processes))
               (output (append results "\n\rexpr " (print curr_id) "> ")))
           (main curr_id output () 0 shift processes symbol-table)))
        ('t (cons (car out)
                  (prompt curr_id (cdr out) shift processes symbol-table)))))
(define (read-return id processes shift symbol-table)
  (fn (expr chars symbol-table)
      (let ((status (cond ((is_error expr) 'error) ('t 'running)))
            (expr (cond ((is_error expr) (cadr expr)) ('t expr)))
            (processes (add_process id status expr processes))
            (id (+ id 1)))
        (prompt id () shift processes symbol-table))))
(define (process_key id curr depth processes symbol-table key shift)
  (cond ((= key ()) (main id () curr depth shift processes symbol-table))
        ((= key 'backspace)
         (let (((new_curr . depth) (trunc curr depth)))
           (main id (cond (curr '(8)) ('t ())) new_curr depth shift
                 processes symbol-table)))
        ((and (= key 'enter) (= curr ()))
         (prompt id () shift processes symbol-table))
        ((and (= key 'enter) (= (car curr) 58))
         (run_cmd id curr shift processes symbol-table))
        ((and (= key 'enter) (> depth 0))
         (main id "\n\r" (append curr "\r") depth shift
               processes symbol-table))
        ((= key 'enter)
         (read curr
               (read-return id processes shift symbol-table)
               symbol-table))
        ('t (let ((depth (+ depth (cond ((= key 40) 1)
                                        ((= key 41) (- 1))
                                        ('t 0))))
                  (key_str (cons key ())))
              (main id key_str (append curr key_str) depth shift
                    processes symbol-table)))))
(define (main curr_id out curr depth shift processes symbol-table)
  (cond ((atom out)
         (fn (in) (let (((key . shift) (keymap in shift))
                        (processes (schedule processes)))
                    (process_key curr_id curr depth processes symbol-table
                                 key shift))))
        ('t (cons (car out)
                  (main curr_id (cdr out) curr depth shift
                        processes symbol-table)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Informational strings  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (init_msg space cmd boot)
  (append "Loaded with " (print_num space) " free cons cells.\n\r"
          "Kernel arguments: " cmd "\n\r"
          boot))
(define help_str (append "\n\rCommands:"
                         "\n\r\t:h - display this help menu"
                         "\n\r\t:l - display license information"
                         "\n\r\t:q - quit (Not implemented, will reboot)"
                         "\n\r\t:r - reboot"
                         "\n\r\t<EXPR> - evaluate the expression <EXPR>"))
(define release_str "\n\rOmar's Lisp Operating System, release 20081002.")
(define gpl_str
  (append release_str
          "\n\rCopyright (C) 2004 - 2008 by Omar Jarjur"
          "\n\n\rThis program is free software. You can redistribute "
          "it and/or modify it under the terms of version 2 of the "
          "GNU General Public License as published by the Free "
          "Software Foundation."
          "\n\n\rThis program is distributed in the hope that it will "
          "be useful, but WITHOUT ANY WARRANTY; without even the "
          "implied warranty of MERCHANTABILITY or FITNESS FOR A "
          "PARTICULAR PURPOSE. See the GNU General Public License for "
          "more details."
          "\n\n\rYou should have received a copy of the GNU General "
          "Public License along with this program; if not, write to "
          "the Free Software Foundation, Inc., 59 Temple Place, "
          "Suite 330, Boston, MA 02111-1307 USA"))
(define boot_str
  (append release_str "\n\rSystem running. Type \":h\" for the help menu."))

;;;;;;;;;;;;;;;;;
;; Entry point ;;
;;;;;;;;;;;;;;;;;
(fn (space boot_args)
    (prompt 0 (init_msg space boot_args boot_str) () () initial_processes))
