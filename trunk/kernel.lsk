;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; kernel.lsk : Operating System Written in Lisp                   ;;
;; Copyright (C) 2004 - 2011 by Omar Jarjur                        ;;
;;                                                                 ;;
;; This program is free software; you can redistribute it and/or   ;;
;; modify it under the terms of version 2 of the GNU General       ;;
;; Public License as published by the Free Software Foundation.    ;;
;;                                                                 ;;
;; This program is distributed in the hope that it will be useful, ;;
;; but WITHOUT ANY WARRANTY; without even the implied warranty of  ;;
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ;;
;; GNU General Public License for more details.                    ;;
;;                                                                 ;;
;; You should have received a copy of the GNU General Public       ;;
;; License along with this program; if not, write to the Free      ;;
;; Software Foundation, Inc.,                                      ;;
;; 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (walk head tail test merge ret)
  (fn (tree)
      (cond ((test tree) (ret tree))
            ('t (merge (head tree)
                       ((walk head tail test merge ret)
                        (tail tree)))))))
(define (add . args) ((foldr + 0) args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to parse an s-expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define initial-reader
  (parse-expr (fn (expression line-number)
                  (list 'read expression))
              (fn (error-message error-line-number)
                  (list 'error (append "Parse error, line "
                                       (print error-line-number)
                                       ": " error-message "\n\r")))
              1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to perform error handling ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (err msg) (list 'error msg))
(define (is_error expr) (= (car expr) 'error))
(define (print_error msg) (append "Error: " msg))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper functions for memory bounded evaluation of an      ;;
;; s-expression                                              ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This evaluator works by passing around size constraints   ;;
;; for each of the data objects being manipulated. Since the ;;
;; data is in the form of trees, the size constraints also   ;;
;; must be trees. Each size constraint tree is either an     ;;
;; integer (representing the size of an atom), or it is a    ;;
;; pair of an integer and a pair of size constraint trees.   ;;
;; In the second case, the integer represents the total size ;;
;; of the tree, and the two integer constraint subtrees are  ;;
;; for the car and cdr of the data tree.                     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (wrap_expr expr size) (cons expr size))
(define (extract_expr wrapped_expr) (car wrapped_expr))
(define (extract_size wrapped_expr) (cdr wrapped_expr))
(define (bounds size) (cond ((number size) size)
                            ((atom size) 0)
                            ('t (car size))))
(define (car_bounds size) (cond ((atom size) 0) ('t (cadr size))))
(define (cdr_bounds size) (cond ((atom size) 0) ('t (cddr size))))
(define (cons_bounds s1 s2)
  (cons (add 1 (bounds s1) (bounds s2)) (cons s1 s2)))
(define (CONS wrapped_expr1 wrapped_expr2)
  (wrap_expr (cons (extract_expr wrapped_expr1)
                   (extract_expr wrapped_expr2))
             (cons_bounds (extract_size wrapped_expr1)
                          (extract_size wrapped_expr2))))
(define (CAR wrapped_expr)
  (wrap_expr (car (extract_expr wrapped_expr))
             (car_bounds (extract_size wrapped_expr))))
(define (CDR wrapped_expr)
  (wrap_expr (cdr (extract_expr wrapped_expr))
             (cdr_bounds (extract_size wrapped_expr))))
(define (ATOM wrapped_expr) (atom (extract_expr wrapped_expr)))
(define (EQ expr1 expr2)
  (and (ATOM expr1) (ATOM expr2)
       (equal (extract_expr expr1) (extract_expr expr2))))
(define (size . args)
  ((foldl (fn (arg total_size)
              (+ total_size (bounds (extract_size arg))))
          0)
   args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper functions for single step evaluation of an ;;
;; s-expression                                      ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (pause cont val) (list 'running (fn () (cont val))))
(define (eval_primitive op args)
  (cond ((= op 'cons) (CONS (CAR args) (CAR (CDR args))))
        ((= op 'car) (CAR (CAR args)))
        ((= op 'cdr) (CDR (CAR args)))
        ((= op 'atom) (ATOM (CAR args)))
        ((= op '=) (EQ (CAR args) (CAR (CDR args))))
        ('t (let ((args_expr (extract_expr args)))
              (wrap_expr (op . args_expr) 1)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Interpreter for lambda-calculus expressions             ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Processes are compiled into these expressions and it is ;;
;; the lambda-calculus interpreter that enforces the rules ;;
;; of memory protection/cooperative multitasking.          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Binding environment functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define primitives
  '(cons car cdr = < > + - * / % >> >>> << & ^ | atom function number))
(define (closure body env)
  (fn (arg globals mem ret)
      (cond ((< mem (size arg env)) (err "Out of memory"))
            ('t (body (CONS arg env) globals mem ret)))))
(define (FN body env) (wrap_expr (closure body env) (+ (size env) 1)))
(define (ROOT env globals mem cont) (pause cont env))
(define (HD lookup) (fn (env globals mem cont)
                        (pause (fn (env) (lookup env globals mem cont))
                               (CAR env))))
(define (TL lookup) (fn (env globals mem cont)
                        (pause (fn (env) (lookup env globals mem cont))
                               (CDR env))))
(define (FIND_GLOBAL var cont)
  (fn (globals)
      (cond ((atom globals) (pause cont (wrap_expr () 1)))
            ((= var (caar globals)) (pause cont (cdar globals)))
            ('t (pause (FIND_GLOBAL var cont) (cdr globals))))))
(define (FIND var)
  (fn (env globals mem cont) ((FIND_GLOBAL var cont) globals)))
(define (LIT val) (fn (env globals mem cont) (pause cont (wrap_expr val 1))))
(define (PRIMITIVE op)
  (LIT (fn (args globals mem return)
           (let ((result (eval_primitive op args)))
             (cond ((< mem (size result)) (err "Out of memory"))
                   ('t (pause return result)))))))
(define (IF test then else)
  (fn (env globals mem cont)
      (test env globals (- mem 1)
            (fn (result) (pause (fn (expr) (expr env globals mem cont))
                                (cond ((extract_expr result) then)
                                      ('t else)))))))
(define (LAMBDA body)
  (fn (env globals mem cont)
      (cond ((< mem 0) (err "Out of memory"))
            ('t (pause cont (FN body env))))))
(define (APPLY op arg)
  (fn (env globals mem_limit cont)
      (op env globals mem_limit
          (fn (op_val)
              (let ((func (extract_expr op_val))
                    (ret (fn (args) (func args globals mem_limit cont)))
                    (next (fn (mem) (arg env globals mem ret))))
                (pause next (- mem_limit (size op_val))))))))
(define (PAIR arg1 arg2)
  (fn (env globals mem cont)
      (cond ((< mem 0) (err "Out of memory"))
            ('t (let ((ret (fn (tl) (fn (hd) (pause cont (CONS hd tl))))))
                  (arg2 env globals mem
                        (fn (tl) (arg1 env globals
                                       (- mem (+ 1 (size tl)))
                                       (ret tl)))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compiler from s-expressions to lambda terms ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (compile_var var env ret empty)
  (cond ((atom env) (cond ((equal var env) (ret ROOT))
                          ('t (empty))))
        ('t (compile_var var (car env) (fn (e) (ret (HD e)))
                         (fn () (compile_var var (cdr env)
                                             (fn (e) (ret (TL e)))
                                             empty))))))
(define (compile_find var env) (compile_var var env id (fn () (FIND var))))
(define (compile_cond compile env)
  (walk car cdr atom
        (fn (case else) (IF (compile (car case) env)
                            (compile (cadr case) env)
                            else))
        (fn (body) (LIT ()))))
(define (compile_let compile bindings body env)
  (compile ((walk car cdr atom
                  (fn (binding expr)
                      (list (list 'fn (list (car binding)) expr)
                            (cadr binding)))
                  (fn (bindings) body))
            bindings)
           env))
(define (compile_args compile env)
  (walk car cdr atom
        (fn (arg arg_list) (PAIR (compile arg env) arg_list))
        (fn (args) (compile args env))))
(define (compile expr env)
  (cond ((= expr ()) (LIT ()))
        ((number expr) (LIT expr))
        ((member expr primitives) (PRIMITIVE expr))
        ((atom expr) (compile_find expr env))
        ((= (car expr) 'cond) ((compile_cond compile env) (cdr expr)))
        ((= (car expr) 'let)
         (compile_let compile (cadr expr) (caddr expr) env))
        ((= (car expr) 'fn)
         (LAMBDA (compile (caddr expr) (cons (cadr expr) env))))
        ((= (car expr) 'quote) (LIT (cadr expr)))
        ('t (APPLY (compile (car expr) env)
                   ((compile_args compile env) (cdr expr))))))
(define (return_cont result) (list 'done (extract_expr result)))
(define (define_cont result) (list 'define result))
(define (process expr mem env globals)
  ((compile expr ()) (wrap_expr () 0) globals mem return_cont))
(define (process-define expr mem env globals)
  ((compile expr ()) (wrap_expr () 0) globals mem define_cont))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to perform process management ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (print_result id status value report)
  (append "\n\r" (print id) ": "
          (cond ((= status 'done) (print value))
                ((= status 'define) "added to global definitions")
                ('t (print_error value)))
          report))
(define (start_define head body globals)
  (cond ((atom head)
         (cons head (process-define body 4000 (wrap_expr () 0) globals)))
        ('t (cons (car head)
                  (process-define (list 'fn (cdr head) body) 4000
                                  (wrap_expr () 0) globals)))))
(define (start_process id expr globals)
  (cond ((= (car expr) 'define)
         (start_define (cadr expr) (car (cddr expr)) globals))
        ('t (cons id (process expr 4000 (wrap_expr () 0) globals)))))
(define (add_process id status expr (running_procs report) globals)
  (cond ((= status 'running)
         (list (cons (start_process id expr globals) running_procs) report))
        ('t (list running_procs (print_result id status expr report)))))
(define (check_processes (running_procs report))
  (cons (list running_procs "") report))
(define (schedule (process_list report) globals)
  ((foldr (fn ((id status result) (globals running_procs report))
              (cond ((= status 'running)
                     (list globals (cons (cons id (result)) running_procs) report))
                    ((= status 'define)
                     (list (cons (cons id result) globals)
                           running_procs
                           (print_result id status result report)))
                    ('t (list globals
                              running_procs
                              (print_result id status result report)))))
          (list globals () report))
   process_list))
(define initial_processes (list () ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to perform system I/O ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (qwerty key shift)
  (cond ((or (= key 170) (= key 182)) (cons () ()))
        ((or (= key 42) (= key 54)) (cons () 't))
        ((= key 1) (cons 'escape shift))
        ((= key 2) (cons (cond (shift 33) ('t 49)) shift))
        ((= key 3) (cons (cond (shift 64) ('t 50)) shift))
        ((= key 4) (cons (cond (shift 35) ('t 51)) shift))
        ((= key 5) (cons (cond (shift 36) ('t 52)) shift))
        ((= key 6) (cons (cond (shift 37) ('t 53)) shift))
        ((= key 7) (cons (cond (shift 94) ('t 54)) shift))
        ((= key 8) (cons (cond (shift 38) ('t 55)) shift))
        ((= key 9) (cons (cond (shift 42) ('t 56)) shift))
        ((= key 10) (cons (cond (shift 40) ('t 57)) shift))
        ((= key 11) (cons (cond (shift 41) ('t 48)) shift))
        ((= key 12) (cons (cond (shift 95) ('t 45)) shift))
        ((= key 13) (cons (cond (shift 43) ('t 61)) shift))
        ((= key 14) (cons 'backspace shift))
        ((= key 15) (cons 'tab shift))
        ((= key 16) (cons (cond (shift 81) ('t 113)) shift))
        ((= key 17) (cons (cond (shift 87) ('t 119)) shift))
        ((= key 18) (cons (cond (shift 69) ('t 101)) shift))
        ((= key 19) (cons (cond (shift 82) ('t 114)) shift))
        ((= key 20) (cons (cond (shift 84) ('t 116)) shift))
        ((= key 21) (cons (cond (shift 89) ('t 121)) shift))
        ((= key 22) (cons (cond (shift 85) ('t 117)) shift))
        ((= key 23) (cons (cond (shift 73) ('t 105)) shift))
        ((= key 24) (cons (cond (shift 79) ('t 111)) shift))
        ((= key 25) (cons (cond (shift 80) ('t 112)) shift))
        ((= key 26) (cons (cond (shift 123) ('t 91)) shift))
        ((= key 27) (cons (cond (shift 125) ('t 93)) shift))
        ((or (= key 28) (= key 86)) (cons 'enter shift))
        ((or (= key 29) (= key 87)) (cons 'control shift))
        ((= key 30) (cons (cond (shift 65) ('t 97)) shift))
        ((= key 31) (cons (cond (shift 83) ('t 115)) shift))
        ((= key 32) (cons (cond (shift 68) ('t 100)) shift))
        ((= key 33) (cons (cond (shift 70) ('t 102)) shift))
        ((= key 34) (cons (cond (shift 71) ('t 103)) shift))
        ((= key 35) (cons (cond (shift 72) ('t 104)) shift))
        ((= key 36) (cons (cond (shift 74) ('t 106)) shift))
        ((= key 37) (cons (cond (shift 75) ('t 107)) shift))
        ((= key 38) (cons (cond (shift 76) ('t 108)) shift))
        ((= key 39) (cons (cond (shift 58) ('t 59)) shift))
        ((= key 40) (cons (cond (shift 34) ('t 39)) shift))
        ((= key 41) (cons (cond (shift 126) ('t 96)) shift))
        ((= key 43) (cons (cond (shift 124) ('t 92)) shift))
        ((= key 44) (cons (cond (shift 90) ('t 122)) shift))
        ((= key 45) (cons (cond (shift 88) ('t 120)) shift))
        ((= key 46) (cons (cond (shift 67) ('t 99)) shift))
        ((= key 47) (cons (cond (shift 86) ('t 118)) shift))
        ((= key 48) (cons (cond (shift 66) ('t 98)) shift))
        ((= key 49) (cons (cond (shift 78) ('t 110)) shift))
        ((= key 50) (cons (cond (shift 77) ('t 109)) shift))
        ((= key 51) (cons (cond (shift 60) ('t 44)) shift))
        ((= key 52) (cons (cond (shift 62) ('t 46)) shift))
        ((= key 53) (cons (cond (shift 63) ('t 47)) shift))
        ((= key 55) (cons 42 shift))
        ((or (= key 56) (= key 89)) (cons 'alt shift))
        ((= key 57) (cons 32 shift))
        ((= key 58) (cons 'caps shift))
        ((= key 59) (cons 'F1 shift))
        ((= key 60) (cons 'F2 shift))
        ((= key 61) (cons 'F3 shift))
        ((= key 62) (cons 'F4 shift))
        ((= key 63) (cons 'F5 shift))
        ((= key 64) (cons 'F6 shift))
        ((= key 65) (cons 'F7 shift))
        ((= key 66) (cons 'F8 shift))
        ((= key 67) (cons 'F9 shift))
        ((= key 68) (cons 'F10 shift))
        ((= key 69) (cons 'pause shift))
        ((= key 70) (cons 'scroll_lock shift))
        ((= key 71) (cons (cond (shift 'home) ('t 55)) shift))
        ((= key 72) (cons (cond (shift 'up) ('t 56)) shift))
        ((= key 73) (cons (cond (shift 'pgup) ('t 57)) shift))
        ((= key 74) (cons 45 shift))
        ((= key 75) (cons (cond (shift 'left) ('t 52)) shift))
        ((= key 76) (cons 53 shift))
        ((= key 77) (cons (cond (shift 'right) ('t 54)) shift))
        ((= key 78) (cons 43 shift))
        ((= key 79) (cons (cond (shift 'end) ('t 49)) shift))
        ((= key 80) (cons (cond (shift 'down) ('t 50)) shift))
        ((= key 81) (cons (cond (shift 'pgdn) ('t 51)) shift))
        ((= key 82) (cons (cond (shift 'insert) ('t 48)) shift))
        ((= key 83) (cons (cond (shift 'delete) ('t 46)) shift))
        ((= key 84) (cons 'F11 shift))
        ((= key 85) (cons 'F12 shift))
        ((= key 88) (cons 47 shift))
        ((= key 90) (cons 'num_lock shift))
        ((= key 91) (cons 'home shift))
        ((= key 92) (cons 'up shift))
        ((= key 93) (cons 'pgup shift))
        ((= key 94) (cons 'left shift))
        ((= key 95) (cons 'right shift))
        ((= key 96) (cons 'end shift))
        ((= key 97) (cons 'down shift))
        ((= key 98) (cons 'pgdn shift))
        ((= key 99) (cons 'insert shift))
        ((= key 100) (cons 'delete shift))
        ('t (cons () shift))))
(define (no_keymap key shift)
  (cond ((= key 8) (cons 'backspace shift))
        ((= key 10) (cons 'enter shift))
        ((= key 13) (cons 'enter shift))
        ('t (cons key shift))))
(define keymap qwerty)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to perform the main loop of the Operating System ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (run_cmd curr_id cmd shift processes globals)
  (cond ((equal cmd ":q\n") 0) ;; Shutdown
        ((equal cmd ":r\n") 1) ;; Reboot
        ((equal cmd ":l\n") (prompt curr_id gpl_str shift processes globals))
        ('t (prompt curr_id help_str shift processes globals))))
(define (process-line id line reader read-count shift processes globals)
  (cond ((atom line)
         (if (= read-count 0)
             (prompt id "" shift processes globals)
             (main id "" "" reader read-count shift processes globals)))
        ((function reader)
         (process-line id (cdr line) (reader (car line))
                       (if (and (= read-count 0) (< (car line) 33))
                           read-count
                           (+ read-count 1))
                       shift processes globals))
        ((= (car reader) 'read)
         (prompt (+ id 1) "" shift
                 (add_process id 'running (cadr reader) processes globals)
                 globals))
        ('t (prompt (+ id 1) (print_error (cadr reader)) shift
                    processes globals))))
(define (process_key key id reversed-line reader read-count shift processes globals)
  (cond ((= key ())
         (main id "" reversed-line reader read-count shift processes globals))
        ((= key 'backspace)
         (main id (if reversed-line '(8) ()) (cdr reversed-line) reader
               read-count shift processes globals))
        ((and (= key 'enter) (= reversed-line ()))
         (prompt id "" shift processes globals))
        ((= key 'enter)
         (let ((line ((foldl cons "\n") reversed-line)))
           (cond ((and (= (car line) 58) (= read-count 0))
                  (run_cmd id line shift processes globals))
                 ('t (process-line id line reader read-count shift
                                   processes globals)))))
        ((number key) (main id `(,key) (cons key reversed-line) reader
                            read-count shift processes globals))
        ('t (main id "" reversed-line reader read-count shift
                  processes globals))))
(define (main curr_id output curr reader read-count shift processes globals)
  (append output
          (fn (in) (let (((key . shift) (keymap in shift))
                         ((globals . processes) (schedule processes globals)))
                     (process_key key curr_id curr reader read-count shift
                                  processes globals)))))
(define (prompt current-id out shift processes globals)
  (let (((processes . results) (check_processes processes))
        (output (append out results "\n\rexpr " (print current-id) "> ")))
    (main current-id output "" initial-reader 0 shift processes globals)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Informational strings  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (init_msg space cmd boot)
  (append "Loaded with " (print space) " free cons cells.\n\r"
          "Kernel arguments: " cmd "\n\r"
          boot))
(define help_str (append "\n\rCommands:"
                         "\n\r\t:h - display this help menu"
                         "\n\r\t:l - display license information"
                         "\n\r\t:q - quit (Not implemented, will reboot)"
                         "\n\r\t:r - reboot"
                         "\n\r\t<EXPR> - evaluate the expression <EXPR>"))
(define release_str "\n\rOmar's Lisp Operating System, release 20081010.")
(define gpl_str
  (append release_str
          "\n\rCopyright (C) 2004 - 2011 by Omar Jarjur"
          "\n\n\rThis program is free software. You can redistribute "
          "it and/or modify it under the terms of version 2 of the "
          "GNU General Public License as published by the Free "
          "Software Foundation."
          "\n\n\rThis program is distributed in the hope that it will "
          "be useful, but WITHOUT ANY WARRANTY; without even the "
          "implied warranty of MERCHANTABILITY or FITNESS FOR A "
          "PARTICULAR PURPOSE. See the GNU General Public License for "
          "more details."
          "\n\n\rYou should have received a copy of the GNU General "
          "Public License along with this program; if not, write to "
          "the Free Software Foundation, Inc., 59 Temple Place, "
          "Suite 330, Boston, MA 02111-1307 USA"))
(define boot_str
  (append release_str "\n\rSystem running. Type \":h\" for the help menu."))

;;;;;;;;;;;;;;;;;
;; Entry point ;;
;;;;;;;;;;;;;;;;;
(fn (space boot_args)
    (prompt 0 (init_msg space boot_args boot_str) () initial_processes ()))
