;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Losak compiler                                                  ;;
;;                                                                 ;;
;; This first stage of the compiler rewrites the multi-process     ;;
;; program into a single process that consists of communicating    ;;
;; co-routines.                                                    ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Copyright (C) 2004 - 2009 by Omar Jarjur                        ;;
;;                                                                 ;;
;; This program is free software; you can redistribute it and/or   ;;
;; modify it under the terms of version 2 of the GNU General       ;;
;; Public License as published by the Free Software Foundation.    ;;
;;                                                                 ;;
;; This program is distributed in the hope that it will be useful, ;;
;; but WITHOUT ANY WARRANTY; without even the implied warranty of  ;;
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ;;
;; GNU General Public License for more details.                    ;;
;;                                                                 ;;
;; You should have received a copy of the GNU General Public       ;;
;; License along with this program; if not, write to the Free      ;;
;; Software Foundation, Inc.,                                      ;;
;; 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (caar x) (car (car x)))
(define (cdar x) (cdr (car x)))
(define (cadr x) (car (cdr x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (cdr x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))

(define (id x) x)
(define (list . args) args)
(define (apply op args) (op . args))
(define (recurse op)
  ((fn (this) (op (fn args ((this this) . args))))
   (fn (this) (op (fn args ((this this) . args))))))
(define (walk head tail test merge ret)
  (fn (tree)
      (cond ((test tree) (ret tree))
            ('t (merge (head tree)
                       ((walk head tail test merge ret)
                        (tail tree)))))))
(define (rreverse list result return)
  (cond ((atom list) (return result))
        ('t (rreverse (cdr list) (cons (car list) result) return))))
(define (reverse list) (rreverse list '() id))
(define (foldl merge end)
  (fn (list)
      (cond ((atom list) end)
            ('t ((foldl merge (merge (car list) end)) (cdr list))))))
(define (foldr merge end)
  (fn (list) (rreverse list '() (foldl merge end))))
(define (append . args) ((foldr (fn (x xs)
                                    (cond ((= xs '()) x)
                                          ('t ((foldr cons xs) x))))
                                '()) args))
(define (equal x y)
        (cond ((atom x) (= x y))
              ((atom y) '())
              ((equal (car x) (car y)) (equal (cdr x) (cdr y)))
              ('t '())))
(define (map op list) ((foldr (fn (x xs) (cons (op x) xs)) '()) list))
(define (or . args) ((foldr (fn (t ts) (cond (t t) ('t ts))) '()) args))
(define (and . args) ((foldr (fn (t ts) (cond (t ts) ('t '()))) 't) args))
(define (not test) (cond (test '()) ('t 't)))
(define (contains eq-test item)
  (foldr (fn (x found) (cond ((eq-test x item) 't) ('t found))) ()))

;;;;;;;;;;;;;;;;;;;;
;; Error handling ;;
;;;;;;;;;;;;;;;;;;;;
(define (print-error msg) (append msg "\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for maintaining the symbol table ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (make-symbol id str) (fn (op) (op id str)))
(define (symbol->id symbol) (symbol (fn (id str) id)))
(define (symbol->string symbol) (symbol (fn (id str) str)))
(define (symbol-eq s1 s2) (= (symbol->id s1) (symbol->id s2)))
(define (lookup string curr table count return)
  (cond ((atom curr) (return count (cons (cons string count) table)))
        ((equal (caar curr) string) (return (cdar curr) table))
        ('t (lookup string (cdr curr) table (+ count 1) return))))
(define (get-symbol string table return)
  (lookup string table table 0 ;; Negative symbol ids are
                               ;; reserved for the compiler
          (fn (id new-table) (return (make-symbol id string) new-table))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper functions for parsing ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (escape-char char return symbols line-num)
  (return (cond ((= char 116) 9)
                ((= char 114) 13)
                ((= char 110) 10)
                ('t char))
          symbols line-num))
(define (build-num chars return symbols line-num)
  (return ((foldl (fn (c n) (+ (* 10 n) (- c 48))) 0) chars)
          symbols line-num))
(define (drop-first pair return symbols line-num)
  (return (cdr pair) symbols line-num))
(define (drop-second pair return symbols line-num)
  (return (car pair) symbols line-num))
(define (quote-value expr return symbols line-num)
  (return (list 'quote expr) symbols line-num))
(define (lookup-symbol chars return symbols line-num)
  (cond ((equal chars "cond") (return 'cond symbols line-num))
        ((equal chars "let") (return 'let symbols line-num))
        ((equal chars "fn") (return 'fn symbols line-num))
        ((equal chars "quote") (return 'quote symbols line-num))
        ((equal chars "cons") (return 'cons symbols line-num))
        ((equal chars "car") (return 'car symbols line-num))
        ((equal chars "cdr") (return 'cdr symbols line-num))
        ((equal chars "atom") (return 'atom symbols line-num))
        ((equal chars "number") (return 'number symbols line-num))
        ((equal chars "function") (return 'function symbols line-num))
        ((equal chars "=") (return '= symbols line-num))
        ((equal chars "<") (return '< symbols line-num))
        ((equal chars ">") (return '> symbols line-num))
        ((equal chars "+") (return '+ symbols line-num))
        ((equal chars "-") (return '- symbols line-num))
        ((equal chars "*") (return '* symbols line-num))
        ((equal chars "/") (return '/ symbols line-num))
        ((equal chars "%") (return '% symbols line-num))
        ((equal chars "~") (return '~ symbols line-num))
        ((equal chars "&") (return '& symbols line-num))
        ((equal chars "|") (return '| symbols line-num))
        ((equal chars "^") (return '^ symbols line-num))
        ((equal chars ">>") (return '>> symbols line-num))
        ((equal chars ">>>") (return '>>> symbols line-num))
        ((equal chars "<<") (return '<< symbols line-num))
        ((equal chars "define") (return 'define symbols line-num))
        ('t (get-symbol chars symbols
                        (fn (id new-symbols)
                          (return id new-symbols line-num))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Parser combinators that simplify the process of writting an LL(1) ;;
;; grammar.                                                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Each parser takes a return continuation, an error continuation,   ;;
;; an input string, and a symbol table. They implement a function    ;;
;; that parses the string, and passes the tree, remaining chars, and ;;
;; new symbol table to the return, or "fails" and passes a message,  ;;
;; the remaining chars, and new symbol table to the error.           ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (fail return error symbols line-num) (error symbols))
(define (done return error symbols line-num)
  (return () symbols line-num))
(define (pop return error symbols line-num)
  (fn (char)
    (cond ((not (number char)) (error symbols))
          ((= char 10)
           (return char symbols (+ 1 line-num)))
          ('t (return char symbols line-num)))))
(define (check test)
  (fn (return error symbols line-num)
    (pop (fn (val symbols line-num)
             (cond ((test val) (return val symbols line-num))
                   ('t ((error symbols) val))))
         error symbols line-num)))
(define (match char) (check (fn (val) (= val char))))
(define (default parser) (fn (else) parser))
(define (case test then)
  (fn (else)
    (fn (return error symbols line-num)
      (test (fn (val symbols line-num)
                (then return error symbols line-num))
            (fn (symbols) (else return error symbols line-num))
            symbols line-num))))
(define (choice . args) ((foldr (fn (c cs) (c cs)) fail) args))
(define (post-process parser op)
  (fn (return error symbols line-num)
    (parser (fn (val symbols line-num)
                (op val return symbols line-num))
            error symbols line-num)))
(define (seq parser1 parser2)
  (fn (return error symbols line-num)
    (parser1 (fn (head symbols line-num)
               (parser2 (fn (tail symbols line-num)
                          (return (cons head tail) symbols line-num))
                        error symbols line-num))
             error symbols line-num)))
(define (escape parser) (seq (post-process pop escape-char) parser))
(define (use parser) (seq pop parser))
(define (peek parser)
  (fn (return error symbols line-num)
    (parser (fn (val symbols new-line-num)
                ((return val symbols line-num) val))
            error symbols line-num)))
(define (interval start end)
  (check (fn (val) (and (> val (- start 1)) (< val (+ end 1))))))
(define (skip parser) (post-process (use parser) drop-first))
(define (first parser1 parser2)
  (post-process (seq parser1 parser2) drop-second))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to parse an s-expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (parse-num . args)
  (apply (choice (case (peek (interval 48 57)) (use parse-num))
                 (default done))
         args))
(define (read-num . args) (apply (post-process parse-num build-num) args))
(define (parse-symbol . args)
  (apply (choice (case (match ()) done)
                 (case (peek (interval 0 32)) done)
                 (case (peek (interval 39 41)) done)
                 (case (peek (match 46)) done)
                 (case (peek (match 59)) done)
                 (default (use parse-symbol)))
         args))
(define (read-symbol . args)
  (apply (post-process parse-symbol lookup-symbol) args))
(define (parse-string . args)
  (apply (choice (case (match 34) done)
                 (case (match 92) (escape parse-string))
                 (default (use parse-string)))
         args))
(define (quote-parser parser) (post-process parser quote-value))
(define (comment parser)
  (fn args (apply (choice (case (match 10) parser)
                          (case (match 13) parser)
                          (default (skip (comment parser))))
                  args)))
(define (parse-paren . args)
  (apply (choice (case (interval 1 32) parse-paren)
                 (case (match 59) (comment parse-paren))
                 (case (match 41) done))
         args))
(define (parse-pair . args)
  (apply (choice (case (interval 1 32) parse-pair)
                 (case (match 59) (comment parse-pair))
                 (case (match 41) done)
                 (case (match 46) (first parse-expr parse-paren))
                 (default (seq parse-expr parse-pair)))
         args))
(define (parse-expr . args)
  (apply (choice (case (peek (match 0)) done)
                 (case (interval 1 32) parse-expr)
                 (case (match 34) (quote-parser parse-string))
                 (case (match 39) (quote-parser parse-expr))
                 (case (match 40) parse-pair)
                 (case (match 41) fail)
                 (case (match 46) fail)
                 (case (match 59) (comment parse-expr))
                 (case (peek (interval 48 57)) read-num)
                 (default read-symbol))
         args))
(define (discard-trailing-whitespace parser)
  (first parser
         (choice (case (peek (interval 1 32)) pop)
                 (default done))))
(define (read-expr cont symbol-table line-number)
  ((discard-trailing-whitespace parse-expr)
   cont
   (fn (symbols) (print-error "Parse error\n"))
   symbol-table line-number))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to print s-expressions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (build-num-str num)
  ((walk (fn (n) (% n 10))
         (fn (n) (/ n 10))
         (fn (n) (= n 0))
         (fn (d op) (fn (str) (op (cons (+ d 48) str))))
         (fn (x) id))
   num))
(define (print-num num)
  (cond ((< num 0) (cons 45 ((build-num-str (- num)) "")))
        ((= num 0) "0")
        ('t ((build-num-str num) ""))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Since we will be mixing user symbols with compiler symbols, we  ;;
;; need to ensure that there are no naming conflicts when printing ;;
;; the generated program. To do this we print symbols using their  ;;
;; id instead of their name.                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (print-symbol sym) (append "s" (print-num (symbol->id sym))))

(define (print-atom expr)
  (cond ((number expr) (print-num expr))
        ((function expr) (print-symbol expr))
        ((= expr 'quote) "quote")
        ((= expr 'car) "car")
        ((= expr 'cdr) "cdr")
        ((= expr 'number) "number")
        ((= expr 'function) "function")
        ((= expr 'atom) "atom")
        ((= expr 'cons) "cons")
        ((= expr 'cond) "cond")
        ((= expr 'let) "let")
        ((= expr 'fn) "fn")
        ((= expr '>>>) ">>>")
        ((= expr '>>) ">>")
        ((= expr '<<) "<<")
        ((= expr '<) "<")
        ((= expr '>) ">")
        ((= expr '=) "=")
        ((= expr '+) "+")
        ((= expr '-) "-")
        ((= expr '*) "*")
        ((= expr '/) "/")
        ((= expr '%) "%")
        ((= expr '&) "&")
        ((= expr '|) "|")
        ((= expr '^) "^")
        ((= expr '~) "~")
        ((= expr 'define) "define")
        ('t "<INTERNAL ERROR>")))
(define (print_pair head tail-str)
  (let ((closing-string (cond ((= (car tail-str) 41) tail-str)
                              ('t (cons 32 tail-str)))))
    ((append-print closing-string) head)))
(define (print-last tail-str)
  (let ((closing-string (append ")" tail-str)))
    (fn (elem)
        (cond (elem (append " . " ((append-print closing-string) elem)))
              ('t closing-string)))))
(define (append-print tail_str)
  (fn (expr)
      (cond ((= expr ()) (append "()" tail_str))
            ((atom expr) (append (print-atom expr) tail_str))
            ('t (append "("
                        ((walk car cdr atom
                               print_pair
                               (print-last tail_str))
                         expr))))))
(define print (append-print ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions supporting code generation ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define finish-symbol (make-symbol (- 1) "finish"))
(define pause-symbol (make-symbol (- 2) "pause"))
(define t-symbol (make-symbol (- 3) "t"))
(define initial-min-id (- 4))
(define (pause expr) (list pause-symbol (list 'fn '() expr)))

(define (VAR var) (fn (ret men-id) (list ret var)))
(define (LIT expr) (fn (ret min-id) (list ret expr)))
(define (QUOTE expr) (LIT (list 'quote expr)))
(define NIL (LIT '()))

(define (PRIMITIVE-OP op)
  (fn (ret min-id)
      (let ((arg-symbol (make-symbol min-id "arg"))
            (ret-symbol (make-symbol (- min-id 1) "return"))
            (op-code (list 'fn (list arg-symbol ret-symbol)
                           (list ret-symbol (cons op arg-symbol)))))
        (list ret op-code))))

(define (test-return test-symbol then else)
  (list 'fn (list test-symbol)
        (pause (list 'cond (list test-symbol then)
                           (list (list 'quote t-symbol) else)))))
(define (IF test then else)
  (fn (ret min-id)
      (let ((test-symbol (make-symbol min-id "test"))
            (ret-symbol (make-symbol (- min-id 1) "return"))
            (min-id (- min-id 2))
            (then-code (then ret-symbol min-id))
            (else-code (else ret-symbol min-id))
            (test-code (test (test-return test-symbol then-code else-code)
                             min-id)))
        (list (list 'fn (list ret-symbol) test-code) ret))))
(define (PAIR first second)
  (fn (ret min-id)
      (let ((first-symbol (make-symbol min-id "first"))
            (second-symbol (make-symbol (- min-id 1) "second"))
            (min-id (- min-id 2))
            (cons-code (list 'cons first-symbol second-symbol))
            (return (list ret cons-code))
            (tail-return (list 'fn (list second-symbol) return))
            (tail (second tail-return min-id)))
        (first (list 'fn (list first-symbol) tail) min-id))))
(define (apply-return op arg ret) (pause (list op arg ret)))
(define (APPLY op arg)
  (fn (ret min-id)
      (let ((arg-symbol (make-symbol min-id "arg"))
            (op-symbol (make-symbol (- min-id 1) "op"))
            (min-id (- min-id 2))
            (op-code (op (list 'fn (list op-symbol)
                               (apply-return op-symbol arg-symbol ret))
                         min-id)))
        (arg (list 'fn (list arg-symbol) op-code) min-id))))
(define (LAMBDA args body)
  (fn (ret min-id)
      (let ((ret-symbol (make-symbol (- min-id 1) "return"))
            (min-id (- min-id 2)))
        (list ret (list 'fn (list args ret-symbol)
                        (body ret-symbol min-id))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compiler from s-expressions to lambda terms ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (is-primitive-op expr)
  (or (= expr 'car) (= expr 'cdr) (= expr 'number) (= expr 'function)
      (= expr 'atom) (= expr 'cons) (= expr '>>>) (= expr '>>)
      (= expr '<<) (= expr '<) (= expr '>) (= expr '=) (= expr '+)
      (= expr '-) (= expr '*) (= expr '/) (= expr '%) (= expr '&)
      (= expr '|) (= expr '^) (= expr '~)))
(define (flatten input-tree output-list)
  (cond ((= input-tree '()) output-list)
        ((atom input-tree) (cons input-tree output-list))
        ('t (flatten (car input-tree)
                     (flatten (cdr input-tree) output-list)))))
(define (compile-find var env globals return)
  (cond (((contains symbol-eq var) (flatten env globals))
         (return (VAR var) ""))
        ('t (return NIL (append "Unknown var \""
                                (symbol->string var)
                                "\" will evaluate to NIL. ")))))
(define (always-true expr)
  (cond ((function expr) '())
        ((atom expr) expr)
        ((not (= (car expr) 'quote)) '())
        ((= (cdr expr) '()) '())
        ('t 't)))
(define (compile-cond env globals)
  (walk car cdr atom
        (fn (case else)
            (cond ((always-true (car case))
                   (fn (return) (compile-expr (cadr case) env globals return)))
                  ('t (fn (return)
                          (compile-expr
                           (car case) env globals
                           (fn (test-code test-warnings)
                               (compile-expr
                                (cadr case) env globals
                                (fn (then-code then-warnings)
                                    (else (fn (else-code else-warnings)
                                              (return (IF test-code
                                                          then-code
                                                          else-code)
                                                      (append test-warnings
                                                              then-warnings
                                                              else-warnings
                                                      ))))))))))))
        (fn (cases) (fn (return) (return NIL "Unhandled cond default. ")))))
(define (compile-let bindings body env globals return)
  (compile-expr ((walk car cdr atom
                  (fn (binding expr)
                      (list (list 'fn (list (car binding)) expr)
                            (cadr binding)))
                  (fn (bindings) body))
                 bindings)
                env globals return))
(define (compile-args env globals)
  (walk car cdr atom
        (fn (arg arg-list)
            (fn (return)
                (compile-expr arg env globals
                 (fn (arg-code arg-warnings)
                     (arg-list (fn (args-code args-warnings)
                                   (return (PAIR arg-code args-code)
                                           (append arg-warnings
                                                   args-warnings))))))))
        (fn (args) (fn (return) (compile-expr args env globals return)))))
(define (compile-apply op args env globals return)
  (compile-expr op env globals
                (fn (op-code op-warnings)
                    (((compile-args env globals) args)
                     (fn (args-code args-warnings)
                         (return (APPLY op-code args-code)
                                 (append op-warnings args-warnings)))))))
(define (compile-expr expr env globals return)
  (cond ((function expr) (compile-find expr env globals return))
        ((is-primitive-op expr) (return (PRIMITIVE-OP expr) ""))
        ((atom expr) (return (LIT expr) ""))
        ((= (car expr) 'quote) (return (QUOTE (cadr expr)) ""))
        ((= (car expr) 'cond) (((compile-cond env globals) (cdr expr)) return))
        ((= (car expr) 'let)
         (compile-let (cadr expr) (caddr expr) env globals return))
        ((= (car expr) 'fn)
         (compile-expr (caddr expr) (cons (cadr expr) env) globals
                       (fn (body warnings)
                           (return (LAMBDA (cadr expr) body) warnings))))
        ('t (compile-apply (car expr) (cdr expr) env globals return))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile expressions to coroutines ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (get-name (line-number . definition))
  (cond ((atom (cadr definition)) (cadr definition))
        ('t (caadr definition))))
(define (get-body (line-number . definition))
  (cond ((atom (cadr definition)) (caddr definition))
        ('t (list 'fn (cdr (cadr definition)) (caddr definition)))))
(define map-to-stderr
  (foldr (fn (char output) (cons (list (cons 2 char)) output)) ()))
(define (print-warnings line-number warnings)
  (cond (warnings (map-to-stderr (append "WARNING; "
                                         "In expression beginning on line "
                                         (print line-number) ": " warnings
                                         "\n")))
        ('t ())))
(define (compile-definition globals)
  (fn (definition)
      (let ((line-number (car definition))
            (name (get-name definition))
            (body (get-body definition)))
        (compile-expr body '() globals
                      (fn (compiled-body warnings)
                          (append (print-warnings line-number warnings)
                                  "(define "
                                  (print name)
                                  "\n("
                                  (print (compiled-body finish-symbol
                                                        initial-min-id))
                                  " run-to-completion))\n"))))))
(define (compile definitions expr line-number)
  (let ((globals (map get-name definitions))
        (compiled-expr (compile-expr expr '() globals
                                     (fn (code warnings)
                                         (append (print-warnings line-number
                                                                 warnings)
                                                 "("
                                                 (print (code finish-symbol
                                                              initial-min-id))
                                                 " main)\n"))))
        (bodies (map (compile-definition globals) definitions)))
    (apply append (cons process-manager-code
                        (append bodies (list compiled-expr))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Output code to perform process I/O ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define process-manager-code
  (append "(define (" (print pause-symbol) " proc)
  (fn (scheduler) (scheduler 'running proc)))
(define (" (print finish-symbol) " val)
  (fn (scheduler) (scheduler 'done val)))
(define (run-to-completion status proc)
  (cond ((= status 'running) ((proc) run-to-completion))
        ('t proc)))
(define (list . args) args)
(define (rreverse list result return)
  (cond ((atom list) (return result))
        ('t (rreverse (cdr list) (cons (car list) result) return))))
(define (foldl merge end)
  (fn (list)
      (cond ((atom list) end)
            ('t ((foldl merge (merge (car list) end)) (cdr list))))))
(define (foldr merge end)
  (fn (list) (rreverse list '() (foldl merge end))))
(define (not test) (cond (test '()) ('t 't)))
(define (or . args) ((foldr (fn (t ts) (cond (t t) ('t ts))) '()) args))
(define (and . args) ((foldr (fn (t ts) (cond (t ts) ('t '()))) 't) args))
(define (equal x y)
        (cond ((atom x) (= x y))
              ((atom y) '())
              ((equal (car x) (car y)) (equal (cdr x) (cdr y)))
              ('t '())))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; TODO: Replace with a real-time FIFO Queue ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define empty-mailbox ())
(define (add-to-mailbox id msg inbox)
  (cond ((atom inbox) (cons msg inbox))
        ('t (cons (car inbox) (add-to-mailbox id msg (cdr inbox))))))
(define (is-mailbox-empty inbox) (atom inbox))
(define (get-message inbox return) (return (car inbox) (cdr inbox)))

(define empty-children ())
(define (add-child (child-id child-mem child) children)
  ((child (list child-mem) " (print finish-symbol) ")
   (fn (status process)
       (cons (list child-id status process empty-mailbox empty-children)
             children))))
(define (add-msg (id status proc inbox children) from-id msg)
  (list id status proc (add-to-mailbox from-id msg inbox) children))
(define (send-child-msg parent-id child-id msg children)
  ((foldr (fn (child children)
             (cons (cond ((equal (car child) child-id)
                          (add-msg child parent-id msg))
                         ('t child))
                   children))
         ())
   children))

(define (main status process)
  (process-return 0 status process empty-mailbox
                  empty-children empty-mailbox write-output))
(define (run-process outbox (id status proc inbox children))
  (process-children children inbox
                    (fn (children inbox)
                        (process-return id status proc inbox
                                        children outbox write-output))))
(define (read-input outbox process)
  (fn (in) (cond (in (run-process outbox (add-msg process () in)))
                 ('t (run-process outbox process)))))
(define (write-output outbox process)
  (cond ((atom process) outbox)
        ((is-mailbox-empty outbox)
         (cond ((and (or (= (car (cdr process)) 'done)
                         (= (car (cdr process)) 'blocked))
                     (function (car (cdr (cdr process)))))
                (read-input outbox process))
               ('t (run-process outbox process))))
        ('t (get-message outbox
                         (fn (msg outbox)
                             (cons msg (write-output outbox process)))))))
(define (perform-io msg proc id inbox children outbox return)
  (cond ((atom msg) ;; send message to parent
         (return (add-to-mailbox () msg outbox)
                 (list id 'done proc inbox children)))
        ((atom (cdr msg)) ;; send message to parent
         (return (add-to-mailbox () (car msg) outbox)
                 (list id 'done proc inbox children)))
        ((atom (cdr (cdr msg))) ;; send message to child
         (return outbox (list id 'done proc inbox
                              (send-child-msg id (car msg)
                                              (car (cdr msg))
                                              children))))
        ('t ;; add new child
         (return outbox (list id 'done proc inbox (add-child msg children))))))
(define (process-children children inbox return)
  (((foldr (fn (child return)
               (fn (children inbox)
                   (process-child child inbox children return)))
           return)
    children)
   () inbox))
(define (process-child child outbox children return)
  (process-tree child outbox
                (fn (outbox child)
                    (cond ((atom child) (return children outbox))
                          ('t (return (cons child children) outbox))))))
(define (process-tree (id status process inbox children) outbox return)
  (process-children children inbox
                    (fn (children inbox)
                        (process-return id status process inbox
                                        children outbox return))))
(define (process-return id status process inbox children outbox return)
  (cond ((= status 'running)
         ((process)
          (fn (status process)
              (return outbox (list id status process inbox children)))))
        ((function process)
         (cond ((is-mailbox-empty inbox)
                (return outbox (list id 'blocked process inbox children)))
               ('t (get-message inbox
                                (fn (msg inbox)
                                    ((process (list msg)
                                              " (print finish-symbol) ")
                                     (fn (status new-process)
                                         (return outbox
                                                 (list id status new-process
                                                       inbox children)))))))))
        ((atom process) (return outbox process))
        ('t (perform-io (car process) (cdr process)
                        id inbox children outbox return))))
\n"))

;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the input ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (compile-source definitions start-line-number)
  (fn (value symbol-table end-line-number)
    (cond ((not value)
           (print-error "No main expression"))
          ((not (= (car value) 'define))
           (compile (reverse definitions) value start-line-number))
          ((not (or (atom (cadr value)) (atom (caadr value))))
           (print-error "Malformed define statement"))
          ('t (read-expr (compile-source (cons (cons start-line-number value)
                                               definitions)
                                         end-line-number)
                         symbol-table
                         end-line-number)))))
(fn (size arguments) (read-expr (compile-source '() 1) '() 1))
