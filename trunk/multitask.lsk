;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Losak compiler                                                  ;;
;;                                                                 ;;
;; This stage of the compiler rewrites the multi-process program   ;;
;; into a single process that consists of communicating            ;;
;; co-routines.                                                    ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Copyright (C) 2004 - 2012 by Omar Jarjur                        ;;
;;                                                                 ;;
;; This program is free software; you can redistribute it and/or   ;;
;; modify it under the terms of version 2 of the GNU General       ;;
;; Public License as published by the Free Software Foundation.    ;;
;;                                                                 ;;
;; This program is distributed in the hope that it will be useful, ;;
;; but WITHOUT ANY WARRANTY; without even the implied warranty of  ;;
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ;;
;; GNU General Public License for more details.                    ;;
;;                                                                 ;;
;; You should have received a copy of the GNU General Public       ;;
;; License along with this program; if not, write to the Free      ;;
;; Software Foundation, Inc.,                                      ;;
;; 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;
;; Error handling ;;
;;;;;;;;;;;;;;;;;;;;
(define map-to-stderr
  (foldr (fn (char output) (cons (list (cons 2 char)) output)) ()))
(define (print-warnings line-number warnings)
  (cond (warnings (map-to-stderr (append "WARNING; "
                                         "In expression beginning on line "
                                         (print line-number) ": " warnings
                                         "\n")))
        ('t ())))
(define (print-error msg) (map-to-stderr (append "Error; "msg "\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities for preventing name collisions ;;
;; in the output of the CPS transformation  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define builtins
  '(cons car cdr null? number? symbol? function? pair?
         = < > + - * / % ~ & | ^ >> >>> <<))
(define (escape-symbols expr)
  (if (pair? expr)
      (cons (escape-symbols (car expr)) (escape-symbols (cdr expr)))
      (if (symbol? expr)
          (let ((symbol-string (symbol->string expr)))
            (if (= (car symbol-string) 95) ;; Underscore
                (string->symbol (cons 95 symbol-string))
              expr))
          expr)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CPS-Transformation functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define scheduler-symbol (string->symbol "_scheduler"))
(define terminated-symbol (string->symbol "_terminated"))
(define expr-continuation-symbol (string->symbol "_expr-handler"))
(define process-continuation-symbol (string->symbol "_process-handler"))
(define initial-symbol-name "_s_")

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Transform a tail call ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (transform-fn-tail-call params body next-symbol-name
                                continuation scheduler)
  (let ((return-symbol (string->symbol next-symbol-name))
        (next-symbol-name (append next-symbol-name "_body"))
        (cps-params (cons scheduler-symbol
                          (cons return-symbol (escape-symbols params)))))
    `(,scheduler ,continuation
                 (fn ,cps-params
                     ,(transform-tail-call body next-symbol-name
                                           return-symbol
                                           scheduler-symbol)))))
(define (transform-application-tail-call op args next-symbol-name
                                         continuation scheduler)
  (let ((val-symbol (string->symbol next-symbol-name))
        (op-next-symbol-name (append next-symbol-name "_op"))
        (args-next-symbol-name (append next-symbol-name "_args")))
    (transform op op-next-symbol-name
               (fn (scheduler op-code)
                   (transform-args args '() args-next-symbol-name
                                   (fn (scheduler args-code)
                                       (list op-code
                                             scheduler
                                             continuation
                                             . args-code))
                                   scheduler))
               scheduler)))
(define (transform-primitive-tail-call op args next-symbol-name
                                       continuation scheduler)
  (transform-args args '() next-symbol-name
                  (fn (scheduler args-code)
                      `(,scheduler ,continuation ,(cons op args-code)))
                  scheduler))
(define (transform-if-tail-call test then else next-symbol-name
                                continuation scheduler)
  (let ((test-value-symbol (string->symbol next-symbol-name))
        (test-next-symbol-name (append next-symbol-name "_test"))
        (then-next-symbol-name (append next-symbol-name "_then"))
        (else-next-symbol-name (append next-symbol-name "_else"))
        (then-code (transform-tail-call then then-next-symbol-name
                                        continuation scheduler-symbol))
        (else-code (transform-tail-call else else-next-symbol-name
                                        continuation scheduler-symbol)))
    (transform test test-next-symbol-name
               (fn (scheduler test-code)
                   `(,scheduler
                     (fn (,scheduler-symbol
                          ,terminated-symbol
                          ,test-value-symbol)
                         (if ,test-value-symbol ,then-code ,else-code))
                     ,test-code))
               scheduler)))
(define (transform-atom-tail-call expr next-symbol-name continuation scheduler)
  (cond ((null? expr) `(,scheduler ,continuation ,expr))
        ((number? expr) `(,scheduler ,continuation ,expr))
        ((not (member expr builtins))
         `(,scheduler ,continuation ,(escape-symbols expr)))
        ('t (let ((return-symbol (string->symbol next-symbol-name))
                  (args-symbol (string->symbol (append next-symbol-name "_args"))))
              `(,scheduler ,continuation
                           (fn ,(cons scheduler-symbol
                                      (cons return-symbol args-symbol))
                               (,scheduler-symbol ,return-symbol
                                                  ,(cons expr
                                                         args-symbol))))))))
(define (transform-tail-call expr next-symbol-name continuation scheduler)
  (if (pair? expr)
      (cond ((= (car expr) 'fn)
             (transform-fn-tail-call (cadr expr) (caddr expr) next-symbol-name
                                     continuation scheduler))
            ((= (car expr) 'if)
             (transform-if-tail-call (cadr expr) (caddr expr) (cadr (cddr expr))
                                     next-symbol-name continuation scheduler))
            ((= (car expr) 'quote) `(,scheduler ,continuation ,expr))
            ((member (car expr) builtins)
             (transform-primitive-tail-call (car expr) (cdr expr)
                                            next-symbol-name
                                            continuation scheduler))
            ('t (transform-application-tail-call (car expr) (cdr expr)
                                                 next-symbol-name continuation
                                                 scheduler)))
      (transform-atom-tail-call expr next-symbol-name
                                continuation scheduler)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Transform a non-tail call ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (transform-fn params body next-symbol-name builder scheduler)
  (let ((return-symbol (string->symbol next-symbol-name))
        (next-symbol-name (append next-symbol-name "_body"))
        (cps-params (cons scheduler-symbol
                          (cons return-symbol (escape-symbols params)))))
    (builder scheduler
             `(fn ,cps-params
                  ,(transform-tail-call body next-symbol-name
                                        return-symbol
                                        scheduler-symbol)))))
(define (transform-args args args-code next-symbol-name builder scheduler)
  (cond ((null? args) (builder scheduler (reverse args-code)))
        ((pair? args)
         (let ((arg-symbol (string->symbol next-symbol-name))
               (arg-next-symbol-name (append next-symbol-name "_arg"))
               (args-next-symbol-name (append next-symbol-name "_args")))
           (transform (car args) arg-next-symbol-name
                      (fn (scheduler arg-code)
                          (transform-args (cdr args)
                                          (cons arg-code args-code)
                                          args-next-symbol-name
                                          builder scheduler))
                      scheduler)))
        ('t (let ((arg-symbol (string->symbol next-symbol-name))
                  (arg-next-symbol-name (append next-symbol-name "_arg")))
              (transform args arg-next-symbol-name
                         (fn (scheduler code)
                             (builder scheduler
                                      (append (reverse args-code) code)))
                         scheduler)))))
(define (transform-application op args next-symbol-name builder scheduler)
  (let ((val-symbol (string->symbol next-symbol-name))
        (op-next-symbol-name (append next-symbol-name "_op"))
        (args-next-symbol-name (append next-symbol-name "_args")))
    (transform op op-next-symbol-name
               (fn (scheduler op-code)
                   (transform-args args '() args-next-symbol-name
                                   (fn (scheduler args-code)
                                       (list op-code
                                             scheduler
                                             `(fn (,scheduler-symbol
                                                   ,terminated-symbol
                                                   ,val-symbol)
                                                  ,(builder scheduler-symbol
                                                            val-symbol))
                                             . args-code))
                                   scheduler))
               scheduler)))
(define (transform-primitive op args next-symbol-name builder scheduler)
  (transform-args args '() next-symbol-name
                  (fn (scheduler args-code)
                      (builder scheduler (cons op args-code)))
                  scheduler))
(define (transform-if test then else next-symbol-name builder scheduler)
  (let ((test-value-symbol (string->symbol next-symbol-name))
        (test-next-symbol-name (append next-symbol-name "_test"))
        (then-next-symbol-name (append next-symbol-name "_then"))
        (else-next-symbol-name (append next-symbol-name "_else"))
        (then-code (transform then then-next-symbol-name
                              builder scheduler-symbol))
        (else-code (transform else else-next-symbol-name
                              builder scheduler-symbol)))
    (transform test test-next-symbol-name
               (fn (scheduler test-code)
                   `(,scheduler
                     (fn (,scheduler-symbol
                          ,terminated-symbol
                          ,test-value-symbol)
                         (if ,test-value-symbol ,then-code ,else-code))
                     ,test-code))
               scheduler)))
(define (transform-atom expr next-symbol-name builder scheduler)
  (cond ((null? expr) (builder scheduler expr))
        ((number? expr) (builder scheduler expr))
        ((not (member expr builtins))
         (builder scheduler (escape-symbols expr)))
        ('t (let ((return-symbol (string->symbol next-symbol-name))
                  (args-symbol (string->symbol (append next-symbol-name
                                                       "_args"))))
              (builder scheduler
                       `(fn ,(cons scheduler-symbol
                                   (cons return-symbol args-symbol))
                            (,scheduler-symbol ,return-symbol
                                               ,(cons expr args-symbol))))))))
(define (transform expr next-symbol-name builder scheduler)
  (if (pair? expr)
      (cond ((= (car expr) 'fn)
             (transform-fn (cadr expr) (caddr expr) next-symbol-name
                           builder scheduler))
            ((= (car expr) 'if)
             (transform-if (cadr expr) (caddr expr) (cadr (cddr expr))
                           next-symbol-name builder scheduler))
            ((= (car expr) 'quote) (builder scheduler expr))
            ((member (car expr) builtins)
             (transform-primitive (car expr) (cdr expr)
                                  next-symbol-name builder scheduler))
            ('t (transform-application (car expr) (cdr expr) next-symbol-name
                                       builder scheduler)))
      (transform-atom expr next-symbol-name builder scheduler)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile expressions to coroutines ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (cps-transformation expr continuation)
  (transform expr initial-symbol-name
             (fn (scheduler expr-code) `(,scheduler ,continuation ,expr-code))
             scheduler-symbol))
(define (transform-statement statement)
  (if (and (pair? statement) (= (car statement) 'define))
      `(define ,(escape-symbols (cadr statement))
         ,(cps-transformation (caddr statement) expr-continuation-symbol))
      (cps-transformation statement process-continuation-symbol)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Output code to perform process I/O ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define process-manager-code
  `((define ,expr-continuation-symbol
      (fn (running-scheduler terminated-scheduler expr) expr))
    (define _process-continuation
      (fn (running-scheduler terminated-scheduler expr)
          (terminated-scheduler expr)))
    (define ,process-continuation-symbol _process-continuation)
    (define _initial-process-runner
      (fn (initial-process) (_run-process initial-process _empty-messenger)))
    (define _top-level-scheduler
      (fn (continuation process-value)
          (_make-process 0 continuation process-value
                         _empty-process-list _empty-mailbox
                         _initial-process-runner)))
    (define ,scheduler-symbol _top-level-scheduler)
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; TODO: Replace with a real-time FIFO Queue ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Mailbox:: (M,R)=>((M,Mailbox<M,R>,T->R)->R,T,T->R)->R
    (define _empty-mailbox
      (fn (non-empty-handler empty-result return) (return empty-result)))
    (define _add-to-mailbox ;; (M,R)=>(M,Mailbox<M,R>,Mailbox<M,R>->R)->R
      (fn (msg inbox return)
          (inbox (fn (first-msg remaining-inbox return)
                     (_add-to-mailbox msg remaining-inbox
                                      (fn (updated-remaining)
                                          (return (fn (non-empty empty return)
                                                      (non-empty first-msg
                                                                 updated-remaining
                                                                 return))))))
                 (fn (non-empty-handler empty-result return)
                     (non-empty-handler msg _empty-mailbox return))
                 return)))
    
    ;; Messenger:: (M,R)=>(Id,Mailbox<M,R>,Mailbox<M,R>->R)->R
    (define _empty-messenger (fn (id mailbox return) (return mailbox)))
    (define _targeted-messenger ; (Id,M,Messenger<M,R>,Messenger<M,R>->R)->R
      (fn (target-id message messenger return)
          (return (fn (id mailbox return)
                      (messenger id mailbox
                                 (fn (mailbox)
                                     (if (= target-id id)
                                         (_add-to-mailbox message mailbox
                                                          return)
                                         (return mailbox))))))))
    (define _blind-messenger ; (M,Messenger<M,R>->R)->R
      (fn (message return)
          (return (fn (id mailbox return)
                      (_add-to-mailbox message mailbox return)))))
    
    ;; ProcessList:: (M,R)=>(Messenger<M,R>,Mailbox<M,R>,ProcessListReturn<M,R>)->R
    ;; ProcessListReturn:: (M,R)=>(ProcessList<M,R>,Mailbox<M,R>)->R
    ;; Process:: (M,R)=>(Messenger<M,R>,RunningHandler<M,R>,EventHandler<M,R>)->R
    ;; ProcessEvent:: (M,R)=>(Mailbox<M,R>,RunningReturn<M,R>,TerminatedReturn<M,R>)->R
    ;; RunningHandler:: (M,R)=>(Process<M,R>)->R
    ;; EventHandler:: (M,R)=>(ProcessEvent<M,R>)->R
    (define _empty-process-list ; ProcessList<M,R>
      (fn (messenger parent-mailbox return)
          (return _empty-process-list parent-mailbox)))
    (define _add-process ; (Process<M,R>,ProcessList<M,R>,ProcessList<M,R>->R)->R
      (fn (process siblings return)
          (return (fn (messenger parent-mailbox return)
                      (siblings
                       messenger parent-mailbox
                       (fn (updated-siblings updated-parent-mailbox)
                           (_make-handlers updated-siblings
                                           updated-parent-mailbox
                                           (fn (updated-process updated-parent-mailbox)
                                               (_add-process updated-process
                                                             updated-siblings
                                                             (fn (updated-processes)
                                                                 (return updated-processes
                                                                         updated-parent-mailbox))))
                                           (fn (updated-parent-mailbox)
                                               (return updated-siblings
                                                       updated-parent-mailbox))
                                           (fn (running-handler event-handler)
                                               (process messenger
                                                        running-handler
                                                        event-handler)))))))))

    ;; RunningReturn:: (M,R)=>(Process<M,R>,Mailbox<M,R>)->R
    ;; TerminatedReturn:: (M,R)=>Mailbox<M,R>->R
    ;; (M,R)=>(ProcessList<M,R>,Mailbox<M,R>,RunningReturn<M,R>,TerminatedReturn<M,R>,(RunningHandler<M,R>,EventHandler<M,R>)->R)->R
    (define _make-handlers
      (fn (siblings parent-mailbox running-return terminated-return return)
          (return (fn (updated-process)
                      (running-return updated-process parent-mailbox))
                  (fn (process-event)
                      (process-event _empty-messenger parent-mailbox
                                     running-return terminated-return)))))

    ;; ProcessContinuation:: (R,V)=>(RunningScheduler<R,V>,TerminatedScheduler<R,V>,V)->R
    ;; RunningScheduler:: (R,V)=>(ProcessContinuation<R,V>,V)->R
    ;; TerminatedScheduler:: (R,V)=>V->R
    ;; (M,R,V)=>(Id,ProcessContinuation<R,V>,V,ProcessList<M,R>,Mailbox<M>,Process<M,R>->R)->R
    (define _make-process
      (fn (id continuation value children mailbox return)
          (return (fn (messenger running-handler event-handler)
                      (messenger id mailbox
                                 (fn (updated-mailbox)
                                     (_make-schedulers id updated-mailbox children
                                                       running-handler
                                                       event-handler
                                                       (fn (running-scheduler
                                                            terminated-scheduler)
                                                           (continuation
                                                            running-scheduler
                                                            terminated-scheduler
                                                            value)))))))))

    ;; (M,R,V)=>(Id,Mailbox<M>,ProcessList<M,R>,RunningHandler<M,R>,EventHandler<M,R>,(RunningScheduler<R,V>,TerminatedScheduler<R,V>)->R)->R
    (define _make-schedulers
      (fn (id mailbox children running-handler event-handler return)
          (return (fn (continuation value)
                      (children _empty-messenger mailbox
                                (fn (updated-children updated-mailbox)
                                    (_make-process id continuation value
                                                   updated-children updated-mailbox
                                                   (fn (updated-process)
                                                       (running-handler
                                                        updated-process))))))
                  (fn (value)
                      (event-handler (fn (messenger parent-mailbox
                                                    running-return
                                                    terminated-return)
                                         (messenger id mailbox
                                                    (fn (mailbox)
                                                        (_process-io id value
                                                                     mailbox
                                                                     children
                                                                     _empty-messenger
                                                                     parent-mailbox
                                                                     running-return
                                                                     terminated-return)))))))))

    (define _flush-mailbox
      (fn (mailbox end return)
          (mailbox (fn (first-message remaining-mailbox return)
                       (_flush-mailbox remaining-mailbox end
                                       (fn (result)
                                           (return (cons first-message
                                                         result)))))
                   end
                   return)))
    (define _id-function (fn (result) result))
    (define _write-messages
      (fn (outbox continuation) (_flush-mailbox outbox continuation _id-function)))

    ;; (M,R)=>RunningReturn<M,R>
    (define _top-level-running-return
      (fn (process parent-mailbox)
          (_write-messages
           parent-mailbox
           (fn in (if in
                      (_blind-messenger in
                                        (fn (messenger)
                                            (_run-process process messenger)))
                      (_run-process process _empty-messenger))))))
    ;; (M,R)=>TerminatedReturn<M,R>
    (define _top-level-terminated-return
      (fn (parent-mailbox) (_write-messages parent-mailbox '())))
    ;; (M,R)=>EventHandler<M,R>
    (define _top-level-event-handler
      (fn (process-event)
          (fn in (if in
                     (_blind-messenger in
                                       (fn (messenger)
                                           (process-event messenger _empty-mailbox
                                                          _top-level-running-return
                                                          _top-level-terminated-return)))
                     (process-event _empty-messenger _empty-mailbox
                                    _top-level-running-return
                                    _top-level-terminated-return)))))
    ;; (M,R)=>RunningHandler<M,R>
    (define _top-level-running-handler
      (fn (process) (_run-process process _empty-messenger)))
    (define _run-process
      (fn (process messenger)
          (process messenger
                   _top-level-running-handler
                   _top-level-event-handler)))

    ;; (M,R)=>(Id,R,Mailbox<M,R>,ProcessList<M,R>,Messenger<M,R>,Mailbox<M,R>,RunningReturn<M,R>,TerminatedReturn<M,R>)->R
    (define _process-io
      (fn (id process-result mailbox children children-messenger parent-mailbox
              running-return terminated-return)
          (if (pair? process-result)
              (_send-message id process-result mailbox children
                             children-messenger parent-mailbox
                             running-return terminated-return)
              (if (function? process-result)
                  (_process-input id process-result mailbox
                                  children children-messenger
                                  parent-mailbox running-return)
                  (terminated-return parent-mailbox)))))
    ;; (M,R)=>(Id,R,Mailbox<M,R>,ProcessList<M,R>,Mailbox<M,R>,RunningReturn<M,R>)->R
    (define _process-input
      (fn (id handler mailbox children messenger parent-mailbox running-return)
          (children messenger mailbox
                    (fn (updated-children updated-mailbox)
                        (_read-message id handler updated-mailbox updated-children
                                       (fn (return)
                                           (return (fn (updated-process)
                                                       (running-return
                                                        updated-process
                                                        parent-mailbox)))))))))
    (define _read-message
      (fn (id handler mailbox children return)
          (mailbox (fn (message remaining-inbox return)
                       (handler (fn (cont value)
                                    (return (fn (process-return)
                                                (_make-process id cont value
                                                               children
                                                               remaining-inbox
                                                               process-return))))
                                _process-continuation
                                .
                                message))
                   (fn (process-return)
                       (_make-process id _process-continuation handler children
                                      _empty-mailbox process-return))
                   return)))
    ;; (M,R)=>(Id,R,Mailbox<M,R>,ProcessList<M,R>,Messenger<M,R>,Mailbox<M,R>,RunningReturn<M,R>)->R
    (define _send-message
      (fn (id result mailbox children children-messenger parent-mailbox
              running-return terminated-return)
          (_process-message (car result) children
                            children-messenger parent-mailbox
                            (fn (children messenger parent-mailbox)
                                (_process-io id (cdr result) mailbox
                                             children messenger
                                             parent-mailbox
                                             running-return
                                             terminated-return)))))
    (define _process-message
      (fn (message children messenger parent-mailbox return)
          (if (pair? message)
              (_process-pair-message message children messenger
                                     parent-mailbox return)
              (_add-to-mailbox (cons message '()) parent-mailbox
                               (fn (parent-mailbox)
                                   (return children messenger parent-mailbox))))))
    (define _process-pair-message
      (fn (message children messenger parent-mailbox return)
          (if (pair? (cdr message))
              (_process-child-message (car message) (cdr message)
                                      children messenger
                                      (fn (children messenger)
                                          (return children
                                                  messenger
                                                  parent-mailbox)))
              (_add-to-mailbox message parent-mailbox
                               (fn (parent-mailbox)
                                   (return children messenger parent-mailbox))))))
    (define _process-child-message
      (fn (child-id message children messenger return)
          (if (pair? (cdr message))
              (_fork-child child-id (car message) (car (cdr message)) children
                           (fn (children) (return children messenger)))
              (_targeted-messenger child-id message messenger 
                                   (fn (messenger) (return children messenger))))))
    (define _fork-child
      (fn (child-id child-mem child-body children return)
          (_add-to-mailbox (cons child-mem '()) _empty-mailbox
                           (fn (child-mailbox)
                               (_make-process child-id _process-continuation
                                              child-body _empty-process-list
                                              child-mailbox
                                              (fn (child-process)
                                                  (_add-process child-process
                                                                children
                                                                return)))))))
    ))

;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the input ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (read-expr cont line-number)
  (parse-expr cont (fn (error-message end-line)
                       (print-error (append "Parse error, line "
                                            (print end-line)
                                            ": " error-message "\n")))
              line-number))
(define (compile-source start-line-number)
  (fn (value end-line-number)
      (cond ((not value)
             (print-error "No main expression"))
            ((not (= (car value) 'define))
             (append (print (transform-statement value)) "\n"))
            ((not (or (symbol? (cadr value)) (symbol? (caadr value))))
             (print-error "Malformed define statement"))
            ('t (append (print (transform-statement value))
                        (read-expr (compile-source end-line-number)
                                   end-line-number))))))
(fn (size arguments)
    ((foldr (fn (statement suffix)
                (append (print statement) "\n" suffix))
            (read-expr (compile-source 1) 1))
     process-manager-code))
