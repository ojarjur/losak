;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Losak compiler                                                      ;;
;;                                                                     ;;
;; This first stage of the compiler rewrites the multi-process program ;;
;; into a single process that consists of communicating co-routines.   ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (caar x) (car (car x)))
(define (cdar x) (cdr (car x)))
(define (cadr x) (car (cdr x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (cdr x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))

(define (id x) x)
(define (list . args) args)
(define (apply op args) (op . args))
(define (recurse op)
  ((fn (this) (op (fn args ((this this) . args))))
   (fn (this) (op (fn args ((this this) . args))))))
(define (walk head tail test merge ret)
  (fn (tree)
      (cond ((test tree) (ret tree))
            ('t (merge (head tree)
                       ((walk head tail test merge ret)
                        (tail tree)))))))
(define (fold merge end)
  (walk car cdr atom merge (fn (val) end)))
(define (foldl merge end)
  (fn (expr)
    (((walk car cdr atom
            (fn (x op) (fn (xs) (op (merge x xs))))
            (fn (x) id))
      expr) end)))
(define (append . args) ((fold (fn (x xs)
                                   (cond ((= xs '()) x)
                                         ('t ((fold cons xs) x))))
                               '()) args))
(define (equal x y)
        (cond ((atom x) (= x y))
              ((atom y) '())
              ((equal (car x) (car y)) (equal (cdr x) (cdr y)))
              ('t '())))
(define (map op list) ((fold (fn (x xs) (cons (op x) xs)) '()) list))
(define (or . args) ((fold (fn (t ts) (cond (t t) ('t ts))) '()) args))
(define (and . args) ((fold (fn (t ts) (cond (t ts) ('t '()))) 't) args))
(define (not test) (cond (test '()) ('t 't)))
(define (rreverse list result)
  (cond ((atom list) result)
        ('t (rreverse (cdr list) (cons (car list) result)))))
(define (reverse list) (rreverse list '()))
(define (contains eq-test item)
  (fold (fn (x found) (cond ((eq-test x item) 't) ('t found))) ()))

;;;;;;;;;;;;;;;;;;;;
;; Error handling ;;
;;;;;;;;;;;;;;;;;;;;
(define (error msg rest) (append msg "\nRemaining chars: " rest "\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for maintaining the symbol table ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (make-symbol id str) (fn (op) (op id str)))
(define (symbol->id symbol) (symbol (fn (id str) id)))
(define (symbol->string symbol) (symbol (fn (id str) str)))
(define (symbol-eq s1 s2) (= (symbol->id s1) (symbol->id s2)))
(define (lookup string curr table count return)
  (cond ((atom curr) (return count (cons (cons string count) table)))
        ((equal (caar curr) string) (return (cdar curr) table))
        ('t (lookup string (cdr curr) table (+ count 1) return))))
(define (get-symbol string table return)
  (lookup string table table 8 ;; Symbols 0-7 are reserved for the compiler
          (fn (id new-table) (return (make-symbol id string) new-table))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper functions for parsing ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (end-of-line chars)
  (or (atom chars)
      (= (car chars) 10)
      (= (car chars) 13)))
(define (discard-line arg) ((walk car cdr end-of-line (fn (c cs) cs) cdr) arg))

(define (escape-char char return rest symbols)
  (return (cond ((= char 116) 9)
                ((= char 114) 13)
                ((= char 110) 10)
                ('t char))
          rest symbols))
(define (build-num chars return rest symbols)
  (return ((foldl (fn (c n) (+ (* 10 n) (- c 48))) 0) chars)
          rest symbols))
(define (drop-first pair return rest symbols)
  (return (cdr pair) rest symbols))
(define (drop-second pair return rest symbols)
  (return (car pair) rest symbols))
(define (quote-value expr return rest symbols)
  (return (list 'quote expr) rest symbols))
(define (lookup-symbol chars return rest symbols)
  (cond ((equal chars "cond") (return 'cond rest symbols))
        ((equal chars "let") (return 'let rest symbols))
        ((equal chars "fn") (return 'fn rest symbols))
        ((equal chars "quote") (return 'quote rest symbols))
        ((equal chars "cons") (return 'cons rest symbols))
        ((equal chars "car") (return 'car rest symbols))
        ((equal chars "cdr") (return 'cdr rest symbols))
        ((equal chars "atom") (return 'atom rest symbols))
        ((equal chars "number") (return 'number rest symbols))
        ((equal chars "function") (return 'function rest symbols))
        ((equal chars "=") (return '= rest symbols))
        ((equal chars "<") (return '< rest symbols))
        ((equal chars ">") (return '> rest symbols))
        ((equal chars "+") (return '+ rest symbols))
        ((equal chars "-") (return '- rest symbols))
        ((equal chars "*") (return '* rest symbols))
        ((equal chars "/") (return '/ rest symbols))
        ((equal chars "%") (return '% rest symbols))
        ((equal chars "~") (return '~ rest symbols))
        ((equal chars "&") (return '& rest symbols))
        ((equal chars "|") (return '| rest symbols))
        ((equal chars "^") (return '^ rest symbols))
        ((equal chars ">>") (return '>> rest symbols))
        ((equal chars ">>>") (return '>>> rest symbols))
        ((equal chars "<<") (return '<< rest symbols))
        ((equal chars "define") (return 'define rest symbols))
        ('t (get-symbol chars symbols
                        (fn (id new-symbols)
                          (return id rest new-symbols))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Parser combinators that simplify the process of writting an LL(1) ;;
;; grammar.                                                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Each parser takes a return continuation, an error continuation,   ;;
;; an input string, and a symbol table. They implement a function    ;;
;; that parses the string, and passes the tree, remaining chars, and ;;
;; new symbol table to the return, or "fails" and passes a message,  ;;
;; the remaining chars, and new symbol table to the error.           ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (fail return error input symbols) (error input symbols))
(define (done return error input symbols) (return () input symbols))
(define (check test)
  (fn (return error input symbols)
    (cond ((test (car input)) (return (car input) (cdr input) symbols))
          ('t (error input symbols)))))
(define (pop return error input symbols)
  (cond ((atom input) (error input symbols))
        ('t (return (car input) (cdr input) symbols))))
(define (match char) (check (fn (val) (= val char))))
(define (default parser) (fn (else) parser))
(define (case test then)
  (fn (else)
    (fn (return error input symbols)
      (test (fn (val rest symbols) (then return error rest symbols))
            (fn (rest symbols) (else return error input symbols))
            input symbols))))
(define (choice . args) ((fold (fn (c cs) (c cs)) fail) args))
(define (post-process parser op)
  (fn (return error input symbols)
    (parser (fn (val rest symbols) (op val return rest symbols))
            error input symbols)))
(define (seq parser1 parser2)
  (fn (return error input symbols)
    (parser1 (fn (head next symbols)
               (parser2 (fn (tail rest symbols)
                          (return (cons head tail) rest symbols))
                        error next symbols))
             error input symbols)))
(define (escape parser) (seq (post-process pop escape-char) parser))
(define (use parser) (seq pop parser))
(define (peek parser)
  (fn (return error input symbols)
    (parser (fn (val rest symbols) (return val input symbols))
            error input symbols)))
(define (interval start end)
  (check (fn (val) (and (> val (- start 1)) (< val (+ end 1))))))
(define (skip parser) (post-process (use parser) drop-first))
(define (first parser1 parser2)
  (post-process (seq parser1 parser2) drop-second))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to parse an s-expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (parse-num . args)
  (apply (choice (case (peek (interval 48 57)) (use parse-num))
                 (default done))
         args))
(define (read-num . args) (apply (post-process parse-num build-num) args))
(define (parse-symbol . args)
  (apply (choice (case (match ()) done)
                 (case (peek (interval 0 32)) done)
                 (case (peek (interval 39 41)) done)
                 (case (peek (match 46)) done)
                 (case (peek (match 59)) done)
                 (default (use parse-symbol)))
         args))
(define (read-symbol . args)
  (apply (post-process parse-symbol lookup-symbol) args))
(define (parse-string . args)
  (apply (choice (case (match 34) done)
                 (case (match 92) (escape parse-string))
                 (default (use parse-string)))
         args))
(define (quote-parser parser) (post-process parser quote-value))
(define (comment parser)
  (recurse (fn (this) (choice (case (match 10) parser)
                              (case (match 13) parser)
                              (default (skip this))))))
(define (parse-paren . args)
  (apply (choice (case (interval 0 32) parse-paren)
                 (case (match 59) (comment parse-paren))
                 (case (match 41) done))
         args))
(define (parse-pair parser)
  (recurse (fn (this)
               (choice (case (interval 0 32) this)
                       (case (match 59) (comment this))
                       (case (match 41) done)
                       (case (match 46) (first parser parse-paren))
                       (default (seq parser this))))))
(define (parse-expr . args)
  (apply (choice (case (interval 0 32) parse-expr)
                 (case (match 34) (quote-parser parse-string))
                 (case (match 39) (quote-parser parse-expr))
                 (case (match 40) (parse-pair parse-expr))
                 (case (match 41) fail)
                 (case (match 46) fail)
                 (case (match 59) (comment parse-expr))
                 (case (peek (interval 48 57)) read-num)
                 (default read-symbol))
         args))
(define (read-expr chars cont symbol-table)
  (parse-expr cont
              (fn (rest symbols) (error "Parse error" rest))
              chars symbol-table))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to print s-expressions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (build-num-str num)
  ((walk (fn (n) (% n 10))
         (fn (n) (/ n 10))
         (fn (n) (= n 0))
         (fn (d op) (fn (str) (op (cons (+ d 48) str))))
         (fn (x) id))
   num))
(define (print-num num)
  (cond ((< num 0) (cons 45 ((build-num-str (- num)) "")))
        ((= num 0) "0")
        ('t ((build-num-str num) ""))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Since we will be mixing user symbols with compiler symbols, we  ;;
;; need to ensure that there are no naming conflicts when printing ;;
;; the generated program. To do this we print symbols using their  ;;
;; id instead of their name.                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (print-symbol sym) (append "symbol" (print-num (symbol->id sym))))

(define (print-atom expr)
  (cond ((number expr) (print-num expr))
        ((function expr) (print-symbol expr))
        ((= expr quote) "quote")
        ((= expr car) "car")
        ((= expr cdr) "cdr")
        ((= expr number) "number")
        ((= expr function) "function")
        ((= expr atom) "atom")
        ((= expr cons) "cons")
        ((= expr cond) "cond")
        ((= expr let) "let")
        ((= expr fn) "fn")
        ((= expr >>>) ">>>")
        ((= expr >>) ">>")
        ((= expr <<) "<<")
        ((= expr <) "<")
        ((= expr >) ">")
        ((= expr =) "=")
        ((= expr +) "+")
        ((= expr -) "-")
        ((= expr *) "*")
        ((= expr /) "/")
        ((= expr %) "%")
        ((= expr &) "&")
        ((= expr |) "|")
        ((= expr ^) "^")
        ((= expr ~) "~")
        ((= expr 'define) "define")
        ('t "<INTERNAL ERROR>")))
(define (print_pair head tail-str)
  (let ((closing-string (cond ((= (car tail-str) 41) tail-str)
                              ('t (cons 32 tail-str)))))
    ((append-print closing-string) head)))
(define (print-last tail-str)
  (let ((closing-string (append ")" tail-str)))
    (fn (elem)
        (cond (elem (append " . " ((append-print closing-string) elem)))
              ('t closing-string)))))
(define (append-print tail_str)
  (fn (expr)
      (cond ((= expr ()) (append "()" tail_str))
            ((atom expr) (append (print-atom expr) tail_str))
            ('t (append "("
                        ((walk car cdr atom
                               print_pair
                               (print-last tail_str))
                         expr))))))
(define print (append-print "\n"))

(define t-symbol (make-symbol 0 "t"))
(define arg-symbol (make-symbol 1 "arg"))
(define env-symbol (make-symbol 2 "env"))
(define ret-symbol (make-symbol 3 "ret"))
(define op-symbol (make-symbol 4 "op"))
(define first-symbol (make-symbol 5 "first"))
(define second-symbol (make-symbol 6 "second"))
(define test-symbol (make-symbol 7 "test"))

(define (QUOTE expr)
  (list 'fn (list env-symbol ret-symbol)
  	(list ret-symbol (list 'quote expr))))
(define (LIT expr)
  (list 'fn (list env-symbol ret-symbol) (list ret-symbol expr)))

(define ROOT (list 'fn (list env-symbol ret-symbol)
                       (list ret-symbol env-symbol)))
(define (HD env) (list 'fn (list env-symbol ret-symbol)
                       (list env env-symbol
                             (list 'fn (list env-symbol)
                                   (list ret-symbol (list 'car env-symbol))))))
(define (TL env) (list 'fn (list env-symbol ret-symbol)
                       (list env env-symbol
                             (list 'fn (list env-symbol)
                                   (list ret-symbol (list 'cdr env-symbol))))))
(define (FIND var globals)
  (cond (((contains symbol-eq var) globals)
         (list 'fn (list env-symbol ret-symbol) (list ret-symbol var)))
        ('t (LIT ()))))

(define (IF test then else)
  (list 'fn (list env-symbol ret-symbol)
        (list test env-symbol
              (list 'fn (list test-symbol)
                    (list (list 'cond (list test-symbol then)
                                      (list (list 'quote t-symbol) else))
                          env-symbol ret-symbol)))))
(define (PAIR first second)
  (list 'fn (list env-symbol ret-symbol)
        (list first env-symbol
              (list 'fn (list first-symbol)
                    (list second env-symbol
                          (list 'fn (list second-symbol)
                                (list ret-symbol
                                      (list 'cons first-symbol
                                            second-symbol))))))))
(define (APPLY op arg)
  (list 'fn (list env-symbol ret-symbol)
        (list arg env-symbol
              (list 'fn (list arg-symbol)
                    (list op env-symbol
                          (list 'fn (list op-symbol)
                                (list 'cond
                                      (list (list 'function op-symbol)
                                            (list op-symbol
                                                  arg-symbol
                                                  ret-symbol))
                                      (list (list 'quote t-symbol)
                                            (list ret-symbol
                                                  (cons op-symbol arg-symbol))))))))))
(define (LAMBDA body)
  (list 'fn (list env-symbol ret-symbol)
        (list ret-symbol
	      (list 'fn (list arg-symbol ret-symbol)
	      	    (list body (list 'cons arg-symbol env-symbol) ret-symbol)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compiler from s-expressions to lambda terms ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (compile-var var env ret empty)
  (cond ((atom env) (cond ((symbol-eq var env) (ret ROOT))
                          ('t (empty))))
        ('t (compile-var var (car env) (fn (e) (ret (HD e)))
                         (fn () (compile-var var (cdr env)
                                             (fn (e) (ret (TL e)))
                                             empty))))))
(define (compile-find var env globals)
  (compile-var var env id (fn () (FIND var globals))))
(define (compile-cond env globals)
  (walk car cdr atom
        (fn (case else) (IF (compile-expr (car case) env globals)
                            (compile-expr (cadr case) env globals)
                            else))
        (fn (cases) (LIT ()))))
(define (compile-let bindings body env globals)
  (compile-expr ((walk car cdr atom
                  (fn (binding expr)
                      (list (list 'fn (list (car binding)) expr)
                            (cadr binding)))
                  (fn (bindings) body))
                 bindings)
                env globals))
(define (compile-args env globals)
  (walk car cdr atom
        (fn (arg arg-list) (PAIR (compile-expr arg env globals) arg-list))
        (fn (args) (compile-expr args env globals))))
(define (compile-expr expr env globals)
  (cond ((function expr) (compile-find expr env globals))
        ((atom expr) (LIT expr))
        ((= (car expr) 'quote) (QUOTE (cadr expr)))
        ((= (car expr) 'cond) ((compile-cond env globals) (cdr expr)))
        ((= (car expr) 'let)
         (compile-let (cadr expr) (caddr expr) env globals))
        ((= (car expr) 'fn)
         (LAMBDA (compile-expr (caddr expr) (cons (cadr expr) env) globals)))
        ('t (APPLY (compile-expr (car expr) env globals)
                   ((compile-args env globals) (cdr expr))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile expressions to coroutines ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (get-name definition)
  (cond ((atom (cadr definition)) (cadr definition))
        ('t (caadr definition))))
(define (get-body definition)
  (cond ((atom (cadr definition)) (caddr definition))
        ('t (list 'fn (cdr (cadr definition)) (caddr definition)))))
(define return-cont (list 'fn (list arg-symbol) arg-symbol))
(define (compile-definition globals)
  (fn (definition)
      (let ((name (get-name definition))
            (body (get-body definition))
	    (compiled-body (compile-expr body '() globals)))
        (append "(define "
                (print name)
                "("
                ((append-print " () (fn (x) x)))\n") compiled-body)))))
(define main-definition
  "(define (main proc)
     (cond ((function proc) (fn (in) (proc in main)))
           ((atom proc) proc)
           ('t (cons (car proc) (main (cdr proc))))))\n")
(define (compile definitions expr)
  (let ((globals (map get-name definitions))
        (compiled-expr (append "("
                               (print (compile-expr expr '() globals))
                               " () main)"))
        (bodies (map (compile-definition globals) definitions)))
    (apply append (cons main-definition
                        (append bodies (list compiled-expr))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to perform process I/O ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;(define empty-inbox ())
;(define (add-message id msg inbox) (cons (cons id msg) inbox))
;(define (is-inbox-empty inbox) (atom inbox))
;(define (get-message inbox return) (return (car inbox) (cdr inbox)))

;(define (add-child child-id child-mem child children globals)
;  (cons (list child-id
;              (process-expr child globals child-mem)
;              empty-inbox
;              ())
;        children))
;(define (send-child-msg id msg children)
;  ((fold (fn (child children)
;             (cons (cond ((= (car child) id)
;                          (list (car child)
;                                (car (cdr child))
;                                (add-message () msg (car (cdr (cdr child))))
;                                (car (cdr (cdr (cdr child))))))
;                         ('t child))
;                   children))
;         ())
;   children))

;(define (run-expr expr globals mem)
;  (process-expr (compile-expr expr ()) globals mem))
;(define (process-expr expr globals mem)
;  (expr NIL globals mem (process-result globals mem)))
;(define (process-children children inbox return)
;  (((foldl (fn (child return)
;               (fn (children inbox)
;                   (process-tree child inbox
;                                 (fn (child inbox)
;                                     (cond (child (return (cons child children)
;                                                          inbox))
;                                           ('t (return children inbox)))))))
;           return) children)
;   () inbox))
;(define (process-tree (id process inbox children) parent-inbox return)
;  (let ((status (car process))
;        (result (cadr process)))
;    (cond ((= status 'running)
;           (process-children children inbox
;                             (fn (children inbox)
;                                 (return (list id (result) inbox children)
;                                         parent-inbox))))
;          ((= status 'done)
;           (result id inbox children parent-inbox
;                   (fn (process inbox children parent-inbox)
;                       (process-children children inbox
;                                         (fn (children inbox)
;                                             (return (list id process inbox children)
;                                                     parent-inbox))))))
;          ('t (return () (add-message id result parent-inbox))))))
;(define (process-result globals mem)
;  (fn (val)
;      (fn (id inbox children parent-inbox return)
;          (process-io id val inbox children parent-inbox globals return))))
;(define (process-io id process inbox children parent-inbox globals return)
;  (cond ((FUNCTION process) ;; Read an input
;         (cond ((is-inbox-empty inbox) ;; Block waiting for input
;                (return (list 'quote process) inbox children parent-inbox))
;               ('t (get-message inbox (fn (msg inbox)
;                                          (return (list process msg) inbox
;                                                  children parent-inbox))))))
;        ((ATOM process) ;; Abort process
;         (return () () () (add-message id process parent-inbox)))
;        ((ATOM (CAR process)) ;; Send message to parent
;         (process-io id (CDR process) inbox children
;                     (add-message id (CAR process) parent-inbox)
;                     globals return))
;        ((EQ (CAR (CAR process)) NIL) ;; Send message to parent
;         (process-io id (CDR process) inbox children
;                     (add-message id (CDR (CAR process)) parent-inbox)
;                     globals return))
;        ((ATOM (CAR (CAR process))) ;; Send message to children
;         (process-io id (CDR process) inbox
;                        (send-child-msg (CAR (CAR process))
;                                        (CDR (CAR process)) children)
;                        parent-inbox globals return))
;        ('t ;; Fork a child process
;         (let ((child-id (CAR (CAR (CAR process))))
;               (child-mem (CDR (CAR (CAR process))))
;               (child (CDR (CAR process))))
;           (process-io id (CDR process) inbox
;                       (add-child child-id child-mem child children globals)
;                       parent-inbox globals return)))))

;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the input ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (input-finished? input-chars)
  (cond ((= input-chars '()) 't)
        ((< (car input-chars) 32) (input-finished? (cdr input-chars)))
        ('t '())))
(define (compile-source definitions)
  (fn (value remaining-chars symbol-table)
    (cond ((input-finished? remaining-chars)
           (compile definitions value))
          ((not (= (car value) 'define))
           (error "Remaining input" remaining-chars))
          ((not (or (atom (cadr value)) (atom (caadr value))))
           (error "Malformed define statement" remaining-chars))
          ('t (read-expr remaining-chars
                         (compile-source (cons value definitions))
                         symbol-table)))))
(define (compile-input input-chars)
  (read-expr input-chars (compile-source '()) '()))
(define (build-input-list inputs return)
  (fn (next-input)
    (cond ((= next-input '()) (return (reverse inputs)))
          ('t (build-input-list (cons next-input inputs) return)))))
(fn (size arguments) (build-input-list '() compile-input))
