;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Losak compiler                                                  ;;
;;                                                                 ;;
;; This stage of the compiler rewrites the multi-process program   ;;
;; into a single process that consists of communicating            ;;
;; co-routines.                                                    ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Copyright (C) 2004 - 2011 by Omar Jarjur                        ;;
;;                                                                 ;;
;; This program is free software; you can redistribute it and/or   ;;
;; modify it under the terms of version 2 of the GNU General       ;;
;; Public License as published by the Free Software Foundation.    ;;
;;                                                                 ;;
;; This program is distributed in the hope that it will be useful, ;;
;; but WITHOUT ANY WARRANTY; without even the implied warranty of  ;;
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ;;
;; GNU General Public License for more details.                    ;;
;;                                                                 ;;
;; You should have received a copy of the GNU General Public       ;;
;; License along with this program; if not, write to the Free      ;;
;; Software Foundation, Inc.,                                      ;;
;; 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;
;; Error handling ;;
;;;;;;;;;;;;;;;;;;;;
(define map-to-stderr
  (foldr (fn (char output) (cons (list (cons 2 char)) output)) ()))
(define (print-warnings line-number warnings)
  (cond (warnings (map-to-stderr (append "WARNING; "
                                         "In expression beginning on line "
                                         (print line-number) ": " warnings
                                         "\n")))
        ('t ())))
(define (print-error msg) (map-to-stderr (append "Error; "msg "\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities for preventing name collisions ;;
;; in the output of the CPS transformation  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (number->symbol symbol-id)
  (string->symbol (append "s" (print symbol-id))))
(define special-forms '(quote if define fn))
(define builtins
  '(cons car cdr atom number function = < > + - * / % ~ & | ^ >> >>> <<))
(define (escape-symbols expr)
  (cond ((atom expr)
         (cond ((member expr special-forms) expr)
               ((member expr builtins) expr)
               ((symbol? expr)
                (string->symbol (append "_" (symbol->string expr))))
               ('t expr)))
        ('t (cons (escape-symbols (car expr)) (escape-symbols (cdr expr))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CPS-Transformation functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define scheduler-symbol (string->symbol "scheduler"))
(define terminated-symbol (string->symbol "terminated"))
(define expr-continuation-symbol (string->symbol "expr-handler"))
(define process-continuation-symbol (string->symbol "process-handler"))
(define initial-symbol-name "s_")

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Transform a tail call ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (transform-fn-tail-call params body next-symbol-name
                                continuation scheduler)
  (let ((return-symbol (string->symbol next-symbol-name))
        (next-symbol-name (append next-symbol-name "_body"))
        (cps-params (cons scheduler-symbol
                          (cons return-symbol (escape-symbols params)))))
    `(,scheduler ,continuation
                 (fn ,cps-params
                     ,(transform-tail-call body next-symbol-name
                                           return-symbol
                                           scheduler-symbol)))))
(define (transform-application-tail-call op args next-symbol-name
                                         continuation scheduler)
  (let ((val-symbol (string->symbol next-symbol-name))
        (op-next-symbol-name (append next-symbol-name "_op"))
        (args-next-symbol-name (append next-symbol-name "_args")))
    (transform op op-next-symbol-name
               (fn (scheduler op-code)
                   (transform-args args '() args-next-symbol-name
                                   (fn (scheduler args-code)
                                       (list op-code
                                             scheduler
                                             continuation
                                             . args-code))
                                   scheduler))
               scheduler)))
(define (transform-if-tail-call test then else next-symbol-name
                                continuation scheduler)
  (let ((test-value-symbol (string->symbol next-symbol-name))
        (test-next-symbol-name (append next-symbol-name "_test"))
        (then-next-symbol-name (append next-symbol-name "_then"))
        (else-next-symbol-name (append next-symbol-name "_else"))
        (then-code (transform-tail-call then then-next-symbol-name
                                        continuation scheduler-symbol))
        (else-code (transform-tail-call else else-next-symbol-name
                                        continuation scheduler-symbol)))
    (transform test test-next-symbol-name
               (fn (scheduler test-code)
                   `(,scheduler
                     (fn (,scheduler-symbol
                          ,terminated-symbol
                          ,test-value-symbol)
                         (if ,test-value-symbol ,then-code ,else-code))
                     ,test-code))
               scheduler)))
(define (transform-atom-tail-call expr next-symbol-name continuation scheduler)
  (cond ((= expr '()) `(,scheduler ,continuation ,expr))
        ((number expr) `(,scheduler ,continuation ,expr))
        ((not (member expr builtins))
         `(,scheduler ,continuation ,(escape-symbols expr)))
        ('t (let ((return-symbol (string->symbol next-symbol-name))
                  (args-symbol (string->symbol (append next-symbol-name "_args"))))
              `(,scheduler ,continuation
                           (fn ,(cons scheduler-symbol
                                      (cons return-symbol args-symbol))
                               (,scheduler-symbol ,return-symbol
                                                  ,(cons expr
                                                         args-symbol))))))))
(define (transform-tail-call expr next-symbol-name continuation scheduler)
  (cond ((atom expr)
         (transform-atom-tail-call expr next-symbol-name
                                   continuation scheduler))
        ((= (car expr) 'fn)
         (transform-fn-tail-call (cadr expr) (caddr expr) next-symbol-name
                                 continuation scheduler))
        ((= (car expr) 'if)
         (transform-if-tail-call (cadr expr) (caddr expr) (cadr (cddr expr))
                                 next-symbol-name continuation scheduler))
        ((= (car expr) 'quote) `(,scheduler ,continuation ,expr))
        ('t (transform-application-tail-call (car expr) (cdr expr)
                                             next-symbol-name continuation
                                             scheduler))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Transform a non-tail call ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (transform-fn params body next-symbol-name builder scheduler)
  (let ((return-symbol (string->symbol next-symbol-name))
        (next-symbol-name (append next-symbol-name "_body"))
        (cps-params (cons scheduler-symbol
                          (cons return-symbol (escape-symbols params)))))
    (builder scheduler
             `(fn ,cps-params
                  ,(transform-tail-call body next-symbol-name
                                        return-symbol
                                        scheduler-symbol)))))
(define (transform-args args args-code next-symbol-name builder scheduler)
  (cond ((= args '()) (builder scheduler (reverse args-code)))
        ((atom args)
         (let ((arg-symbol (string->symbol next-symbol-name))
               (arg-next-symbol-name (append next-symbol-name "_arg")))
           (transform args arg-next-symbol-name
                      (fn (scheduler code)
                          (builder scheduler
                                   (append (reverse args-code) code)))
                      scheduler)))
        ('t (let ((arg-symbol (string->symbol next-symbol-name))
                  (arg-next-symbol-name (append next-symbol-name "_arg"))
                  (args-next-symbol-name (append next-symbol-name "_args")))
              (transform (car args) arg-next-symbol-name
                         (fn (scheduler arg-code)
                             (transform-args (cdr args)
                                             (cons arg-code args-code)
                                             args-next-symbol-name
                                             builder scheduler))
                         scheduler)))))
(define (transform-application op args next-symbol-name builder scheduler)
  (let ((val-symbol (string->symbol next-symbol-name))
        (op-next-symbol-name (append next-symbol-name "_op"))
        (args-next-symbol-name (append next-symbol-name "_args")))
    (transform op op-next-symbol-name
               (fn (scheduler op-code)
                   (transform-args args '() args-next-symbol-name
                                   (fn (scheduler args-code)
                                       (list op-code
                                             scheduler
                                             `(fn (,scheduler-symbol
                                                   ,terminated-symbol
                                                   ,val-symbol)
                                                  ,(builder scheduler-symbol
                                                            val-symbol))
                                             . args-code))
                                   scheduler))
               scheduler)))
(define (transform-if test then else next-symbol-name builder scheduler)
  (let ((test-value-symbol (string->symbol next-symbol-name))
        (test-next-symbol-name (append next-symbol-name "_test"))
        (then-next-symbol-name (append next-symbol-name "_then"))
        (else-next-symbol-name (append next-symbol-name "_else"))
        (then-code (transform then then-next-symbol-name
                              builder scheduler-symbol))
        (else-code (transform else else-next-symbol-name
                              builder scheduler-symbol)))
    (transform test test-next-symbol-name
               (fn (scheduler test-code)
                   `(,scheduler
                     (fn (,scheduler-symbol
                          ,terminated-symbol
                          ,test-value-symbol)
                         (if ,test-value-symbol ,then-code ,else-code))
                     ,test-code))
               scheduler)))
(define (transform-atom expr next-symbol-name builder scheduler)
  (cond ((= expr '()) (builder scheduler expr))
        ((number expr) (builder scheduler expr))
        ((not (member expr builtins))
         (builder scheduler (escape-symbols expr)))
        ('t (let ((return-symbol (string->symbol next-symbol-name))
                  (args-symbol (string->symbol (append next-symbol-name
                                                       "_args"))))
              (builder scheduler
                       `(fn ,(cons scheduler-symbol
                                   (cons return-symbol args-symbol))
                            (,scheduler-symbol ,return-symbol
                                               ,(cons expr args-symbol))))))))
(define (transform expr next-symbol-name builder scheduler)
  (cond ((atom expr) (transform-atom expr next-symbol-name builder scheduler))
        ((= (car expr) 'fn)
         (transform-fn (cadr expr) (caddr expr) next-symbol-name
                       builder scheduler))
        ((= (car expr) 'if)
         (transform-if (cadr expr) (caddr expr) (cadr (cddr expr))
                       next-symbol-name builder scheduler))
        ((= (car expr) 'quote) (builder scheduler expr))
        ('t (transform-application (car expr) (cdr expr) next-symbol-name
                                   builder scheduler))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile expressions to coroutines ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (cps-transformation expr continuation)
  (transform expr initial-symbol-name
             (fn (scheduler expr-code) `(,scheduler ,continuation ,expr-code))
             scheduler-symbol))
(define (transform-statement statement)
  (cond ((atom statement)
         (cps-transformation statement process-continuation-symbol))
        ((= (car statement) 'define)
         `(define ,(escape-symbols (cadr statement))
            ,(cps-transformation (caddr statement) expr-continuation-symbol)))
        ('t (cps-transformation statement process-continuation-symbol))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Output code to perform process I/O ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define process-manager-code
  `((define ,expr-continuation-symbol
      (fn (running-scheduler terminated-scheduler expr) expr))
    (define process-continuation
      (fn (running-scheduler terminated-scheduler expr)
          (terminated-scheduler expr)))
    (define ,process-continuation-symbol process-continuation)
    (define initial-process-runner
      (fn (initial-process) (run-process initial-process empty-messenger)))
    (define top-level-scheduler
      (fn (continuation process-value)
          (make-process 0 continuation process-value
                        empty-process-list empty-mailbox
                        initial-process-runner)))
    (define ,scheduler-symbol top-level-scheduler)
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; TODO: Replace with a real-time FIFO Queue ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Mailbox:: (M,R)=>((M,Mailbox<M,R>,T->R)->R,T,T->R)->R
    (define empty-mailbox
      (fn (non-empty-handler empty-result return) (return empty-result)))
    (define add-to-mailbox ;; (M,R)=>(M,Mailbox<M,R>,Mailbox<M,R>->R)->R
      (fn (msg inbox return)
          (inbox (fn (first-msg remaining-inbox return)
                     (add-to-mailbox msg remaining-inbox
                                     (fn (updated-remaining)
                                         (return (fn (non-empty empty return)
                                                     (non-empty first-msg
                                                                updated-remaining
                                                                return))))))
                 (fn (non-empty-handler empty-result return)
                     (non-empty-handler msg empty-mailbox return))
                 return)))
    
    ;; Messenger:: (M,R)=>(Id,Mailbox<M,R>,Mailbox<M,R>->R)->R
    (define empty-messenger (fn (id mailbox return) (return mailbox)))
    (define targeted-messenger ; (Id,M,Messenger<M,R>,Messenger<M,R>->R)->R
      (fn (target-id message messenger return)
          (return (fn (id mailbox return)
                      (messenger id mailbox
                                 (fn (mailbox)
                                     ((fn (test)
                                          (if test
                                              (add-to-mailbox message mailbox
                                                              return)
                                            (return mailbox)))
                                      (= target-id id))))))))
    (define blind-messenger ; (M,Messenger<M,R>->R)->R
      (fn (message return)
          (return (fn (id mailbox return)
                      (add-to-mailbox message mailbox return)))))
    
    ;; ProcessList:: (M,R)=>(Messenger<M,R>,Mailbox<M,R>,ProcessListReturn<M,R>)->R
    ;; ProcessListReturn:: (M,R)=>(ProcessList<M,R>,Mailbox<M,R>)->R
    ;; Process:: (M,R)=>(Messenger<M,R>,RunningHandler<M,R>,EventHandler<M,R>)->R
    ;; ProcessEvent:: (M,R)=>(Mailbox<M,R>,RunningReturn<M,R>,TerminatedReturn<M,R>)->R
    ;; RunningHandler:: (M,R)=>(Process<M,R>)->R
    ;; EventHandler:: (M,R)=>(ProcessEvent<M,R>)->R
    (define empty-process-list ; ProcessList<M,R>
      (fn (messenger parent-mailbox return)
          (return empty-process-list parent-mailbox)))
    (define add-process ; (Process<M,R>,ProcessList<M,R>,ProcessList<M,R>->R)->R
      (fn (process siblings return)
          (return (fn (messenger parent-mailbox return)
                      (siblings
                       messenger parent-mailbox
                       (fn (updated-siblings updated-parent-mailbox)
                           (make-handlers updated-siblings
                                          updated-parent-mailbox
                                          (fn (updated-process updated-parent-mailbox)
                                              (add-process updated-process
                                                           updated-siblings
                                                           (fn (updated-processes)
                                                               (return updated-processes
                                                                       updated-parent-mailbox))))
                                          (fn (updated-parent-mailbox)
                                              (return updated-siblings
                                                      updated-parent-mailbox))
                                          (fn (running-handler event-handler)
                                              (process messenger
                                                       running-handler
                                                       event-handler)))))))))
    
    ;; RunningReturn:: (M,R)=>(Process<M,R>,Mailbox<M,R>)->R
    ;; TerminatedReturn:: (M,R)=>Mailbox<M,R>->R
    ;; (M,R)=>(ProcessList<M,R>,Mailbox<M,R>,RunningReturn<M,R>,TerminatedReturn<M,R>,(RunningHandler<M,R>,EventHandler<M,R>)->R)->R
    (define make-handlers
      (fn (siblings parent-mailbox running-return terminated-return return)
          (return (fn (updated-process)
                      (running-return updated-process parent-mailbox))
                  (fn (process-event)
                      (process-event empty-messenger parent-mailbox
                                     running-return terminated-return)))))
    
    ;; ProcessContinuation:: (R,V)=>(RunningScheduler<R,V>,TerminatedScheduler<R,V>,V)->R
    ;; RunningScheduler:: (R,V)=>(ProcessContinuation<R,V>,V)->R
    ;; TerminatedScheduler:: (R,V)=>V->R
    ;; (M,R,V)=>(Id,ProcessContinuation<R,V>,V,ProcessList<M,R>,Mailbox<M>,Process<M,R>->R)->R
    (define make-process
      (fn (id continuation value children mailbox return)
          (return (fn (messenger running-handler event-handler)
                      (messenger id mailbox
                                 (fn (updated-mailbox)
                                     (make-schedulers id updated-mailbox children
                                                      running-handler
                                                      event-handler
                                                      (fn (running-scheduler
                                                           terminated-scheduler)
                                                          (continuation
                                                           running-scheduler
                                                           terminated-scheduler
                                                           value)))))))))
    
    ;; (M,R,V)=>(Id,Mailbox<M>,ProcessList<M,R>,RunningHandler<M,R>,EventHandler<M,R>,(RunningScheduler<R,V>,TerminatedScheduler<R,V>)->R)->R
    (define make-schedulers
      (fn (id mailbox children running-handler event-handler return)
          (return (fn (continuation value)
                      (children empty-messenger mailbox
                                (fn (updated-children updated-mailbox)
                                    (make-process id continuation value
                                                  updated-children updated-mailbox
                                                  (fn (updated-process)
                                                      (running-handler
                                                       updated-process))))))
                  (fn (value)
                      (event-handler (fn (messenger parent-mailbox
                                                    running-return
                                                    terminated-return)
                                         (messenger id mailbox
                                                    (fn (mailbox)
                                                        (process-io id value
                                                                    mailbox
                                                                    children
                                                                    empty-messenger
                                                                    parent-mailbox
                                                                    running-return
                                                                    terminated-return)))))))))
    
    (define flush-mailbox
      (fn (mailbox end return)
          (mailbox (fn (first-message remaining-mailbox return)
                       (flush-mailbox remaining-mailbox end
                                      (fn (result)
                                          (return (cons first-message
                                                        result)))))
                   end
                   return)))
    (define id-function (fn (result) result))
    (define write-messages
      (fn (outbox continuation) (flush-mailbox outbox continuation id-function)))
    
    ;; (M,R)=>RunningReturn<M,R>
    (define top-level-running-return
      (fn (process parent-mailbox)
          (write-messages parent-mailbox
                          (run-process process empty-messenger))))
    ;; (M,R)=>TerminatedReturn<M,R>
    (define top-level-terminated-return
      (fn (parent-mailbox) (write-messages parent-mailbox '())))
    ;; (M,R)=>EventHandler<M,R>
    (define top-level-event-handler
      (fn (process-event)
          (fn in (if in
                     (blind-messenger in
                                      (fn (messenger)
                                          (process-event messenger empty-mailbox
                                                         top-level-running-return
                                                         top-level-terminated-return)))
                   (process-event empty-messenger empty-mailbox
                                  top-level-running-return
                                  top-level-terminated-return)))))
    ;; (M,R)=>RunningHandler<M,R>
    (define top-level-running-handler
      (fn (process) (run-process process empty-messenger)))
    (define run-process
      (fn (process messenger)
          (process messenger
                   top-level-running-handler
                   top-level-event-handler)))
    
    ;; (M,R)=>(Id,R,Mailbox<M,R>,ProcessList<M,R>,Messenger<M,R>,Mailbox<M,R>,RunningReturn<M,R>,TerminatedReturn<M,R>)->R
    (define process-io
      (fn (id process-result mailbox children children-messenger parent-mailbox
              running-return terminated-return)
          ((fn (is-atom)
               (if is-atom
                   ((fn (is-function)
                        (if is-function
                            (process-input id process-result mailbox
                                           children children-messenger
                                           parent-mailbox running-return)
                          (terminated-return parent-mailbox)))
                    (function process-result))
                 (send-message id process-result mailbox children
                               children-messenger parent-mailbox
                               running-return terminated-return)))
           (atom process-result))))
    ;; (M,R)=>(Id,R,Mailbox<M,R>,ProcessList<M,R>,Mailbox<M,R>,RunningReturn<M,R>)->R
    (define process-input
      (fn (id handler mailbox children messenger parent-mailbox running-return)
          (children messenger mailbox
                    (fn (updated-children updated-mailbox)
                        (read-message id handler updated-mailbox updated-children
                                      (fn (return)
                                          (return (fn (updated-process)
                                                      (running-return
                                                       updated-process
                                                       parent-mailbox)))))))))
    (define read-message
      (fn (id handler mailbox children return)
          (mailbox (fn (message remaining-inbox return)
                       (handler (fn (cont value)
                                    (return (fn (process-return)
                                                (make-process id cont value
                                                              children
                                                              remaining-inbox
                                                              process-return))))
                                process-continuation
                                .
                                message))
                   (fn (process-return)
                       (make-process id process-continuation handler children
                                     empty-mailbox process-return))
                   return)))
    ;; (M,R)=>(Id,R,Mailbox<M,R>,ProcessList<M,R>,Messenger<M,R>,Mailbox<M,R>,RunningReturn<M,R>)->R
    (define send-message
      (fn (id result mailbox children children-messenger parent-mailbox
              running-return terminated-return)
          ((fn (continuation)
               ((fn (message)
                    (process-message message children
                                     children-messenger parent-mailbox
                                     (fn (children messenger parent-mailbox)
                                         (process-io id continuation mailbox
                                                     children messenger
                                                     parent-mailbox
                                                     running-return
                                                     terminated-return))))
                (car result)))
           (cdr result))))
    (define process-message
      (fn (message children messenger parent-mailbox return)
          ((fn (is-atom)
               (if is-atom
                   (add-to-mailbox (cons message '()) parent-mailbox
                                   (fn (parent-mailbox)
                                       (return children messenger parent-mailbox)))
                 (process-pair-message message children messenger
                                       parent-mailbox return)))
           (atom message))))
    (define process-pair-message
      (fn (message children messenger parent-mailbox return)
          ((fn (is-atom)
               (if is-atom
                   (add-to-mailbox message parent-mailbox
                                   (fn (parent-mailbox)
                                       (return children messenger parent-mailbox)))
                 (process-child-message (car message) (cdr message)
                                        children messenger
                                        (fn (children messenger)
                                            (return children
                                                    messenger
                                                    parent-mailbox)))))
           (atom (cdr message)))))
    (define process-child-message
      (fn (child-id message children messenger return)
          (if (atom (cdr message))
              (targeted-messenger child-id message messenger 
                                  (fn (messenger) (return children messenger)))
              (fork-child child-id (car message) (car (cdr message)) children
                          (fn (children) (return children messenger))))))
    (define fork-child
      (fn (child-id child-mem child-body children return)
          (add-to-mailbox (cons child-mem '()) empty-mailbox
                          (fn (child-mailbox)
                              (make-process child-id process-continuation
                                            child-body empty-process-list
                                            child-mailbox
                                            (fn (child-process)
                                                (add-process child-process
                                                             children
                                                             return)))))))
    ))

;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the input ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (read-expr cont line-number)
  (parse-expr cont (fn (error-message end-line)
                       (print-error (append "Parse error, line "
                                            (print end-line)
                                            ": " error-message "\n")))
              line-number))
(define (compile-source start-line-number)
  (fn (value end-line-number)
      (cond ((not value)
             (print-error "No main expression"))
            ((not (= (car value) 'define))
             (append (print (transform-statement value)) "\n"))
            ((not (or (atom (cadr value)) (atom (caadr value))))
             (print-error "Malformed define statement"))
            ('t (append (print (transform-statement value))
                        (read-expr (compile-source end-line-number)
                                   end-line-number))))))
(fn (size arguments)
    ((foldr (fn (statement suffix)
                (append (print statement) "\n" suffix))
            (read-expr (compile-source 1) 1))
     process-manager-code))
