;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Losak compiler                                                  ;;
;;                                                                 ;;
;; This stage of the compiler rewrites the multi-process program   ;;
;; into a single process that consists of communicating            ;;
;; co-routines.                                                    ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Copyright (C) 2004 - 2011 by Omar Jarjur                        ;;
;;                                                                 ;;
;; This program is free software; you can redistribute it and/or   ;;
;; modify it under the terms of version 2 of the GNU General       ;;
;; Public License as published by the Free Software Foundation.    ;;
;;                                                                 ;;
;; This program is distributed in the hope that it will be useful, ;;
;; but WITHOUT ANY WARRANTY; without even the implied warranty of  ;;
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ;;
;; GNU General Public License for more details.                    ;;
;;                                                                 ;;
;; You should have received a copy of the GNU General Public       ;;
;; License along with this program; if not, write to the Free      ;;
;; Software Foundation, Inc.,                                      ;;
;; 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (caar x) (car (car x)))
(define (cdar x) (cdr (car x)))
(define (cadr x) (car (cdr x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))

(define (id x) x)
(define (list . args) args)
(define (apply op args) (op . args))
(define (recurse op)
  ((fn (this) (op (fn args ((this this) . args))))
   (fn (this) (op (fn args ((this this) . args))))))
(define (walk head tail test merge ret)
  (fn (tree)
      (cond ((test tree) (ret tree))
            ('t (merge (head tree)
                       ((walk head tail test merge ret)
                        (tail tree)))))))
(define (rreverse list result return)
  (cond ((atom list) (return result))
        ('t (rreverse (cdr list) (cons (car list) result) return))))
(define (reverse list) (rreverse list '() id))
(define (foldl merge end)
  (fn (list)
      (cond ((atom list) end)
            ('t ((foldl merge (merge (car list) end)) (cdr list))))))
(define (foldr merge end)
  (fn (list) (rreverse list '() (foldl merge end))))
(define (append . args) ((foldr (fn (x xs)
                                    (cond ((= xs '()) x)
                                          ('t ((foldr cons xs) x))))
                                '()) args))
(define (equal x y)
  (cond ((atom x) (= x y))
        ((atom y) '())
        ((equal (car x) (car y)) (equal (cdr x) (cdr y)))
        ('t '())))
(define (map op list) ((foldr (fn (x xs) (cons (op x) xs)) '()) list))
(define (or . args) ((foldr (fn (t ts) (cond (t t) ('t ts))) '()) args))
(define (and . args) ((foldr (fn (t ts) (cond (t ts) ('t '()))) 't) args))
(define (not test) (cond (test '()) ('t 't)))
(define (member item list)
  (cond ((atom list) '())
        ((equal item (car list)) list)
        ('t (member item (cdr list)))))

;;;;;;;;;;;;;;;;;;;;
;; Error handling ;;
;;;;;;;;;;;;;;;;;;;;
(define map-to-stderr
  (foldr (fn (char output) (cons (list (cons 2 char)) output)) ()))
(define (print-warnings line-number warnings)
  (cond (warnings (map-to-stderr (append "WARNING; "
                                         "In expression beginning on line "
                                         (print line-number) ": " warnings
                                         "\n")))
        ('t ())))
(define (print-error msg) (map-to-stderr (append "Error; "msg "\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper functions for parsing ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (escape-char char)
  (cond ((= char 116) 9)
        ((= char 114) 13)
        ((= char 110) 10)
        ('t char)))
(define (build-num chars)
  ((foldl (fn (c n) (+ (* 10 n) (- c 48))) 0) chars))
(define (quote-value expr) (list 'quote expr))
(define (quasiquote-value expr) (list 'quasiquote expr))
(define (unquote-value expr) (list 'unquote expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Parser combinators that simplify the process of writting an LL(1) ;;
;; grammar.                                                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Each parser takes a return continuation, an error continuation,   ;;
;; and a current line number. They implement a function that takes   ;;
;; input one character at a time (in curried form), parses the input ;;
;; string, and passes the tree and updated line number to the        ;;
;; return, or "fails" and passes a message to the error.             ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (fail return error line-num) (error line-num))
(define (done return error line-num) (return () line-num))
(define (pop return error line-num)
  (fn (char)
      (cond ((= char '()) (pop return error line-num))
            ((not (number char)) (error line-num))
            ((= char 10) (return char (+ 1 line-num)))
            ('t (return char line-num)))))
(define (check test)
  (fn (return error line-num)
      (pop (fn (val line-num)
               (cond ((test val) (return val line-num))
                     ('t ((error line-num) val))))
           error line-num)))
(define (match char) (check (fn (val) (= val char))))
(define (default parser) (fn (else) parser))
(define (case test then)
  (fn (else)
      (fn (return error line-num)
          (test (fn (val line-num)
                    (then return error line-num))
                (fn (symbols) (else return error line-num))
                line-num))))
(define (choice . args) ((foldr (fn (c cs) (c cs)) fail) args))
(define (post-process parser op)
  (fn (return error line-num)
      (parser (fn (val line-num) (return (op val) line-num))
              error line-num)))
(define (seq parser1 parser2)
  (fn (return error line-num)
      (parser1 (fn (head line-num)
                   (parser2 (fn (tail line-num)
                                (return (cons head tail) line-num))
                            error line-num))
               error line-num)))
(define (escape parser) (seq (post-process pop escape-char) parser))
(define (use parser) (seq pop parser))
(define (peek parser)
  (fn (return error line-num)
      (parser (fn (val new-line-num)
                  ((return val line-num) val))
              error line-num)))
(define (interval start end)
  (check (fn (val) (and (> val (- start 1)) (< val (+ end 1))))))
(define (skip parser) (post-process (use parser) cdr))
(define (first parser1 parser2) (post-process (seq parser1 parser2) car))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to parse an s-expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (parse-num . args)
  (apply (choice (case (peek (interval 48 57)) (use parse-num))
                 (default done))
         args))
(define (read-num . args) (apply (post-process parse-num build-num) args))
(define (parse-symbol . args)
  (apply (choice (case (interval 0 32) done)
                 (case (peek (interval 39 41)) done)
                 (case (peek (match 46)) done)
                 (case (peek (match 59)) done)
                 (default (use parse-symbol)))
         args))
(define (read-symbol . args)
  (apply (post-process parse-symbol string->symbol) args))
(define (parse-string . args)
  (apply (choice (case (match 34) done)
                 (case (match 92) (escape parse-string))
                 (default (use parse-string)))
         args))
(define (quote-parser parser) (post-process parser quote-value))
(define (quasiquote-parser parser) (post-process parser quasiquote-value))
(define (unquote-parser parser) (post-process parser unquote-value))
(define (comment parser)
  (fn args (apply (choice (case (match 10) parser)
                          (case (match 13) parser)
                          (default (skip (comment parser))))
                  args)))
(define (parse-paren . args)
  (apply (choice (case (interval 1 32) parse-paren)
                 (case (match 59) (comment parse-paren))
                 (case (match 41) done))
         args))
(define (parse-pair . args)
  (apply (choice (case (interval 1 32) parse-pair)
                 (case (match 59) (comment parse-pair))
                 (case (match 41) done)
                 (case (match 46) (first parse-expr parse-paren))
                 (default (seq parse-expr parse-pair)))
         args))
(define (parse-expr . args)
  (apply (choice (case (interval 1 32) parse-expr)
                 (case (match 34) (quote-parser parse-string))
                 (case (match 39) (quote-parser parse-expr))
                 (case (match 96) (quasiquote-parser parse-expr))
                 (case (match 44) (unquote-parser parse-expr))
                 (case (match 40) parse-pair)
                 (case (match 41) fail)
                 (case (match 46) fail)
                 (case (match 59) (comment parse-expr))
                 (case (peek (interval 48 57)) read-num)
                 (default read-symbol))
         args))
(define (read-expr cont line-number)
  (parse-expr cont (fn (end-line)
                       (print-error (append "Parse error, line "
                                            (print-num line-number)
                                            " -> line "
                                            (print-num end-line)
                                            "\n")))
              line-number))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to print s-expressions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (build-num-str num)
  ((walk (fn (n) (% n 10))
         (fn (n) (/ n 10))
         (fn (n) (= n 0))
         (fn (d op) (fn (str) (op (cons (+ d 48) str))))
         (fn (x) id))
   num))
(define (print-num num)
  (cond ((< num 0) (cons 45 ((build-num-str (- num)) "")))
        ((= num 0) "0")
        ('t ((build-num-str num) ""))))
(define (print-atom expr)
  (cond ((number expr) (print-num expr))
        ((symbol? expr) (symbol->string expr))
        ('t "<INTERNAL ERROR>")))
(define (print-tail expr suffix)
  (cond ((= expr '()) (append ")" suffix))
        ((atom expr) (append " . " (print-atom expr) ")" suffix))
        ('t (append " " (print-with-suffix (car expr)
                                           (print-tail (cdr expr) suffix))))))
(define (print-with-suffix expr suffix)
  (cond ((= expr '()) (append "()" suffix))
        ((atom expr) (append (print-atom expr) suffix))
        ('t (append "(" (print-with-suffix (car expr)
                                           (print-tail (cdr expr) suffix))))))
(define (print-with-newline expr) (print-with-suffix expr "\n"))
(define (print expr) (print-with-suffix expr ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities for preventing name collisions ;;
;; in the output of the CPS transformation  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (number->symbol symbol-id)
  (string->symbol (append "s" (print-num symbol-id))))
(define (escape-symbols expr)
  (cond ((symbol? expr) (string->symbol (append "_" (symbol->string expr))))
        ((atom expr) expr)
        ('t (cons (escape-symbols (car expr)) (escape-symbols (cdr expr))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CPS-Transformation functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define scheduler-symbol (number->symbol 0))
(define terminated-symbol (number->symbol 1))
(define expr-continuation-symbol (number->symbol 2))
(define process-continuation-symbol (number->symbol 3))
(define initial-min-symbol-id 4)

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Transform a tail call ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define builtins
  '(cons car cdr atom number function = < > + - * / % ~ & | ^ >> >>> <<))
(define (transform-fn-tail-call params body next-symbol-id
                                continuation scheduler)
  (let ((return-symbol (number->symbol next-symbol-id))
        (next-symbol-id (* 2 next-symbol-id))
        (cps-params (cons scheduler-symbol
                          (cons return-symbol (escape-symbols params)))))
    `(,scheduler ,continuation
                 (fn ,cps-params
                     ,(transform-tail-call body next-symbol-id
                                           return-symbol
                                           scheduler-symbol)))))
(define (transform-application-tail-call op args next-symbol-id
                                         continuation scheduler)
  (let ((val-symbol (number->symbol next-symbol-id))
        (op-next-symbol-id (* 2 (+ next-symbol-id 1)))
        (args-next-symbol-id (+ 1 (* 2 (+ next-symbol-id 1)))))
    (transform op op-next-symbol-id
               (fn (scheduler op-code)
                   (transform-args args '() args-next-symbol-id
                                   (fn (scheduler args-code)
                                       (list op-code
                                             scheduler
                                             continuation
                                             . args-code))
                                   scheduler))
               scheduler)))
(define (transform-if-tail-call test then else next-symbol-id
                                continuation scheduler)
  (let ((test-value-symbol (number->symbol next-symbol-id))
        (test-next-symbol-id (* 2 next-symbol-id))
        (then-next-symbol-id (* 2 (+ 1 (* 2 next-symbol-id))))
        (else-next-symbol-id (+ 1 (* 2 (+ 1 (* 2 next-symbol-id)))))
        (then-code (transform-tail-call then then-next-symbol-id
                                        continuation scheduler-symbol))
        (else-code (transform-tail-call else else-next-symbol-id
                                        continuation scheduler-symbol)))
    (transform test test-next-symbol-id
               (fn (scheduler test-code)
                   `(,scheduler
                     (fn (,scheduler-symbol
                          ,terminated-symbol
                          ,test-value-symbol)
                         (if ,test-value-symbol ,then-code ,else-code))
                     ,test-code))
               scheduler)))
(define (transform-atom-tail-call expr next-symbol-id continuation scheduler)
  (cond ((= expr '()) `(,scheduler ,continuation ,expr))
        ((number expr) `(,scheduler ,continuation ,expr))
        ((not (member expr builtins))
         `(,scheduler ,continuation ,(escape-symbols expr)))
        ('t (let ((return-symbol (number->symbol next-symbol-id))
                  (args-symbol (number->symbol (* next-symbol-id 2))))
              `(,scheduler ,continuation
                           (fn ,(cons scheduler-symbol
                                      (cons return-symbol args-symbol))
                               (,scheduler-symbol ,return-symbol
                                                  ,(cons expr
                                                         args-symbol))))))))
(define (transform-tail-call expr next-symbol-id continuation scheduler)
  (cond ((atom expr)
         (transform-atom-tail-call expr next-symbol-id
                                   continuation scheduler))
        ((= (car expr) 'fn)
         (transform-fn-tail-call (cadr expr) (caddr expr) next-symbol-id
                                 continuation scheduler))
        ((= (car expr) 'if)
         (transform-if-tail-call (cadr expr) (caddr expr) (cadr (cddr expr))
                                 next-symbol-id continuation scheduler))
        ((= (car expr) 'quote) `(,scheduler ,continuation ,expr))
        ('t (transform-application-tail-call (car expr) (cdr expr)
                                             next-symbol-id continuation
                                             scheduler))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Transform a non-tail call ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (transform-fn params body next-symbol-id builder scheduler)
  (let ((return-symbol (number->symbol next-symbol-id))
        (next-symbol-id (* 2 next-symbol-id))
        (cps-params (cons scheduler-symbol
                          (cons return-symbol (escape-symbols params)))))
    (builder scheduler
             `(fn ,cps-params
                  ,(transform-tail-call body next-symbol-id
                                        return-symbol
                                        scheduler-symbol)))))
(define (transform-args args args-code next-symbol-id builder scheduler)
  (cond ((= args '()) (builder scheduler (reverse args-code)))
        ((atom args)
         (let ((arg-symbol (number->symbol next-symbol-id))
               (arg-next-symbol-id (* 2 next-symbol-id)))
           (transform args arg-next-symbol-id
                      (fn (scheduler code)
                          (builder scheduler
                                   (append (reverse args-code) code)))
                      scheduler)))
        ('t (let ((arg-symbol (number->symbol next-symbol-id))
                  (arg-next-symbol-id (* 2 next-symbol-id))
                  (args-next-symbol-id (+ 1 (* 2 next-symbol-id))))
              (transform (car args) arg-next-symbol-id
                         (fn (scheduler arg-code)
                             (transform-args (cdr args)
                                             (cons arg-code args-code)
                                             args-next-symbol-id
                                             builder scheduler))
                         scheduler)))))
(define (transform-application op args next-symbol-id builder scheduler)
  (let ((val-symbol (number->symbol next-symbol-id))
        (op-next-symbol-id (* 2 (+ next-symbol-id 1)))
        (args-next-symbol-id (+ 1 (* 2 (+ next-symbol-id 1)))))
    (transform op op-next-symbol-id
               (fn (scheduler op-code)
                   (transform-args args '() args-next-symbol-id
                                   (fn (scheduler args-code)
                                       (list op-code
                                             scheduler
                                             `(fn (,scheduler-symbol
                                                   ,terminated-symbol
                                                   ,val-symbol)
                                                  ,(builder scheduler-symbol
                                                            val-symbol))
                                             . args-code))
                                   scheduler))
               scheduler)))
(define (transform-if test then else next-symbol-id builder scheduler)
  (let ((test-value-symbol (number->symbol next-symbol-id))
        (test-next-symbol-id (* 2 next-symbol-id))
        (then-next-symbol-id (* 2 (+ 1 (* 2 next-symbol-id))))
        (else-next-symbol-id (+ 1 (* 2 (+ 1 (* 2 next-symbol-id)))))
        (then-code (transform then then-next-symbol-id
                              builder scheduler-symbol))
        (else-code (transform else else-next-symbol-id
                              builder scheduler-symbol)))
    (transform test test-next-symbol-id
               (fn (scheduler test-code)
                   `(,scheduler
                     (fn (,scheduler-symbol
                          ,terminated-symbol
                          ,test-value-symbol)
                         (if ,test-value-symbol ,then-code ,else-code))
                     ,test-code))
               scheduler)))
(define (transform-atom expr next-symbol-id builder scheduler)
  (cond ((= expr '()) (builder scheduler expr))
        ((number expr) (builder scheduler expr))
        ((not (member expr builtins))
         (builder scheduler (escape-symbols expr)))
        ('t (let ((return-symbol (number->symbol next-symbol-id))
                  (args-symbol (number->symbol (* next-symbol-id 2))))
              (builder scheduler
                       `(fn ,(cons scheduler-symbol
                                   (cons return-symbol args-symbol))
                            (,scheduler-symbol ,return-symbol
                                               ,(cons expr args-symbol))))))))
(define (transform expr next-symbol-id builder scheduler)
  (cond ((atom expr) (transform-atom expr next-symbol-id builder scheduler))
        ((= (car expr) 'fn)
         (transform-fn (cadr expr) (caddr expr) next-symbol-id
                       builder scheduler))
        ((= (car expr) 'if)
         (transform-if (cadr expr) (caddr expr) (cadr (cddr expr))
                       next-symbol-id builder scheduler))
        ((= (car expr) 'quote) (builder scheduler expr))
        ('t (transform-application (car expr) (cdr expr) next-symbol-id
                                   builder scheduler))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile expressions to coroutines ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (cps-transformation expr continuation)
  (transform expr initial-min-symbol-id
             (fn (scheduler expr-code) `(,scheduler ,continuation ,expr-code))
             scheduler-symbol))
(define (transform-statement statement)
  (cond ((atom statement)
         (cps-transformation statement process-continuation-symbol))
        ((= (car statement) 'define)
         `(define ,(escape-symbols (cadr statement))
            ,(cps-transformation (caddr statement) expr-continuation-symbol)))
        ('t (cps-transformation statement process-continuation-symbol))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Output code to perform process I/O ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define process-manager-code
  `((define ,expr-continuation-symbol
      (fn (running-scheduler terminated-scheduler expr) expr))
    (define process-continuation
      (fn (running-scheduler terminated-scheduler expr)
          (terminated-scheduler expr)))
    (define ,process-continuation-symbol process-continuation)
    (define initial-process-runner
      (fn (initial-process) (run-process initial-process empty-messenger)))
    (define top-level-scheduler
      (fn (continuation process-value)
          (make-process 0 continuation process-value
                        empty-process-list empty-mailbox
                        initial-process-runner)))
    (define ,scheduler-symbol top-level-scheduler)
    
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; TODO: Replace with a real-time FIFO Queue ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Mailbox:: (M,R)=>((M,Mailbox<M,R>,T->R)->R,T,T->R)->R
    (define empty-mailbox
      (fn (non-empty-handler empty-result return) (return empty-result)))
    (define add-to-mailbox ;; (M,R)=>(M,Mailbox<M,R>,Mailbox<M,R>->R)->R
      (fn (msg inbox return)
          (inbox (fn (first-msg remaining-inbox return)
                     (add-to-mailbox msg remaining-inbox
                                     (fn (updated-remaining)
                                         (return (fn (non-empty empty return)
                                                     (non-empty first-msg
                                                                updated-remaining
                                                                return))))))
                 (fn (non-empty-handler empty-result return)
                     (non-empty-handler msg empty-mailbox return))
                 return)))
    
    ;; Messenger:: (M,R)=>(Id,Mailbox<M,R>,Mailbox<M,R>->R)->R
    (define empty-messenger (fn (id mailbox return) (return mailbox)))
    (define targeted-messenger ; (Id,M,Messenger<M,R>,Messenger<M,R>->R)->R
      (fn (target-id message messenger return)
          (return (fn (id mailbox return)
                      (messenger id mailbox
                                 (fn (mailbox)
                                     ((fn (test)
                                          (if test
                                              (add-to-mailbox message mailbox
                                                              return)
                                            (return mailbox)))
                                      (= target-id id))))))))
    (define blind-messenger ; (M,Messenger<M,R>->R)->R
      (fn (message return)
          (return (fn (id mailbox return)
                      (add-to-mailbox message mailbox return)))))
    
    ;; ProcessList:: (M,R)=>(Messenger<M,R>,Mailbox<M,R>,ProcessListReturn<M,R>)->R
    ;; ProcessListReturn:: (M,R)=>(ProcessList<M,R>,Mailbox<M,R>)->R
    ;; Process:: (M,R)=>(Messenger<M,R>,RunningHandler<M,R>,EventHandler<M,R>)->R
    ;; ProcessEvent:: (M,R)=>(Mailbox<M,R>,RunningReturn<M,R>,TerminatedReturn<M,R>)->R
    ;; RunningHandler:: (M,R)=>(Process<M,R>)->R
    ;; EventHandler:: (M,R)=>(ProcessEvent<M,R>)->R
    (define empty-process-list ; ProcessList<M,R>
      (fn (messenger parent-mailbox return)
          (return empty-process-list parent-mailbox)))
    (define add-process ; (Process<M,R>,ProcessList<M,R>,ProcessList<M,R>->R)->R
      (fn (process siblings return)
          (return (fn (messenger parent-mailbox return)
                      (siblings
                       messenger parent-mailbox
                       (fn (updated-siblings updated-parent-mailbox)
                           (make-handlers updated-siblings
                                          updated-parent-mailbox
                                          (fn (updated-process updated-parent-mailbox)
                                              (add-process updated-process
                                                           updated-siblings
                                                           (fn (updated-processes)
                                                               (return updated-processes
                                                                       updated-parent-mailbox))))
                                          (fn (updated-parent-mailbox)
                                              (return updated-siblings
                                                      updated-parent-mailbox))
                                          (fn (running-handler event-handler)
                                              (process messenger
                                                       running-handler
                                                       event-handler)))))))))
    
    ;; RunningReturn:: (M,R)=>(Process<M,R>,Mailbox<M,R>)->R
    ;; TerminatedReturn:: (M,R)=>Mailbox<M,R>->R
    ;; (M,R)=>(ProcessList<M,R>,Mailbox<M,R>,RunningReturn<M,R>,TerminatedReturn<M,R>,(RunningHandler<M,R>,EventHandler<M,R>)->R)->R
    (define make-handlers
      (fn (siblings parent-mailbox running-return terminated-return return)
          (return (fn (updated-process)
                      (running-return updated-process parent-mailbox))
                  (fn (process-event)
                      (process-event empty-messenger parent-mailbox
                                     running-return terminated-return)))))
    
    ;; ProcessContinuation:: (R,V)=>(RunningScheduler<R,V>,TerminatedScheduler<R,V>,V)->R
    ;; RunningScheduler:: (R,V)=>(ProcessContinuation<R,V>,V)->R
    ;; TerminatedScheduler:: (R,V)=>V->R
    ;; (M,R,V)=>(Id,ProcessContinuation<R,V>,V,ProcessList<M,R>,Mailbox<M>,Process<M,R>->R)->R
    (define make-process
      (fn (id continuation value children mailbox return)
          (return (fn (messenger running-handler event-handler)
                      (messenger id mailbox
                                 (fn (updated-mailbox)
                                     (make-schedulers id updated-mailbox children
                                                      running-handler
                                                      event-handler
                                                      (fn (running-scheduler
                                                           terminated-scheduler)
                                                          (continuation
                                                           running-scheduler
                                                           terminated-scheduler
                                                           value)))))))))
    
    ;; (M,R,V)=>(Id,Mailbox<M>,ProcessList<M,R>,RunningHandler<M,R>,EventHandler<M,R>,(RunningScheduler<R,V>,TerminatedScheduler<R,V>)->R)->R
    (define make-schedulers
      (fn (id mailbox children running-handler event-handler return)
          (return (fn (continuation value)
                      (children empty-messenger mailbox
                                (fn (updated-children updated-mailbox)
                                    (make-process id continuation value
                                                  updated-children updated-mailbox
                                                  (fn (updated-process)
                                                      (running-handler
                                                       updated-process))))))
                  (fn (value)
                      (event-handler (fn (messenger parent-mailbox
                                                    running-return
                                                    terminated-return)
                                         (messenger id mailbox
                                                    (fn (mailbox)
                                                        (process-io id value
                                                                    mailbox
                                                                    children
                                                                    empty-messenger
                                                                    parent-mailbox
                                                                    running-return
                                                                    terminated-return)))))))))
    
    (define flush-mailbox
      (fn (mailbox end return)
          (mailbox (fn (first-message remaining-mailbox return)
                       (flush-mailbox remaining-mailbox end
                                      (fn (result)
                                          (return (cons first-message
                                                        result)))))
                   end
                   return)))
    (define id-function (fn (result) result))
    (define write-messages
      (fn (outbox continuation) (flush-mailbox outbox continuation id-function)))
    
    ;; (M,R)=>RunningReturn<M,R>
    (define top-level-running-return
      (fn (process parent-mailbox)
          (write-messages parent-mailbox
                          (run-process process empty-messenger))))
    ;; (M,R)=>TerminatedReturn<M,R>
    (define top-level-terminated-return
      (fn (parent-mailbox) (write-messages parent-mailbox '())))
    ;; (M,R)=>EventHandler<M,R>
    (define top-level-event-handler
      (fn (process-event)
          (fn in (if in
                     (blind-messenger in
                                      (fn (messenger)
                                          (process-event messenger empty-mailbox
                                                         top-level-running-return
                                                         top-level-terminated-return)))
                   (process-event empty-messenger empty-mailbox
                                  top-level-running-return
                                  top-level-terminated-return)))))
    ;; (M,R)=>RunningHandler<M,R>
    (define top-level-running-handler
      (fn (process) (run-process process empty-messenger)))
    (define run-process
      (fn (process messenger)
          (process messenger
                   top-level-running-handler
                   top-level-event-handler)))
    
    ;; (M,R)=>(Id,R,Mailbox<M,R>,ProcessList<M,R>,Messenger<M,R>,Mailbox<M,R>,RunningReturn<M,R>,TerminatedReturn<M,R>)->R
    (define process-io
      (fn (id process-result mailbox children children-messenger parent-mailbox
              running-return terminated-return)
          ((fn (is-atom)
               (if is-atom
                   ((fn (is-function)
                        (if is-function
                            (process-input id process-result mailbox
                                           children children-messenger
                                           parent-mailbox running-return)
                          (terminated-return parent-mailbox)))
                    (function process-result))
                 (send-message id process-result mailbox children
                               children-messenger parent-mailbox
                               running-return terminated-return)))
           (atom process-result))))
    ;; (M,R)=>(Id,R,Mailbox<M,R>,ProcessList<M,R>,Mailbox<M,R>,RunningReturn<M,R>)->R
    (define process-input
      (fn (id handler mailbox children messenger parent-mailbox running-return)
          (children messenger mailbox
                    (fn (updated-children updated-mailbox)
                        (read-message id handler updated-mailbox updated-children
                                      (fn (return)
                                          (return (fn (updated-process)
                                                      (running-return
                                                       updated-process
                                                       parent-mailbox)))))))))
    (define read-message
      (fn (id handler mailbox children return)
          (mailbox (fn (message remaining-inbox return)
                       (handler (fn (cont value)
                                    (return (fn (process-return)
                                                (make-process id cont value
                                                              children
                                                              remaining-inbox
                                                              process-return))))
                                process-continuation
                                .
                                message))
                   (fn (process-return)
                       (make-process id process-continuation handler children
                                     empty-mailbox process-return))
                   return)))
    ;; (M,R)=>(Id,R,Mailbox<M,R>,ProcessList<M,R>,Messenger<M,R>,Mailbox<M,R>,RunningReturn<M,R>)->R
    (define send-message
      (fn (id result mailbox children children-messenger parent-mailbox
              running-return terminated-return)
          ((fn (continuation)
               ((fn (message)
                    (process-message message children
                                     children-messenger parent-mailbox
                                     (fn (children messenger parent-mailbox)
                                         (process-io id continuation mailbox
                                                     children messenger
                                                     parent-mailbox
                                                     running-return
                                                     terminated-return))))
                (car result)))
           (cdr result))))
    (define process-message
      (fn (message children messenger parent-mailbox return)
          ((fn (is-atom)
               (if is-atom
                   (add-to-mailbox (cons message '()) parent-mailbox
                                   (fn (parent-mailbox)
                                       (return children messenger parent-mailbox)))
                 (process-pair-message message children messenger
                                       parent-mailbox return)))
           (atom message))))
    (define process-pair-message
      (fn (message children messenger parent-mailbox return)
          ((fn (is-atom)
               (if is-atom
                   (add-to-mailbox message parent-mailbox
                                   (fn (parent-mailbox)
                                       (return children messenger parent-mailbox)))
                 (process-child-message (car message) (cdr message)
                                        children messenger
                                        (fn (children messenger)
                                            (return children
                                                    messenger
                                                    parent-mailbox)))))
           (atom (cdr message)))))
    (define process-child-message
      (fn (child-id message children messenger return)
          (if (atom (cdr message))
              (targeted-messenger child-id message messenger 
                                  (fn (messenger) (return children messenger)))
              (fork-child child-id (car message) (car (cdr message)) children
                          (fn (children) (return children messenger))))))
    (define fork-child
      (fn (child-id child-mem child-body children return)
          (add-to-mailbox child-mem empty-mailbox
                          (fn (child-mailbox)
                              (make-process child-id process-continuation
                                            child-body empty-process-list
                                            child-mailbox
                                            (fn (child-process)
                                                (add-process child-process
                                                             children
                                                             return)))))))
    ))

;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the input ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (compile-source start-line-number)
  (fn (value end-line-number)
      (cond ((not value)
             (print-error "No main expression"))
            ((not (= (car value) 'define))
             (print-with-suffix (transform-statement value) "\n"))
            ((not (or (atom (cadr value)) (atom (caadr value))))
             (print-error "Malformed define statement"))
            ('t (print-with-suffix (transform-statement value)
                                   (read-expr (compile-source end-line-number)
                                              end-line-number))))))
(fn (size arguments)
    ((foldr (fn (statement suffix)
                (print-with-suffix statement (append "\n" suffix)))
            (read-expr (compile-source 1) 1))
     process-manager-code))
