;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Losak compiler                                                  ;;
;;                                                                 ;;
;; This stage of the compiler performs lambda-lifting to reduce    ;;
;; the size of the binding environments for closures.              ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Copyright (C) 2004 - 2011 by Omar Jarjur                        ;;
;;                                                                 ;;
;; This program is free software; you can redistribute it and/or   ;;
;; modify it under the terms of version 2 of the GNU General       ;;
;; Public License as published by the Free Software Foundation.    ;;
;;                                                                 ;;
;; This program is distributed in the hope that it will be useful, ;;
;; but WITHOUT ANY WARRANTY; without even the implied warranty of  ;;
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ;;
;; GNU General Public License for more details.                    ;;
;;                                                                 ;;
;; You should have received a copy of the GNU General Public       ;;
;; License along with this program; if not, write to the Free      ;;
;; Software Foundation, Inc.,                                      ;;
;; 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (caar x) (car (car x)))
(define (cdar x) (cdr (car x)))
(define (cadr x) (car (cdr x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))

(define (id x) x)
(define (list . args) args)
(define (apply op args) (op . args))
(define (recurse op)
  ((fn (this) (op (fn args ((this this) . args))))
   (fn (this) (op (fn args ((this this) . args))))))
(define (walk head tail test merge ret)
  (fn (tree)
      (cond ((test tree) (ret tree))
            ('t (merge (head tree)
                       ((walk head tail test merge ret)
                        (tail tree)))))))
(define (rreverse list result return)
  (cond ((atom list) (return result))
        ('t (rreverse (cdr list) (cons (car list) result) return))))
(define (reverse list) (rreverse list '() id))
(define (foldl merge end)
  (fn (list)
      (cond ((atom list) end)
            ('t ((foldl merge (merge (car list) end)) (cdr list))))))
(define (foldr merge end)
  (fn (list) (rreverse list '() (foldl merge end))))
(define (append . args) ((foldr (fn (x xs)
                                    (cond ((= xs '()) x)
                                          ('t ((foldr cons xs) x))))
                                '()) args))
(define (equal x y)
  (cond ((atom x) (= x y))
        ((atom y) '())
        ((equal (car x) (car y)) (equal (cdr x) (cdr y)))
        ('t '())))
(define (map op list) ((foldr (fn (x xs) (cons (op x) xs)) '()) list))
(define (or . args) ((foldr (fn (t ts) (cond (t t) ('t ts))) '()) args))
(define (and . args) ((foldr (fn (t ts) (cond (t ts) ('t '()))) 't) args))
(define (not test) (cond (test '()) ('t 't)))
(define (member item list)
  (cond ((atom list) '())
        ((equal item (car list)) list)
        ('t (member item (cdr list)))))

;;;;;;;;;;;;;;;;;;;;
;; Error handling ;;
;;;;;;;;;;;;;;;;;;;;
(define map-to-stderr
  (foldr (fn (char output) (cons (list (cons 2 char)) output)) ()))
(define (print-warnings line-number warnings)
  (cond (warnings (map-to-stderr (append "WARNING; "
                                         "In expression beginning on line "
                                         (print line-number) ": " warnings
                                         "\n")))
        ('t ())))
(define (print-error msg) (map-to-stderr (append "Error; "msg "\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper functions for parsing ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (escape-char char)
  (cond ((= char 116) 9)
        ((= char 114) 13)
        ((= char 110) 10)
        ('t char)))
(define (build-num chars)
  ((foldl (fn (c n) (+ (* 10 n) (- c 48))) 0) chars))
(define (quote-value expr) (list 'quote expr))
(define (quasiquote-value expr) (list 'quasiquote expr))
(define (unquote-value expr) (list 'unquote expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Parser combinators that simplify the process of writting an LL(1) ;;
;; grammar.                                                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Each parser takes a return continuation, an error continuation,   ;;
;; and a current line number. They implement a function that takes   ;;
;; input one character at a time (in curried form), parses the input ;;
;; string, and passes the tree and updated line number to the        ;;
;; return, or "fails" and passes a message to the error.             ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (fail return error line-num) (error line-num))
(define (done return error line-num) (return () line-num))
(define (pop return error line-num)
  (fn (char)
      (cond ((= char '()) (pop return error line-num))
            ((not (number char)) (error line-num))
            ((= char 10) (return char (+ 1 line-num)))
            ('t (return char line-num)))))
(define (check test)
  (fn (return error line-num)
      (pop (fn (val line-num)
               (cond ((test val) (return val line-num))
                     ('t ((error line-num) val))))
           error line-num)))
(define (match char) (check (fn (val) (= val char))))
(define (default parser) (fn (else) parser))
(define (case test then)
  (fn (else)
      (fn (return error line-num)
          (test (fn (val line-num)
                    (then return error line-num))
                (fn (symbols) (else return error line-num))
                line-num))))
(define (choice . args) ((foldr (fn (c cs) (c cs)) fail) args))
(define (post-process parser op)
  (fn (return error line-num)
      (parser (fn (val line-num) (return (op val) line-num))
              error line-num)))
(define (seq parser1 parser2)
  (fn (return error line-num)
      (parser1 (fn (head line-num)
                   (parser2 (fn (tail line-num)
                                (return (cons head tail) line-num))
                            error line-num))
               error line-num)))
(define (escape parser) (seq (post-process pop escape-char) parser))
(define (use parser) (seq pop parser))
(define (peek parser)
  (fn (return error line-num)
      (parser (fn (val new-line-num)
                  ((return val line-num) val))
              error line-num)))
(define (interval start end)
  (check (fn (val) (and (> val (- start 1)) (< val (+ end 1))))))
(define (skip parser) (post-process (use parser) cdr))
(define (first parser1 parser2) (post-process (seq parser1 parser2) car))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to parse an s-expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (parse-num . args)
  (apply (choice (case (peek (interval 48 57)) (use parse-num))
                 (default done))
         args))
(define (read-num . args) (apply (post-process parse-num build-num) args))
(define (parse-symbol . args)
  (apply (choice (case (interval 0 32) done)
                 (case (peek (interval 39 41)) done)
                 (case (peek (match 46)) done)
                 (case (peek (match 59)) done)
                 (default (use parse-symbol)))
         args))
(define (read-symbol . args)
  (apply (post-process parse-symbol string->symbol) args))
(define (parse-string . args)
  (apply (choice (case (match 34) done)
                 (case (match 92) (escape parse-string))
                 (default (use parse-string)))
         args))
(define (quote-parser parser) (post-process parser quote-value))
(define (quasiquote-parser parser) (post-process parser quasiquote-value))
(define (unquote-parser parser) (post-process parser unquote-value))
(define (comment parser)
  (fn args (apply (choice (case (match 10) parser)
                          (case (match 13) parser)
                          (default (skip (comment parser))))
                  args)))
(define (parse-paren . args)
  (apply (choice (case (interval 1 32) parse-paren)
                 (case (match 59) (comment parse-paren))
                 (case (match 41) done))
         args))
(define (parse-pair . args)
  (apply (choice (case (interval 1 32) parse-pair)
                 (case (match 59) (comment parse-pair))
                 (case (match 41) done)
                 (case (match 46) (first parse-expr parse-paren))
                 (default (seq parse-expr parse-pair)))
         args))
(define (parse-expr . args)
  (apply (choice (case (interval 1 32) parse-expr)
                 (case (match 34) (quote-parser parse-string))
                 (case (match 39) (quote-parser parse-expr))
                 (case (match 96) (quasiquote-parser parse-expr))
                 (case (match 44) (unquote-parser parse-expr))
                 (case (match 40) parse-pair)
                 (case (match 41) fail)
                 (case (match 46) fail)
                 (case (match 59) (comment parse-expr))
                 (case (peek (interval 48 57)) read-num)
                 (default read-symbol))
         args))
(define (read-expr cont line-number)
  (parse-expr cont (fn (end-line)
                       (print-error (append "Parse error, line "
                                            (print-num line-number)
                                            " -> line "
                                            (print-num end-line)
                                            "\n")))
              line-number))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to print s-expressions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (build-num-str num)
  ((walk (fn (n) (% n 10))
         (fn (n) (/ n 10))
         (fn (n) (= n 0))
         (fn (d op) (fn (str) (op (cons (+ d 48) str))))
         (fn (x) id))
   num))
(define (print-num num)
  (cond ((< num 0) (cons 45 ((build-num-str (- num)) "")))
        ((= num 0) "0")
        ('t ((build-num-str num) ""))))
(define (print-atom expr)
  (cond ((number expr) (print-num expr))
        ((symbol? expr) (symbol->string expr))
        ('t "<INTERNAL ERROR>")))
(define (print-tail expr suffix)
  (cond ((= expr '()) (append ")" suffix))
        ((atom expr) (append " . " (print-atom expr) ")" suffix))
        ('t (append " " (print-with-suffix (car expr)
                                           (print-tail (cdr expr) suffix))))))
(define (print-with-suffix expr suffix)
  (cond ((= expr '()) (append "()" suffix))
        ((atom expr) (append (print-atom expr) suffix))
        ('t (append "(" (print-with-suffix (car expr)
                                           (print-tail (cdr expr) suffix))))))
(define (print-with-newline expr) (print-with-suffix expr "\n"))
(define (print expr) (print-with-suffix expr ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Utilities for preventing name collisions ;;
;; in the output of the CPS transformation  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (number->symbol symbol-id)
  (string->symbol (append "s" (print-num symbol-id))))
(define builtins
  '(cons car cdr atom number function = < > + - * / % ~ & | ^ >> >>> <<))
(define (escape-symbols expr)
  (cond ((member expr builtins) expr)
        ((symbol? expr) (string->symbol (append "_" (symbol->string expr))))
        ((atom expr) expr)
        ('t (cons (escape-symbols (car expr)) (escape-symbols (cdr expr))))))

;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the input ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (flatten tree return-list)
  (cond ((= tree '()) return-list)
        ((atom tree) (cons tree return-list))
        ('t (flatten (car tree) (flatten (cdr tree) return-list)))))
(define (merge list1 list2)
  ((foldr (fn (item list)
              (if (member item list)
                  list
                  (cons item list)))
          list2)
   list1))
(define (subtract-list source excludes)
  ((foldr (fn (item list)
              (if (member item excludes)
                  list
                  (cons item list)))
          '())
   source))
(define (definition-return name return)
  (fn (body referenced-params definitions next-definition-number)
      (return `(define ,(escape-symbols name) ,body)
               referenced-params
               definitions
               next-definition-number)))
(define (fn-return params return)
  (fn (body referenced-params definitions next-definition-number)
      (let ((definition-name (append "fn_" (print-num next-definition-number)))
            (label (string->symbol definition-name))
            (bound-params (flatten params '()))
            (free-variables (subtract-list referenced-params bound-params)))
        (return (cons label (escape-symbols free-variables))
                free-variables
                (cons `(define ,label
                         (fn ,(escape-symbols free-variables)
                             (fn ,(escape-symbols params) ,body)))
                       definitions)
                (+ 1 next-definition-number)))))
(define (fn-defintions params body bound-params next-definition-number return)
  (let ((nested-bound-params (flatten params bound-params)))
    (extract-definitions body nested-bound-params next-definition-number
                         (fn-return params return))))
(define (args-definitions args bound-params next-definition-number return)
  (if (atom args)
      (extract-definitions args bound-params next-definition-number return)
      (let (((head head-params head-definitions next-definition-number)
             (extract-definitions (car args)
                                  bound-params
                                  next-definition-number
                                  list))
            ((tail tail-params tail-definitions next-definition-number)
             (args-definitions (cdr args)
                               bound-params
                               next-definition-number
                               list)))
        (return (cons head tail)
                (merge head-params tail-params)
                (append head-definitions tail-definitions)
                next-definition-number))))
(define (extract-definitions expr local-vars next-definition-number return)
  (cond ((symbol? expr)
         (return (escape-symbols expr)
                 (if (member expr local-vars) (list expr) '())
                 '()
                 next-definition-number))
        ((atom expr) (return expr '() '() next-definition-number))
        ((= (car expr) 'quote)
         (return expr '() '() next-definition-number))
        ((= (car expr) 'define)
         (extract-definitions (caddr expr)
                              local-vars
                              next-definition-number
                              (definition-return (cadr expr) return)))
        ((= (car expr) 'fn)
         (fn-defintions (cadr expr) (caddr expr)
                        local-vars next-definition-number return))
        ((= (car expr) 'if)
         (let (((test test-free-vars test-definitions next-definition-number)
                (extract-definitions (cadr expr) local-vars
                                     next-definition-number list))
               ((then then-free-vars then-definitions next-definition-number)
                (extract-definitions (caddr expr) local-vars
                                     next-definition-number list))
               ((else else-free-vars else-definitions next-definition-number)
                (extract-definitions (cadr (cddr expr)) local-vars
                                     next-definition-number list)))
           (return `(if ,test ,then ,else)
                    (merge test-free-vars (merge then-free-vars else-free-vars))
                    (append test-definitions then-definitions else-definitions)
                    next-definition-number)))
        ('t (args-definitions expr
                              local-vars
                              next-definition-number
                              return))))
(define (statement-return return)
  (fn (expr free-vars definitions next-definition-number)
      ((foldr (fn (def suffix) (print-with-suffix def (append "\n" suffix)))
              (print-with-suffix expr
                                 (append "\n" (return next-definition-number))))
       definitions)))
(define (compile expr next-definition-number return)
  (extract-definitions expr
                       '()
                        next-definition-number
                       (statement-return return)))
(define (compile-source start-line-number next-definition-number)
  (fn (value end-line-number)
      (cond ((not value)
             (print-error "No main expression"))
            ((not (= (car value) 'define))
             (compile value next-definition-number
                      (fn (next-definition-number) "\n")))
            ((not (or (atom (cadr value)) (atom (caadr value))))
             (print-error "Malformed define statement"))
            ('t (compile value next-definition-number
                         (fn (next-definition-number)
                             (read-expr (compile-source end-line-number
                                                        next-definition-number)
                                        end-line-number)))))))
(fn (size arguments) (read-expr (compile-source 1 0) 1))
