;;;;;;;;;;;;;;;;;;;;;;;
;; Utility functions ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (list . x) x)
(define (apply op args) (op . args))
(define (equal x y)
        (cond ((atom x) (= x y))
              ((atom y) '())
              ((equal (car x) (car y)) (equal (cdr x) (cdr y)))
              ('t '())))
(define (rreverse list result return)
  (cond ((atom list) (return result))
        ('t (rreverse (cdr list) (cons (car list) result) return))))
(define (reverse list) (rreverse list '() (fn (x) x)))
(define (foldl merge end)
  (fn (list)
      (cond ((atom list) end)
            ('t ((foldl merge (merge (car list) end)) (cdr list))))))
(define (foldr merge end)
  (fn (list) (rreverse list '() (foldl merge end))))
(define (append . args) ((foldr (fn (x xs)
                                    (cond ((= xs '()) x)
                                          ('t ((foldr cons xs) x))))
                               '()) args))
(define (and . args) ((foldr (fn (t ts) (cond (t ts) ('t '()))) 't) args))
(define trim-trailing-whitespace
  (foldr (fn (x xs) (cond ((and (atom xs) (< x 33)) "") ('t (cons x xs)))) ""))
(define (trim-whitespace line)
  (cond ((< (car line) 33) (trim-whitespace (cdr line)))
  	('t (trim-trailing-whitespace line))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for inter-process I/O ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (fork id space child continuation)
  (cons (list id space child) continuation))
(define (send-to-parent msg continuation)
  (cons (list msg) continuation))
(define (send-to-child child-id msg continuation)
  (cons (list child-id msg) continuation))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for processing symbols ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (string->symbol chars)
   (cond ((equal chars "fn") 'fn)
         ((equal chars "if") 'if)
         ((equal chars "quote") 'quote)
         ('t (fn (op) (op 't chars)))))
(define (make-symbol return)
   (fn (chars rest) (return (string->symbol chars) rest)))
(define (symbol->string symbol) (symbol (fn (is-symbol chars) chars)))
(define (symbol-equal symbol1 symbol2)
   (equal (symbol->string symbol1) (symbol->string symbol2)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions defining the parser ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (parse-symbol source return)
   (cond ((= source ()) (return () source))
         ((< (car source) 33) (return () source))
         ((= (car source) 39) (return () source))
         ((= (car source) 40) (return () source))
         ((= (car source) 41) (return () source))
         ('t (parse-symbol (cdr source)
                           (fn (chars rest)
                               (return (cons (car source) chars) rest))))))
(define (parse-number val source return)
   (cond ((and (> (car source) 47) (< (car source) 58))
          (parse-number (+ (* val 10) (- (car source) 48))
                        (cdr source) return))
         ('t (return val source))))
(define (parse-atom source return)
   (cond ((< (car source) 48) (parse-symbol source (make-symbol return)))
         ((> (car source) 57) (parse-symbol source (make-symbol return)))
         ('t (parse-number 0 source return))))
(define (parse-tail hd rest return)
  (parse-list rest (fn (tl rest) (cond ((= tl 'error) (return tl rest))
                                       ('t (return (cons hd tl) rest))))))
(define (parse-list source return)
   (cond ((= source ()) (return 'error source))
         ((< (car source) 33) (parse-list (cdr source) return))
         ((= (car source) 41) ;; close paren
          (return '() (cdr source)))
         ('t (parse source (fn (hd rest)
                               (cond ((= hd 'error) (return hd rest))
                                     ('t (parse-tail hd rest return))))))))
(define (parse source return)
   (cond ((= source ()) (return 'error source))
         ((< (car source) 33) ;; whitespace
          (parse (cdr source) return))
         ((= (car source) 40) ;; open paren
          (parse-list (cdr source) return))
         ((= (car source) 41) ;; close paren
          (return 'error source))
         ('t (parse-atom source return))))
(define (read source)
  (parse source (fn (expr rest) (cond (rest 'error) ('t expr)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions defining the evaluator ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (find val env)
  (cond ((atom env) ())
        ((symbol-equal val (car (car env))) (cdr (car env)))
        ('t (find val (cdr env)))))
(define (closure param body env)
  (fn (op) (op () (fn (arg) (eval body (cons (cons param arg) env))))))
(define (apply-op op arg)
  (op (fn (is-symbol body) (cond (is-symbol ()) ('t (body arg))))))
(define (eval-list op list env)
  (cond ((atom list) op)
        ('t (eval-list (apply-op op (eval (car list) env)) (cdr list) env))))
(define (eval expr env)
  (cond ((number expr) expr)
        ((atom expr) (find expr env))
        ((= (car expr) 'quote) (car (cdr expr)))
        ((= (car expr) 'fn)
         (closure (car (cdr expr)) (car (cdr (cdr expr))) env))
        ((= (car expr) 'if)
         (cond ((eval (car (cdr expr)) env)
                (eval (car (cdr (cdr expr))) env))
               ('t (eval (car (cdr (cdr (cdr expr)))) env))))
        ('t (eval-list (eval (car expr) env) (cdr expr) env))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions defining the printer ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (rec-print-number num str)
  (cond ((= num 0) str)
        ('t (rec-print-number (/ num 10) (cons (+ 48 (% num 10)) str)))))
(define (print-number expr)
  (cond ((= expr 0) "0")
  	((< expr 0) (append "-" (rec-print-number (- expr) "")))
  	('t (rec-print-number expr ""))))
(define (print-list list)
  (cond (list (append (print (car list)) (print-list (cdr list))))
        ('t ")")))
(define (print expr)
  (cond ((function expr)
         (expr (fn (is-symbol val)
                   (cond (is-symbol val) ('t "<FUNCTION>")))))
        ((number expr) (print-number expr))
        ('t (cons 40 (print-list expr)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for the forked child processes ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (repl source) (print (eval (read source) ())))
(define (repl-task id reversed-source)
  (fn (space)
      (let ((output (repl (reverse reversed-source))))
      	 (send-to-parent (append (print id) ": " output "\n") ()))))

;;;;;;;;;;;;;;;;;;;;;;
;; The main process ;;
;;;;;;;;;;;;;;;;;;;;;;
(define (prompt id space results)
  (output (apply append (reverse (cons "> " (cons (print id) results))))
  	  (forward id space "" '())))
(define (output line return)
  (cond ((atom line) return)
        ('t (send-to-parent (car line) (output (cdr line) return)))))
(define process-space 100)
(define (forward id space line results)
  (fn (input)
      (cond ((< space process-space) "Out of memory!\n")
      	    ((= input 10)
	     (cond ((atom (trim-whitespace line))
	     	    (prompt id space results))
		   ('t (fork id process-space (repl-task id line)
	     	             (prompt (+ id 1)
			     	     (- space process-space)
				     results)))))
      	    ((= input 0) '())
      	    ((atom input) (forward id space (cons input line) results))
	    ('t (forward id (+ space process-space) line (cons input results))))))

;; The main loop
(define (main space args) (prompt 0 space '()))
main
