;;;;;;;;;;;;;;;;;;;;;;;
;; Utility functions ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (list . x) x)
(define (apply op args) (op . args))
(define (equal x y)
        (cond ((atom x) (= x y))
              ((atom y) '())
              ((equal (car x) (car y)) (equal (cdr x) (cdr y)))
              ('t '())))
(define (rreverse list result return)
  (cond ((atom list) (return result))
        ('t (rreverse (cdr list) (cons (car list) result) return))))
(define (reverse list) (rreverse list '() (fn (x) x)))
(define (foldl merge end)
  (fn (list)
      (cond ((atom list) end)
            ('t ((foldl merge (merge (car list) end)) (cdr list))))))
(define (foldr merge end)
  (fn (list) (rreverse list '() (foldl merge end))))
(define (append . args) ((foldr (fn (x xs)
                                    (cond ((= xs '()) x)
                                          ('t ((foldr cons xs) x))))
                               '()) args))
(define (and . args) ((foldr (fn (t ts) (cond (t ts) ('t '()))) 't) args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for processing symbols ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (string->symbol chars)
   (cond ((equal chars "fn") 'fn)
         ((equal chars "if") 'if)
         ('t (fn (op) (op 't chars)))))
(define (make-symbol return)
   (fn (chars rest) (return (string->symbol chars) rest)))
(define (symbol->string symbol) (symbol (fn (is-symbol chars) chars)))
(define (symbol-equal symbol1 symbol2)
   (equal (symbol->string symbol1) (symbol->string symbol2)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions defining the parser ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (parse-symbol source return)
   (cond ((= source ()) (return () source))
         ((< (car source) 33) (return () source))
         ((= (car source) 39) (return () source))
         ((= (car source) 40) (return () source))
         ((= (car source) 41) (return () source))
         ('t (parse-symbol (cdr source)
                           (fn (chars rest)
                               (return (cons (car source) chars) rest))))))
(define (parse-number val source return)
   (cond ((and (> (car source) 47) (< (car source) 58))
          (parse-number (+ (* val 10) (- (car source) 48))
                        (cdr source) return))
         ('t (return val source))))
(define (parse-atom source return)
   (cond ((< (car source) 48) (parse-symbol source (make-symbol return)))
         ((> (car source) 57) (parse-symbol source (make-symbol return)))
         ('t (parse-number 0 source return))))
(define (parse-tail hd rest return)
  (parse-list rest (fn (tl rest) (cond ((= tl 'error) (return tl rest))
                                       ('t (return (cons hd tl) rest))))))
(define (parse-list source return)
   (cond ((= source ()) (return 'error source))
         ((< (car source) 33) (parse-list (cdr source) return))
         ((= (car source) 41) ;; close paren
          (return '() (cdr source)))
         ('t (parse source (fn (hd rest)
                               (cond ((= hd 'error) (return hd rest))
                                     ('t (parse-tail hd rest return))))))))
(define (parse source return)
   (cond ((= source ()) (return 'error source))
         ((< (car source) 33) ;; whitespace
          (parse (cdr source) return))
         ((= (car source) 40) ;; open paren
          (parse-list (cdr source) return))
         ((= (car source) 41) ;; close paren
          (return 'error source))
         ('t (parse-atom source return))))
(define (read source)
  (parse source (fn (expr rest) (cond (rest 'error) ('t expr)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions defining the evaluator ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (find val env)
  (cond ((atom env) ())
        ((symbol-equal val (car (car env))) (cdr (car env)))
        ('t (find val (cdr env)))))
(define (closure param body env)
  (fn (op) (op () (fn (arg) (eval body (cons (cons param arg) env))))))
(define (apply-op op arg)
  (op (fn (is-symbol body) (cond (is-symbol ()) ('t (body arg))))))
(define (eval-list op list env)
  (cond ((atom list) op)
        ('t (eval-list (apply-op op (eval (car list) env)) (cdr list) env))))
(define (eval expr env)
  (cond ((atom expr) (find expr env))
        ((= (car expr) 'fn)
         (closure (car (cdr expr)) (car (cdr (cdr expr))) env))
        ((= (car expr) 'if)
         (cond ((eval (car (cdr expr)) env)
                (eval (car (cdr (cdr expr))) env))
               ('t (eval (car (cdr (cdr (cdr expr)))) env))))
        ('t (eval-list (eval (car expr) env) (cdr expr) env))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions defining the printer ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (rec-print-number num str)
  (cond ((= num 0) str)
        ('t (rec-print-number (/ num 10) (cons (+ 48 (% num 10)) str)))))
(define (print-number expr)
  (cond ((= expr 0) "0")
  	((< expr 0) (append "-" (rec-print-number (- expr) "")))
  	('t rec-print-number expr "")))
(define (print-list list)
  (cond (list (append (print (car list)) (print-list (cdr list))))
        ('t ")")))
(define (print expr)
  (cond ((function expr)
         (expr (fn (is-symbol val)
                   (cond (is-symbol val) ('t "<FUNCTION>")))))
        ((number expr) (print-number expr))
        ('t (cons 40 (print-list expr)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for the forked child processes ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (send-parent-msg msg next) (cons (list msg) next))
(define (print-task id source)
  (fn (space) (send-parent-msg (append (print id)
                                       ": "
                                       (print (eval (read source) ()))
                                       "\n")
                               ())))

;;;;;;;;;;;;;;;;;;;;;;
;; The main process ;;
;;;;;;;;;;;;;;;;;;;;;;
(define (fork id space child continuation)
  (cons (list id space child) continuation))
(define (prompt output id space)
  (append output (print id) "> " (main-loop space id "" ())))
(define (main-loop space id line output)
  (fn (in) (cond ((space < 100) "Out of memory!\n")
                 ((= in 10)
                  (fork id 100 (print-task id line)
                        (prompt (apply append (reverse output))
                                (+ id 1) (- space 100))))
                 ((atom in) (main-loop space id (cons in line) output))
                 ('t (main-loop (+ 100 space) id line (cons in output))))))
(define (entry space args) (prompt "" 0 space))
entry
