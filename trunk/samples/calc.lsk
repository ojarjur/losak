;;;;;;;;;;;;;;;;;;;;;;;
;; Utility functions ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (list . x) x)
(define (apply op args) (op . args))
(define (equal x y)
        (cond ((atom x) (= x y))
              ((atom y) '())
              ((equal (car x) (car y)) (equal (cdr x) (cdr y)))
              ('t '())))
(define (rreverse list result return)
  (cond ((atom list) (return result))
        ('t (rreverse (cdr list) (cons (car list) result) return))))
(define (reverse list) (rreverse list '() (fn (x) x)))
(define (foldl merge end)
  (fn (list)
      (cond ((atom list) end)
            ('t ((foldl merge (merge (car list) end)) (cdr list))))))
(define (foldr merge end)
  (fn (list) (rreverse list '() (foldl merge end))))
(define (append . args) ((foldr (fn (x xs)
                                    (cond ((= xs '()) x)
                                          ('t ((foldr cons xs) x))))
                               '()) args))
(define (and . args) ((foldr (fn (t ts) (cond (t ts) ('t '()))) 't) args))
(define trim-trailing-whitespace
  (foldr (fn (x xs) (cond ((and (atom xs) (< x 33)) "") ('t (cons x xs)))) ""))
(define (trim-whitespace line)
  (cond ((< (car line) 33) (trim-whitespace (cdr line)))
  	('t (trim-trailing-whitespace line))))
(define (map op list) ((foldr (fn (x xs) (cons (op x) xs)) '()) list))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for inter-process I/O ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (fork id space child continuation)
  (cons (list id space child) continuation))
(define (send-to-parent msg continuation)
  (cons (list msg) continuation))
(define (send-to-child child-id msg continuation)
  (cons (list child-id msg) continuation))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for processing symbols ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (string->symbol chars) (fn (op) (op 't chars)))
(define (make-symbol return)
   (fn (chars rest) (return (string->symbol chars) rest)))
(define (symbol->string symbol) (symbol (fn (is-symbol chars) chars)))
(define (symbol-equal symbol1 symbol2)
   (equal (symbol->string symbol1) (symbol->string symbol2)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions defining the parser ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (parse-symbol source return)
   (cond ((= source ()) (return () source))
         ((< (car source) 33) (return () source)) ; Whitespace
         ((= (car source) 39) (return () source)) ; Quote
         ((= (car source) 40) (return () source)) ; Open Paren
         ((= (car source) 41) (return () source)) ; Close Paren
         ((= (car source) 46) (return () source)) ; Period
         ((= (car source) 92) (return () source)) ; Backslash
         ('t (parse-symbol (cdr source)
                           (fn (chars rest)
                               (return (cons (car source) chars) rest))))))
(define (parse-number val source return)
   (cond ((and (> (car source) 47) (< (car source) 58))
          (parse-number (+ (* val 10) (- (car source) 48))
                        (cdr source) return))
         ('t (return val source))))
(define (parse-atom source return)
   (cond ((= (car source) 92) (return 'fn (cdr source)))
         ((< (car source) 48) (parse-symbol source (make-symbol return)))
         ((> (car source) 57) (parse-symbol source (make-symbol return)))
         ('t (parse-number 0 source return))))
(define (parse-tail hd rest return)
  (parse-list rest (fn (tl rest) (cond ((= tl 'error) (return tl rest))
                                       ('t (return (cons hd tl) rest))))))
(define (parse-list source return)
   (cond ((= source ()) (return 'error source))
         ((< (car source) 33) (parse-list (cdr source) return))
         ((= (car source) 46) (parse-list (cdr source) return))
         ((= (car source) 41) ;; close paren
          (return '() (cdr source)))
         ('t (parse source (fn (hd rest)
                               (cond ((= hd 'error) (return hd rest))
                                     ('t (parse-tail hd rest return))))))))
(define (parse source return)
   (cond ((= source ()) (return 'error source))
         ((< (car source) 33) ;; whitespace
          (parse (cdr source) return))
         ((= (car source) 46) ;; period
          (parse (cdr source) return))
         ((= (car source) 40) ;; open paren
          (parse-list (cdr source) return))
         ((= (car source) 41) ;; close paren
          (return 'error source))
         ('t (parse-atom source return))))
(define (read source)
  (parse source (fn (expr rest) (cond (rest 'error) ('t expr)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions defining the evaluator ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (find val env)
  (cond ((atom env) val)
        ((symbol-equal val (car (car env))) (cdr (car env)))
        ('t (find val (cdr env)))))
(define (closure param body env)
  (fn (op) (op () (fn (arg) (eval body (cons (cons param arg) env))))))
(define (application op args)
  (cond ((atom args) op)
        ((function op)
  	 (op (fn (is-symbol body)
                 (cond (is-symbol (cons op args))
                       ('t (application (body (car args)) (cdr args)))))))
        ((atom op) (cons op args))
        ('t (append op args))))
(define (eval-list exprs)
  (cond ((atom (cdr exprs)) (car exprs))
        ('t (application (car exprs) (cdr exprs)))))
(define (eval expr env)
  (cond ((number expr) expr)
        ((atom expr) (find expr env))
        ((= (car expr) 'fn)
         (closure (car (cdr expr)) (cdr (cdr expr)) env))
        ('t (eval-list (map (fn (elem) (eval elem env)) expr)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions defining the printer ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (rec-print-number num str)
  (cond ((= num 0) str)
        ('t (rec-print-number (/ num 10) (cons (+ 48 (% num 10)) str)))))
(define (print-number expr)
  (cond ((= expr 0) "0")
  	((< expr 0) (append "-" (rec-print-number (- expr) "")))
  	('t (rec-print-number expr ""))))
(define print-list
  (foldr (fn (x xs) (cond ((equal ")" xs) (append (print x) xs))
                          ('t (append (print x) " " xs))))
         ")"))
(define (print expr)
  (cond ((function expr)
         (expr (fn (is-symbol val)
                   (cond (is-symbol val) ('t "<FUNCTION>")))))
        ((number expr) (print-number expr))
        ('t (cons 40 (print-list expr)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for the forked child processes ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (repl source) (print (eval (read source) ())))
(define (repl-task id reversed-source)
  (fn (space)
      (let ((output (repl (reverse reversed-source))))
      	 (send-to-parent (append (print id) ": " output "\n") ()))))

;;;;;;;;;;;;;;;;;;;;;;
;; The main process ;;
;;;;;;;;;;;;;;;;;;;;;;
(define (prompt id space results)
  (output (apply append (reverse (cons "> " (cons (print id) results))))
  	  (forward id space "" '())))
(define (output line return)
  (cond ((atom line) return)
        ('t (send-to-parent (car line) (output (cdr line) return)))))
(define process-space 100)
(define (forward id space line results)
  (fn (input)
      (cond ((< space process-space) "Out of memory!\n")
      	    ((= input 10)
	     (cond ((atom (trim-whitespace line))
	     	    (prompt id space results))
		   ('t (fork id process-space (repl-task id line)
	     	             (prompt (+ id 1)
			     	     (- space process-space)
				     results)))))
      	    ((= input 0) '())
      	    ((atom input) (forward id space (cons input line) results))
	    ('t (forward id (+ space process-space) line (cons input results))))))

;; The main loop
(define greeting
  (append "This is a simple, multi-tasking lambda-calculator.\n"
          "Use the \"\\\" character for \"lambda\", surround\n"
          "lambda expressions by parentheses, and separate the\n"
          "parameter from the body by either a period, whitespace,\n"
          "or parentheses. So, for instance, true is \"(\\x(\\y x))\"\n"
          "and false is \"(\\x(\\y y))\".\n\n"
          "Type <CTRL>+D to quit.\n"))
(define (main space args) (prompt 0 space (list greeting)))
main
