;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; repl.lsk : Multitasking LOSAK Read-Eval-Print loop              ;;
;; Copyright (C) 2004 - 2010 by Omar Jarjur                        ;;
;;                                                                 ;;
;; This program is free software; you can redistribute it and/or   ;;
;; modify it under the terms of version 2 of the GNU General       ;;
;; Public License as published by the Free Software Foundation.    ;;
;;                                                                 ;;
;; This program is distributed in the hope that it will be useful, ;;
;; but WITHOUT ANY WARRANTY; without even the implied warranty of  ;;
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ;;
;; GNU General Public License for more details.                    ;;
;;                                                                 ;;
;; You should have received a copy of the GNU General Public       ;;
;; License along with this program; if not, write to the Free      ;;
;; Software Foundation, Inc.,                                      ;;
;; 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (caar x) (car (car x)))
(define (cdar x) (cdr (car x)))
(define (cadr x) (car (cdr x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (cadar x) (car (cdr (car x))))
(define (caadr x) (car (car (cdr x))))
(define (caddr x) (car (cdr (cdr x))))
(define (id x) x)
(define (list . args) args)
(define (apply op args) (op . args))
(define (equal x y)
        (cond ((atom x) (= x y))
              ((atom y) '())
              ((equal (car x) (car y)) (equal (cdr x) (cdr y)))
              ('t '())))
(define (walk head tail test merge ret)
  (fn (tree)
      (cond ((test tree) (ret tree))
            ('t (merge (head tree)
                       ((walk head tail test merge ret)
                        (tail tree)))))))
(define (foldr merge end) (walk car cdr atom merge (fn (val) end)))
(define (foldl merge end)
  (fn (expr)
    (((walk car cdr atom
            (fn (x op) (fn (xs) (op (merge x xs))))
            (fn (x) id))
      expr) end)))
(define reverse (foldl cons '()))
(define (or . args) ((foldr (fn (t ts) (cond (t t) ('t ts))) '()) args))
(define (and . args) ((foldr (fn (t ts) (cond (t ts) ('t '()))) 't) args))
(define (not test) (cond (test '()) ('t 't)))
(define (append . args) ((foldr (fn (x xs) (cond ((= xs '()) x)
                                                ('t ((foldr cons xs) x))))
                               '()) args))
(define (length list) ((foldr (fn (x y) (+ 1 y)) 0) list))
(define (add . args) ((foldr + 0) args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for maintaining the symbol table ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (string->symbol string)
  (cond ((equal string "cond") 'cond)
        ((equal string "let") 'let)
        ((equal string "fn") 'fn)
        ((equal string "quote") 'quote)
        ((equal string "cons") 'cons)
        ((equal string "car") 'car)
        ((equal string "cdr") 'cdr)
        ((equal string "atom") 'atom)
        ((equal string "number") 'number)
        ((equal string "function") 'function)
        ((equal string "=") '=)
        ((equal string "<") '<)
        ((equal string ">") '>)
        ((equal string "+") '+)
        ((equal string "-") '-)
        ((equal string "*") '*)
        ((equal string "/") '/)
        ((equal string "%") '%)
        ((equal string "~") '~)
        ((equal string "&") '&)
        ((equal string "|") '|)
        ((equal string "^") '^)
        ((equal string ">>") '>>)
        ((equal string ">>>") '>>>)
        ((equal string "<<") '<<)
        ((equal string "define") 'define)
        ('t (let ((symbol-length (length string)))
              (fn (op) (op symbol-length string))))))
(define (symbol->string symbol)
  (cond ((function symbol)
         (symbol (fn (length string) string)))
        ((= symbol '()) "()")
        ((= symbol 'cond) "cond")
        ((= symbol 'let) "let")
        ((= symbol 'fn) "fn")
        ((= symbol 'quote) "quote")
        ((= symbol 'cons) "cons")
        ((= symbol 'car) "car")
        ((= symbol 'cdr) "cdr")
        ((= symbol 'atom) "atom")
        ((= symbol 'number) "number")
        ((= symbol 'function) "function")
        ((= symbol '=) "=")
        ((= symbol '<) "<")
        ((= symbol '>) ">")
        ((= symbol '+) "+")
        ((= symbol '-) "-")
        ((= symbol '*) "*")
        ((= symbol '/) "/")
        ((= symbol '%) "%")
        ((= symbol '~) "~")
        ((= symbol '&) "&")
        ((= symbol '|) "|")
        ((= symbol '^) "^")
        ((= symbol '>>) ">>")
        ((= symbol '>>>) ">>>")
        ((= symbol '<<) "<<")
        ((= symbol 'define) "define")
        ('t "<INTERNAL-ERROR: UNKNOWN SYMBOL>")))

(define (symbol-eq s1 s2)
  (cond ((and (function s1) (function s2))
         (let ((get-length (fn (symbol) (symbol (fn (length string) length)))))
           (cond ((= (get-length s1) (get-length s2))
                  (equal (symbol->string s1) (symbol->string s2)))
                 ('t '()))))
        ('t (= s1 s2))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper functions for parsing ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (escape-char char return line-num)
  (return (cond ((= char 116) 9)
                ((= char 114) 13)
                ((= char 110) 10)
                ('t char))
          line-num))
(define (build-num chars return line-num)
  (return ((foldl (fn (c n) (+ (* 10 n) (- c 48))) 0) chars) line-num))
(define (drop-first pair return line-num)
  (return (cdr pair) line-num))
(define (drop-second pair return line-num)
  (return (car pair) line-num))
(define (quote-value expr return line-num)
  (return (list 'quote expr) line-num))
(define (lookup-symbol chars return line-num)
  (return (string->symbol chars) line-num))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Parser combinators that simplify the process of       ;;
;; writting an LL(1) grammar.                            ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Each combinator takes a return continuation, an error ;;
;; continuation, and a line number.                      ;;
;; Each parser is a function that takes an input         ;;
;; character, and then either returns a continuation     ;;
;; parser, invokes the error continuation, or passes a   ;;
;; parsed value and new line number to the return        ;;
;; continuation.                                         ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (fail message) (fn (return error line-num) (error message line-num)))
(define (done return error line-num) (return '() line-num))
(define (pop return error line-num)
  (fn (char)
      (cond ((= char '()) (pop return error line-num))
            ((not (number char)) (error "unexpected end of input" line-num))
            ((= char 10)
             (return char (+ 1 line-num)))
            ('t (return char line-num)))))
(define (check test error-message)
  (fn (return error line-num)
      (pop (fn (val line-num)
               (cond ((test val) (return val line-num))
                     ('t ((error error-message line-num) val))))
           error line-num)))
(define (match char)
  (check (fn (val) (= val char))
         (append "failed to read expected character \'" (list char) "\'")))
(define (default parser) (fn (else) parser))
(define (case test then)
  (fn (else)
      (fn (return error line-num)
          (test (fn (val line-num)
                    (then return error line-num))
                (fn (error-message error-line-number)
                    (else return error line-num))
                line-num))))
(define (choice . args)
  ((foldr (fn (c cs) (c cs)) (fail "found no matching parse options")) args))
(define (post-process parser op)
  (fn (return error line-num)
      (parser (fn (val line-num)
                  (op val return line-num))
              error line-num)))
(define (seq parser1 parser2)
  (fn (return error line-num)
      (parser1 (fn (head line-num)
                   (parser2 (fn (tail line-num)
                                (return (cons head tail) line-num))
                            error line-num))
               error line-num)))
(define (escape parser) (seq (post-process pop escape-char) parser))
(define (use parser) (seq pop parser))
(define (peek parser)
  (fn (return error line-num)
      (parser (fn (val new-line-num)
                  ((return val line-num) val))
              error line-num)))
(define (interval start end)
  (check (fn (val) (and (> val (- start 1)) (< val (+ end 1))))
         (append "failed to read a character in the range \'"
                 start "\' -> \'" end "\'")))
(define (skip parser) (post-process (use parser) drop-first))
(define (first parser1 parser2)
  (post-process (seq parser1 parser2) drop-second))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to parse an s-expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (parse-num . args)
  (apply (choice (case (interval 0 32) done)
                 (case (peek (interval 48 57)) (use parse-num))
                 (default done))
         args))
(define (read-num . args) (apply (post-process parse-num build-num) args))
(define (parse-symbol . args)
  (apply (choice (case (interval 0 32) done)
                 (case (peek (interval 39 41)) done)
                 (case (peek (match 46)) done)
                 (case (peek (match 59)) done)
                 (default (use parse-symbol)))
         args))
(define (read-symbol . args)
  (apply (post-process parse-symbol lookup-symbol) args))
(define (parse-string . args)
  (apply (choice (case (match 34) done)
                 (case (match 92) (escape parse-string))
                 (default (use parse-string)))
         args))
(define (quote-parser parser) (post-process parser quote-value))
(define (comment parser)
  (fn args (apply (choice (case (match 10) parser)
                          (case (match 13) parser)
                          (default (skip (comment parser))))
                  args)))
(define (parse-paren . args)
  (apply (choice (case (interval 1 32) parse-paren)
                 (case (match 59) (comment parse-paren))
                 (case (match 41) done))
         args))
(define (parse-pair . args)
  (apply (choice (case (interval 1 32) parse-pair)
                 (case (match 59) (comment parse-pair))
                 (case (match 41) done)
                 (case (match 46) (first parse-expr parse-paren))
                 (default (seq parse-expr parse-pair)))
         args))
(define (parse-expr . args)
  (apply (choice (case (interval 1 32) parse-expr)
                 (case (match 34) (quote-parser parse-string))
                 (case (match 39) (quote-parser parse-expr))
                 (case (match 40) parse-pair)
                 (case (match 41)
                       (fail "found an unexpected closing parenthesis"))
                 (case (match 46) (fail "found an unexpected period"))
                 (case (match 59) (comment parse-expr))
                 (case (peek (interval 48 57)) read-num)
                 (default read-symbol))
         args))
(define initial-reader
  (parse-expr (fn (expression line-number)
                  (list 'read expression))
              (fn (error-message error-line-number)
                  (list 'error (append "Parse error, line "
                                       (number->string error-line-number)
                                       ": " error-message "\n\r")))
              1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to represent evaluated expressions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (NUMBER val)
  (fn (number-handler symbol-handler function-handler pair-handler)
      (number-handler val)))
(define (SYMBOL val)
  (fn (number-handler symbol-handler function-handler pair-handler)
      (symbol-handler val)))
(define (FUNCTION val size)
  (fn (number-handler symbol-handler function-handler pair-handler)
      (function-handler val size)))
(define (PAIR head tail)
  (let ((pair-size (+ 1 (+ (size head) (size tail)))))
    (fn (number-handler symbol-handler function-handler pair-handler)
        (pair-handler head tail pair-size))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to print evaluated s-expressions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (build_num_str num)
  ((walk (fn (n) (% n 10))
         (fn (n) (/ n 10))
         (fn (n) (= n 0))
         (fn (d op) (fn (str) (op (cons (+ d 48) str))))
         (fn (x) id))
   num))
(define (number->string num)
  (cond ((< num 0) (cons 45 ((build_num_str (- num)) "")))
        ((= num 0) "0")
        ('t ((build_num_str num) ""))))
(define (print expr)
  (expr (fn (num) (number->string num))
        (fn (symbol) (symbol->string symbol))
        (fn (fun function-size) "<FUNCTION>")
        (fn (head tail pair-size)
            (let ((tail-string (print tail)))
              (cond ((equal tail-string "()")
                     (append "(" (print head) ")"))
                    ((= (car tail-string) 40)
                     (append "(" (print head) " " (cdr tail-string)))
                    ('t (append "(" (print head) " . " tail-string ")")))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for processing an evaluated expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (size expr)
  (expr (fn (num) 1)
        (fn (sym) (cond ((function sym) (sym (fn (length string) length)))
                        ('t 1)))
        (fn (fun size) size)
        (fn (head tail size) size)))
(define (not-null? expr)
  (expr (fn (num) 't)
        (fn (sym) sym)
        (fn (fun size) 't)
        (fn (head tail size) 't)))
(define (get-head expr)
  (expr (fn (num) FALSE)
        (fn (sym) FALSE)
        (fn (fun size) FALSE)
        (fn (head tail size) head)))
(define (get-tail expr)
  (expr (fn (num) FALSE)
        (fn (sym) FALSE)
        (fn (fun size) FALSE)
        (fn (head tail size) tail)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper functions for evaluation of primitive operations ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define TRUE (SYMBOL (string->symbol "t")))
(define FALSE (SYMBOL '()))
(define (pair-operation op)
  (fn (args cont error)
      (cont ((get-head args) (fn (num) FALSE)
                             (fn (sym) FALSE)
                             (fn (fun size) FALSE)
                             (fn (head tail size) (op (cons head tail)))))))
(define (unary-operation op)
  (fn (args cont error)
      (cont ((get-head args) (fn (num) (NUMBER (op num)))
                             (fn (sym) FALSE)
                             (fn (fun size) FALSE)
                             (fn (head tail size) FALSE)))))
(define (numerical-operation op)
  (fn (args cont error)
      ((get-head args) (fn (num1)
                           ((unary-operation (fn (num2) (op num1 num2)))
                            (get-tail args) cont error))
                       (fn (sym) (cont FALSE))
                       (fn (fun size) (cont FALSE))
                       (fn (head tail size) (cont FALSE)))))
(define (boolean-operation op)
  (fn (args error cont)
      (let ((arg1 (get-head args))
            (arg2 (get-head (get-tail args))))
        (arg1 (fn (num1)
                  (cont (arg2 (fn (num2) (cond ((op num1 num2) TRUE)
                                               ('t FALSE)))
                              (fn (sym) FALSE)
                              (fn (fun size) FALSE)
                              (fn (head tail size) FALSE))))
              (fn (sym1) (cont FALSE))
              (fn (fun size) (cont FALSE))
              (fn (head tail size) (cont FALSE))))))
(define (equals-test args error cont)
  (let ((arg1 (get-head args))
        (arg2 (get-head (get-tail args))))
    (arg1 (fn (num1)
              (cont (arg2 (fn (num2) (cond ((= num1 num2) TRUE) ('t FALSE)))
                          (fn (sym) FALSE)
                          (fn (fun size) FALSE)
                          (fn (head tail size) FALSE))))
          (fn (sym1)
              (cont (arg2 (fn (num) FALSE)
                          (fn (sym2)
                              (cond ((symbol-eq sym1 sym2) TRUE) ('t FALSE)))
                          (fn (fun size) FALSE)
                          (fn (head tail size) FALSE))))
          (fn (fun size) (cont FALSE))
          (fn (head tail size) (cont FALSE)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Interpreter for lambda-calculus expressions             ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Processes are compiled into these expressions and it is ;;
;; the lambda-calculus interpreter that enforces the rules ;;
;; of memory protection/cooperative multitasking.          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (wrap-literal val)
  (cond ((number val) (NUMBER val))
        ((atom val) (SYMBOL val))
        ('t (PAIR (wrap-literal (car val)) (wrap-literal (cdr val))))))
(define (LIT val)
  (let ((wrapped-val (wrap-literal val)))
    (fn (env globals mem cont error) (cont wrapped-val))))
(define (FIND var)
  (fn (env globals mem cont error) (cont (env var globals))))
(define (IF test then else)
  (fn (env globals mem cont error)
      (test env globals (- mem 1)
            (fn (result) ((cond ((not-null? result) then)
                                ('t else))
                          env globals mem cont error))
            error)))
(define (LAMBDA params body)
  (fn (env globals mem cont error)
      (cond ((< mem 0) (error "Out of memory"))
            ('t (cont (FUNCTION (fn (args cont error)
                                    (body (bind params args env)
                                          globals mem cont error))
                                (size env)))))))
(define (APPLY op args)
  (fn (env globals mem cont error)
      (args env globals mem
            (fn (args-val)
                (op env globals (- mem (size args-val))
                    (fn (op-val)
                        (op-val (fn (num) (cont FALSE))
                                (fn (sym) (cont FALSE))
                                (fn (fun size) (fun args-val cont error))
                                (fn (head tail) (cont FALSE))))
                    error))
            error)))
(define (CONS arg1 arg2)
  (fn (env globals mem cont error)
      (cond ((< mem 0) (error "Out of memory"))
            ('t (arg2 env globals mem
                      (fn (arg2-val)
                          (arg1 env globals (- mem (size arg2-val))
                                (fn (arg1-val)
                                    (cont (PAIR arg1-val arg2-val)))
                                error))
                      error)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compiler from s-expressions to lambda terms ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define compile-cond (foldr (fn (case else) (IF (compile (car case))
                                                (compile (cadr case))
                                                else))
                            (LIT '())))
(define (compile-let bindings body)
  (compile ((foldr (fn (binding expr)
                       (list (list 'fn (list (car binding)) expr)
                             (cadr binding)))
                   body)
            bindings)))
(define compile-args
  (walk car cdr atom
        (fn (arg arg_list) (CONS (compile arg) arg_list))
        (fn (args) (compile args))))
(define (compile expr env)
  (cond ((= expr '()) (LIT '()))
        ((number expr) (LIT expr))
        ((atom expr) (FIND expr))
        ((= (car expr) 'quote) (LIT (cadr expr)))
        ((= (car expr) 'cond) (compile-cond (cdr expr)))
        ((= (car expr) 'let) (compile-let (cadr expr) (caddr expr)))
        ((= (car expr) 'fn) (LAMBDA (cadr expr) (compile (caddr expr))))
        ('t (APPLY (compile (car expr))
                   (compile-args (cdr expr))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Binding environment functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define initial-globals
  (let ((cons-value (FUNCTION (fn (args cont error)
                                  (cont (PAIR (get-head args)
                                              (get-head (get-tail args)))))
                              1))
        (car-value (FUNCTION (pair-operation car) 1))
        (cdr-value (FUNCTION (pair-operation cdr) 1))
        (=-value (FUNCTION equals-test 1))
        (<-value (FUNCTION (boolean-operation <) 1))
        (>-value (FUNCTION (boolean-operation >) 1))
        (+-value (FUNCTION (numerical-operation +) 1))
        (--value (FUNCTION (fn (args cont error)
                               (cond ((not-null? (get-tail args))
                                      ((numerical-operation -)
                                       args cont error))
                                     ('t ((unary-operation -)
                                          args cont error))))
                           1))
        (*-value (FUNCTION (numerical-operation *) 1))
        (/-value (FUNCTION (numerical-operation /) 1))
        (%-value (FUNCTION (numerical-operation %) 1))
        (>>-value (FUNCTION (numerical-operation >>) 1))
        (>>>-value (FUNCTION (numerical-operation >>>) 1))
        (<<-value (FUNCTION (numerical-operation <<) 1))
        (~-value (FUNCTION (unary-operation ~) 1))
        (&-value (FUNCTION (numerical-operation &) 1))
        (^-value (FUNCTION (numerical-operation ^) 1))
        (|-value (FUNCTION (numerical-operation |) 1))
        (atom-value (FUNCTION (fn (args cont error)
                                  (cont ((car args)
                                         (fn (num) TRUE)
                                         (fn (sym) TRUE)
                                         (fn (fun size) TRUE)
                                         (fn (head tail size) FALSE))))
                              1))
        (function-value (FUNCTION (fn (args cont error)
                                      (cont ((car args)
                                             (fn (num) FALSE)
                                             (fn (sym) FALSE)
                                             (fn (fun size) TRUE)
                                             (fn (head tail size) FALSE))))
                                  1))
        (number-value (FUNCTION (fn (args cont error)
                                    (cont ((car args)
                                           (fn (num) TRUE)
                                           (fn (sym) FALSE)
                                           (fn (fun size) FALSE)
                                           (fn (head tail size) FALSE))))
                                1)))
    (fn (var)
        (cond ((= var 'cons) cons-value)
              ((= var 'car) car-value)
              ((= var 'cdr) cdr-value)
              ((= var '=) =-value)
              ((= var '<) <-value)
              ((= var '>) >-value)
              ((= var '+) +-value)
              ((= var '-) --value)
              ((= var '*) *-value)
              ((= var '/) /-value)
              ((= var '%) %-value)
              ((= var '>>) >>-value)
              ((= var '>>>) >>>-value)
              ((= var '<<) <<-value)
              ((= var '&) &-value)
              ((= var '^) ^-value)
              ((= var '|) |-value)
              ((= var 'atom) atom-value)
              ((= var 'function) function-value)
              ((= var 'number) number-value)
              ('t FALSE)))))

(define (add-global name val globals)
  (fn (var) (cond ((symbol-eq var name) val)
                  ('t (globals var)))))
(define (empty-env var globals) (globals var))
(define (bind params val env)
  (cond ((= params '()) env)
        ((atom params)
         (fn (var globals)
             (cond ((symbol-eq var params) val)
                   ('t (env var globals)))))
        ('t (bind (car params) (get-head val)
                  (bind (cdr params) (get-tail val) env)))))

(define (eval expr globals space return error-return)
  ((compile expr) empty-env globals space return error-return))
(define (definition-return name)
  (fn (value) (send-to-parent (list name 'define value) '())))
(define (expression-return id)
  (fn (value) (send-to-parent (list id 'done (print value)) '())))
(define (error-return id)
  (fn (message)
      (send-to-parent (list id 'done (append "Error: " message)) '())))
(define (definition-name definition)
  (cond ((atom (cadr definition)) (cadr definition))
        ('t (caadr definition))))
(define (definition-body definition)
  (cond ((atom (cadr definition)) (caddr definition))
        ('t (list 'fn (cdr (cadr definition)) (caddr definition)))))
(define (evaluator id expr globals)
  (fn (space) (cond ((= (car expr) 'define)
                     (eval (definition-body expr) globals space
                           (definition-return (definition-name expr))
                           (error-return id)))
                    ('t (eval expr globals space
                              (expression-return id)
                              (error-return id))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for inter-process I/O ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (fork id space child continuation)
  (cons (list id space child) continuation))
(define (send-to-parent msg continuation)
  (cons (list msg) continuation))
(define (send-to-child child-id msg continuation)
  (cons (list child-id msg) continuation))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to perform the main loop of the Operating System ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define process-space 1000)
(define (run-cmd curr_id cmd output globals)
  (cond ((equal cmd ":q\n") 0) ;; Quit
        ((equal cmd ":l\n") (prompt curr_id (append output gpl-str) globals))
        ('t (prompt curr_id (append output help-str) globals))))
(define (process-reader-result reader-result read-count id output line globals)
  (cond ((function reader-result)
         (process-input reader-result read-count id output line globals))
        ((= (car reader-result) 'error)
         (process-input initial-reader 0 (+ id 1)
                        (append output
                                (number->string id) ": " (cadr reader-result)
                                 "\n\r")
                        line globals))
        ('t (fork id process-space
                  (evaluator id (cadr reader-result) globals)
                  (process-input initial-reader 0 (+ id 1)
                                 output line globals)))))
(define (process-input reader read-count id output line globals)
  (cond ((and (atom line) (= read-count 0)) (prompt id output globals))
        ((atom line) (main id output "" reader read-count globals))
        ('t (let ((reader-result (reader (car line)))
                  (read-count (cond ((and (= read-count 0) (< (car line) 33))
                                     read-count)
                                    ('t (+ read-count 1)))))
              (process-reader-result reader-result read-count
                                     id output (cdr line) globals)))))
(define (process-key key id output reversed-line reader read-count globals)
  (cond ((= key 10)
         (let ((line (reverse reversed-line)))
           (cond ((and (= (car line) 58) (= read-count 0))
                  (run-cmd id line output globals))
                 ('t (process-input reader read-count
                                    id output line globals)))))
        ('t (main id output reversed-line reader read-count globals))))
(define (main current-id output current-line reader read-count globals)
  (fn (in)
      (cond ((atom in)
             (process-key in current-id output (cons in current-line)
                          reader read-count globals))
            ((= (cadr in) 'define)
             (main current-id
                   (append output "Define: " (symbol->string (car in)) "\n\r")
                   current-line reader read-count
                   (add-global (car in) (caddr in) globals)))
            ((= (cadr in) 'done)
             (main current-id
                   (append output
                           (number->string (car in)) ": " (caddr in) "\n\r")
                   current-line reader read-count globals))
            ('t (main current-id output current-line
                      reader read-count globals)))))
(define (prompt current-id output globals)
  (append output "expr " (number->string current-id) "> "
          (main current-id "" "" initial-reader 0 globals)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Informational strings  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (build-init-msg space cmd boot)
  (append "Loaded with " (number->string space) " free cons cells.\n\r"
          "Arguments: " cmd "\n\r"
          boot))
(define help-str (append "Commands:\n\r"
                         "\t:h - display this help menu\n\r"
                         "\t:l - display license information\n\r"
                         "\t:q - quit\n\r"
                         "\t<EXPR> - evaluate the expression <EXPR>\n\r"))
(define release-str "Omar's REPL, release 20100802.\n\r")
(define gpl-str
  (append release-str
          "Copyright (C) 2004 - 2010 by Omar Jarjur"
          "\n\n\rThis program is free software. You can redistribute "
          "it and/or modify it under the terms of version 2 of the "
          "GNU General Public License as published by the Free "
          "Software Foundation."
          "\n\n\rThis program is distributed in the hope that it will "
          "be useful, but WITHOUT ANY WARRANTY; without even the "
          "implied warranty of MERCHANTABILITY or FITNESS FOR A "
          "PARTICULAR PURPOSE. See the GNU General Public License for "
          "more details."
          "\n\n\rYou should have received a copy of the GNU General "
          "Public License along with this program; if not, write to "
          "the Free Software Foundation, Inc., 59 Temple Place, "
          "Suite 330, Boston, MA 02111-1307 USA\n\r"))
(define boot-str
  (append release-str "System running. Type \":h\" for the help menu.\n\r"))

;; Entry point
(fn (space args)
    (prompt 0 (build-init-msg space args boot-str) initial-globals))
