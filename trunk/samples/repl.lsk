;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; repl.lsk : Multitasking LOSAK Read-Eval-Print loop              ;;
;; Copyright (C) 2004 - 2011 by Omar Jarjur                        ;;
;;                                                                 ;;
;; This program is free software; you can redistribute it and/or   ;;
;; modify it under the terms of version 2 of the GNU General       ;;
;; Public License as published by the Free Software Foundation.    ;;
;;                                                                 ;;
;; This program is distributed in the hope that it will be useful, ;;
;; but WITHOUT ANY WARRANTY; without even the implied warranty of  ;;
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ;;
;; GNU General Public License for more details.                    ;;
;;                                                                 ;;
;; You should have received a copy of the GNU General Public       ;;
;; License along with this program; if not, write to the Free      ;;
;; Software Foundation, Inc.,                                      ;;
;; 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (walk head tail test merge ret)
  (fn (tree)
      (cond ((test tree) (ret tree))
            ('t (merge (head tree)
                       ((walk head tail test merge ret)
                        (tail tree)))))))
(define (length list) ((foldr (fn (x y) (+ 1 y)) 0) list))
(define (add . args) ((foldr + 0) args))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to parse an s-expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define initial-reader
  (parse-expr (fn (expression line-number)
                  (list 'read expression))
              (fn (error-message error-line-number)
                  (list 'error (append "Parse error, line "
                                       (print error-line-number)
                                       ": " error-message "\n\r")))
              1))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to represent evaluated expressions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (NULL null-handler number-handler symbol-handler function-handler pair-handler)
  (null-handler))
(define (NUMBER val)
  (fn (null-handler number-handler symbol-handler function-handler pair-handler)
      (number-handler val)))
(define (SYMBOL val)
  (let ((symbol-size (length (symbol->string val))))
    (fn (null-handler number-handler symbol-handler function-handler pair-handler)
        (symbol-handler val symbol-size))))
(define (FUNCTION val size)
  (fn (null-handler number-handler symbol-handler function-handler pair-handler)
      (function-handler val size)))
(define (PAIR head tail)
  (let ((pair-size (+ 1 (+ (size head) (size tail)))))
    (fn (null-handler number-handler symbol-handler function-handler pair-handler)
        (pair-handler head tail pair-size))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to print evaluated s-expressions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (expr->string expr)
  (expr (fn () "()")
        (fn (num) (print num))
        (fn (symbol symbol-size) (symbol->string symbol))
        (fn (fun function-size) "<FUNCTION>")
        (fn (head tail pair-size)
            (let ((head-string (expr->string head))
                  (tail-string (expr->string tail)))
              (cond ((equal tail-string "()")
                     (append "(" head-string ")"))
                    ((= (car tail-string) 40)
                     (append "(" head-string " " (cdr tail-string)))
                    ('t (append "(" head-string " . " tail-string ")")))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for processing an evaluated expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (size expr)
  (expr (fn () 0)
        (fn (num) 1)
        (fn (sym size) size)
        (fn (fun size) size)
        (fn (head tail size) size)))
(define (not-null? expr)
  (expr (fn () '())
        (fn (num) 't)
        (fn (sym size) 't)
        (fn (fun size) 't)
        (fn (head tail size) 't)))
(define (get-head expr)
  (expr (fn () NULL)
        (fn (num) NULL)
        (fn (sym size) NULL)
        (fn (fun size) NULL)
        (fn (head tail size) head)))
(define (get-tail expr)
  (expr (fn () NULL)
        (fn (num) NULL)
        (fn (sym size) NULL)
        (fn (fun size) NULL)
        (fn (head tail size) tail)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper functions for evaluation of primitive operations ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define TRUE (SYMBOL 't))
(define (pair-operation op)
  (fn (args globals mem cont error)
      (cont ((get-head args) (fn () NULL)
                             (fn (num) NULL)
                             (fn (sym size) NULL)
                             (fn (fun size) NULL)
                             (fn (head tail size) (op (cons head tail)))))))
(define (unary-operation op)
  (fn (args globals mem cont error)
      (cont ((get-head args) (fn () NULL)
                             (fn (num) (NUMBER (op num)))
                             (fn (sym size) NULL)
                             (fn (fun size) NULL)
                             (fn (head tail size) NULL)))))
(define (numerical-operation op)
  (fn (args globals mem cont error)
      ((get-head args) (fn () (cont NULL))
                       (fn (num1)
                           ((unary-operation (fn (num2) (op num1 num2)))
                            (get-tail args) globals mem cont error))
                       (fn (sym size) (cont NULL))
                       (fn (fun size) (cont NULL))
                       (fn (head tail size) (cont NULL)))))
(define (boolean-operation op)
  (fn (args globals mem cont error)
      (let ((arg1 (get-head args))
            (arg2 (get-head (get-tail args))))
        (arg1 (fn () (cont NULL))
              (fn (num1)
                  (cont (arg2 (fn () NULL)
                              (fn (num2) (cond ((op num1 num2) TRUE)
                                               ('t NULL)))
                              (fn (sym size) NULL)
                              (fn (fun size) NULL)
                              (fn (head tail size) NULL))))
              (fn (sym1 size) (cont NULL))
              (fn (fun size) (cont NULL))
              (fn (head tail size) (cont NULL))))))
(define (equals-test args globals mem cont error)
  (let ((arg1 (get-head args))
        (arg2 (get-head (get-tail args))))
    (arg1 (fn () (cont NULL))
          (fn (num1)
              (cont (arg2 (fn () NULL)
                          (fn (num2) (cond ((= num1 num2) TRUE) ('t NULL)))
                          (fn (sym size) NULL)
                          (fn (fun size) NULL)
                          (fn (head tail size) NULL))))
          (fn (sym1 size)
              (cont (arg2 (fn () NULL)
                          (fn (num) NULL)
                          (fn (sym2 size)
                              (cond ((= sym1 sym2) TRUE) ('t NULL)))
                          (fn (fun size) NULL)
                          (fn (head tail size) NULL))))
          (fn (fun size) (cont NULL))
          (fn (head tail size) (cont NULL)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Interpreter for lambda-calculus expressions             ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Processes are compiled into these expressions and it is ;;
;; the lambda-calculus interpreter that enforces the rules ;;
;; of memory protection/cooperative multitasking.          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (wrap-literal val)
  (cond ((number val) (NUMBER val))
        ((symbol? val) (SYMBOL val))
        ((atom val) NULL)
        ('t (PAIR (wrap-literal (car val)) (wrap-literal (cdr val))))))
(define (LIT val)
  (let ((wrapped-val (wrap-literal val)))
    (fn (env globals mem cont error) (cont wrapped-val))))
(define (FIND var)
  (fn (env globals mem cont error) (cont (lookup var env globals))))
(define (IF test then else)
  (fn (env globals mem cont error)
      (test env globals (- mem 1)
            (fn (result) ((cond ((not-null? result) then)
                                ('t else))
                          env globals mem cont error))
            error)))
(define (LAMBDA params body)
  (fn (env globals mem cont error)
      (cond ((< mem (+ 1 (size env))) (error "Out of memory"))
            ('t (cont (FUNCTION (fn (args globals mem cont error)
                                    (body (bind params args env)
                                          globals mem cont error))
                                (size env)))))))
(define (APPLY op args)
  (fn (env globals mem cont error)
      (args env globals mem
            (fn (args-val)
                (op env globals (- mem (size args-val))
                    (fn (op-val)
                        (op-val (fn () (cont NULL))
                                (fn (num) (cont NULL))
                                (fn (sym size) (cont NULL))
                                (fn (fun size)
                                    (fun args-val globals mem cont error))
                                (fn (head tail) (cont NULL))))
                    error))
            error)))
(define (CONS arg1 arg2)
  (fn (env globals mem cont error)
      (cond ((< mem (+ 1 (size env))) (error "Out of memory"))
            ('t (arg2 env globals mem
                      (fn (arg2-val)
                          (arg1 env globals
                                (- mem (+ 1 (size arg2-val)))
                                (fn (arg1-val) (cont (PAIR arg1-val arg2-val)))
                                error))
                      error)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compiler from s-expressions to lambda terms ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define compile-cond (foldr (fn (case else) (IF (compile (car case))
                                                (compile (cadr case))
                                                else))
                            (LIT '())))
(define (compile-let bindings body)
  (compile ((foldr (fn (binding expr)
                       (list (list 'fn (list (car binding)) expr)
                             (cadr binding)))
                   body)
            bindings)))
(define compile-args
  (walk car cdr atom
        (fn (arg arg_list) (CONS (compile arg) arg_list))
        (fn (args) (compile args))))
(define (compile expr env)
  (cond ((symbol? expr) (FIND expr))
        ((number expr) (LIT expr))
        ((atom expr) (LIT '()))
        ((= (car expr) 'quote) (LIT (cadr expr)))
        ((= (car expr) 'cond) (compile-cond (cdr expr)))
        ((= (car expr) 'let) (compile-let (cadr expr) (caddr expr)))
        ((= (car expr) 'fn) (LAMBDA (cadr expr) (compile (caddr expr))))
        ('t (APPLY (compile (car expr))
                   (compile-args (cdr expr))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Binding environment functions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define initial-globals
  (let ((cons-value (FUNCTION (fn (args globals mem cont error)
                                  (cont (PAIR (get-head args)
                                              (get-head (get-tail args)))))
                              1))
        (car-value (FUNCTION (pair-operation car) 1))
        (cdr-value (FUNCTION (pair-operation cdr) 1))
        (=-value (FUNCTION equals-test 1))
        (<-value (FUNCTION (boolean-operation <) 1))
        (>-value (FUNCTION (boolean-operation >) 1))
        (+-value (FUNCTION (numerical-operation +) 1))
        (--value (FUNCTION (fn (args globals mem cont error)
                               (cond ((not-null? (get-tail args))
                                      ((numerical-operation -)
                                       args globals mem cont error))
                                     ('t ((unary-operation -)
                                          args globals mem cont error))))
                           1))
        (*-value (FUNCTION (numerical-operation *) 1))
        (/-value (FUNCTION (numerical-operation /) 1))
        (%-value (FUNCTION (numerical-operation %) 1))
        (>>-value (FUNCTION (numerical-operation >>) 1))
        (>>>-value (FUNCTION (numerical-operation >>>) 1))
        (<<-value (FUNCTION (numerical-operation <<) 1))
        (~-value (FUNCTION (unary-operation ~) 1))
        (&-value (FUNCTION (numerical-operation &) 1))
        (^-value (FUNCTION (numerical-operation ^) 1))
        (|-value (FUNCTION (numerical-operation |) 1))
        (atom-value (FUNCTION (fn (args globals mem cont error)
                                  (cont ((car args)
                                         (fn () TRUE)
                                         (fn (num) TRUE)
                                         (fn (sym size) TRUE)
                                         (fn (fun size) TRUE)
                                         (fn (head tail size) NULL))))
                              1))
        (function-value (FUNCTION (fn (args globals mem cont error)
                                      (cont ((car args)
                                             (fn () NULL)
                                             (fn (num) NULL)
                                             (fn (sym size) NULL)
                                             (fn (fun size) TRUE)
                                             (fn (head tail size) NULL))))
                                  1))
        (number-value (FUNCTION (fn (args globals mem cont error)
                                    (cont ((car args)
                                           (fn () NULL)
                                           (fn (num) TRUE)
                                           (fn (sym size) NULL)
                                           (fn (fun size) NULL)
                                           (fn (head tail size) NULL))))
                                1)))
    (fn (var)
        (cond ((= var 'cons) cons-value)
              ((= var 'car) car-value)
              ((= var 'cdr) cdr-value)
              ((= var '=) =-value)
              ((= var '<) <-value)
              ((= var '>) >-value)
              ((= var '+) +-value)
              ((= var '-) --value)
              ((= var '*) *-value)
              ((= var '/) /-value)
              ((= var '%) %-value)
              ((= var '>>) >>-value)
              ((= var '>>>) >>>-value)
              ((= var '<<) <<-value)
              ((= var '&) &-value)
              ((= var '^) ^-value)
              ((= var '|) |-value)
              ((= var 'atom) atom-value)
              ((= var 'function) function-value)
              ((= var 'number) number-value)
              ('t NULL)))))

(define (add-global name val globals)
  (fn (var) (cond ((= var name) val)
                  ('t (globals var)))))
(define empty-env (FUNCTION (fn (var globals) (globals var)) 0))
(define (lookup var env globals)
  (env (fn () (globals var))
       (fn (num) (globals var))
       (fn (sym size) (globals var))
       (fn (fun size) (fun var globals))
       (fn (head tail size) (globals var))))
(define (bind params val env)
  (cond ((= params '()) env)
        ((atom params)
         (FUNCTION (fn (var globals)
                       (cond ((= var params) val)
                             ('t (lookup var env globals))))
                   (+ (size env) (size val))))
        ('t (bind (car params) (get-head val)
                  (bind (cdr params) (get-tail val) env)))))

(define (eval expr globals space return error-return)
  ((compile expr) empty-env globals space return error-return))
(define (definition-return name)
  (fn (value) (send-to-parent (list name 'define value) '())))
(define (expression-return id)
  (fn (value) (send-to-parent (list id 'done (expr->string value)) '())))
(define (error-return id)
  (fn (message)
      (send-to-parent (list id 'done (append "Error: " message)) '())))
(define (definition-name definition)
  (cond ((atom (cadr definition)) (cadr definition))
        ('t (caadr definition))))
(define (definition-body definition)
  (cond ((atom (cadr definition)) (caddr definition))
        ('t (list 'fn (cdr (cadr definition)) (caddr definition)))))
(define (evaluator id expr globals)
  (fn (space) (cond ((= (car expr) 'define)
                     (eval (definition-body expr) globals space
                           (definition-return (definition-name expr))
                           (error-return id)))
                    ('t (eval expr globals space
                              (expression-return id)
                              (error-return id))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for inter-process I/O ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (fork id space child continuation)
  (cons (list id space child) continuation))
(define (send-to-parent msg continuation)
  (cons (list msg) continuation))
(define (send-to-child child-id msg continuation)
  (cons (list child-id msg) continuation))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to perform the main loop of the Operating System ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define process-space 1000)
(define (run-cmd curr_id cmd output globals)
  (cond ((equal cmd ":q\n") 0) ;; Quit
        ((equal cmd ":l\n") (prompt curr_id (append output gpl-str) globals))
        ('t (prompt curr_id (append output help-str) globals))))
(define (process-reader-result reader-result read-count id output line globals)
  (cond ((function reader-result)
         (process-input reader-result read-count id output line globals))
        ((= (car reader-result) 'error)
         (process-input initial-reader 0 (+ id 1)
                        (append output
                                (print id) ": " (cadr reader-result)
                                 "\n\r")
                        line globals))
        ('t (fork id process-space
                  (evaluator id (cadr reader-result) globals)
                  (process-input initial-reader 0 (+ id 1)
                                 output line globals)))))
(define (process-input reader read-count id output line globals)
  (cond ((and (atom line) (= read-count 0)) (prompt id output globals))
        ((atom line) (main id output "" reader read-count globals))
        ('t (let ((reader-result (reader (car line)))
                  (read-count (cond ((and (= read-count 0) (< (car line) 33))
                                     read-count)
                                    ('t (+ read-count 1)))))
              (process-reader-result reader-result read-count
                                     id output (cdr line) globals)))))
(define (process-key key id output reversed-line reader read-count globals)
  (cond ((= key 10)
         (let ((line (reverse reversed-line)))
           (cond ((and (= (car line) 58) (= read-count 0))
                  (run-cmd id line output globals))
                 ('t (process-input reader read-count
                                    id output line globals)))))
        ('t (main id output reversed-line reader read-count globals))))
(define (main current-id output current-line reader read-count globals)
  (fn (in)
      (cond ((atom in)
             (process-key in current-id output (cons in current-line)
                          reader read-count globals))
            ((= (cadr in) 'define)
             (main current-id
                   (append output "Define: " (symbol->string (car in)) "\n\r")
                   current-line reader read-count
                   (add-global (car in) (caddr in) globals)))
            ((= (cadr in) 'done)
             (main current-id
                   (append output
                           (print (car in)) ": " (caddr in) "\n\r")
                   current-line reader read-count globals))
            ('t (main current-id output current-line
                      reader read-count globals)))))
(define (prompt current-id output globals)
  (append output "expr " (print current-id) "> "
          (main current-id "" "" initial-reader 0 globals)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Informational strings  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (build-init-msg space cmd boot)
  (append "Loaded with " (print space) " free cons cells.\n\r"
          "Arguments: " cmd "\n\r"
          boot))
(define help-str (append "Commands:\n\r"
                         "\t:h - display this help menu\n\r"
                         "\t:l - display license information\n\r"
                         "\t:q - quit\n\r"
                         "\t<EXPR> - evaluate the expression <EXPR>\n\r"))
(define release-str "Omar's REPL, release 20110812.\n\r")
(define gpl-str
  (append release-str
          "Copyright (C) 2004 - 2011 by Omar Jarjur"
          "\n\n\rThis program is free software. You can redistribute "
          "it and/or modify it under the terms of version 2 of the "
          "GNU General Public License as published by the Free "
          "Software Foundation."
          "\n\n\rThis program is distributed in the hope that it will "
          "be useful, but WITHOUT ANY WARRANTY; without even the "
          "implied warranty of MERCHANTABILITY or FITNESS FOR A "
          "PARTICULAR PURPOSE. See the GNU General Public License for "
          "more details."
          "\n\n\rYou should have received a copy of the GNU General "
          "Public License along with this program; if not, write to "
          "the Free Software Foundation, Inc., 59 Temple Place, "
          "Suite 330, Boston, MA 02111-1307 USA\n\r"))
(define boot-str
  (append release-str "System running. Type \":h\" for the help menu.\n\r"))

;; Entry point
(fn (space args)
    (prompt 0 (build-init-msg space args boot-str) initial-globals))
