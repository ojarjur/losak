;; Lambda calculus interpreter.
;; For the sake of asciimation, lambda is spelled "\"
;;  i.e. (\x.\y.\z.z x y) => cons...
(let ((list (fn x x))
      (reverse
        (let ((rrev (fn (rrev list result)
                        (cond ((atom list) result)
                              ('t (rrev rrev (cdr list)
                                             (cons (car list) result)))))))
          (fn (list) (rrev rrev list '()))))
      (append
        (let ((rappend (fn (rappend start end)
                           (cond ((atom start) end)
                                 ('t (cons (car start)
                                           (rappend rappend
                                                    (cdr start) end)))))))
          (fn (start end) (rappend rappend start end))))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Parse a lambda expression string ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (parse (fn (str) (list 'success (append "<INPUT: "
                                              (append (reverse str) ">")))))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Read in a lambda expression ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (read (let ((rread (fn (rread input depth str)
                             (cond ((atom input) (cons input (parse str)))
                                   ((= (car input) '())
                                    (rread rread (cdr input) depth str))
                                   ((= (car input) 40)
                                    (rread rread (cdr input) (+ depth 1)
                                           (cons (car input) str)))
                                   ((= (car input) 41)
                                    (rread rread (cdr input) (- depth 1)
                                           (cons (car input) str)))
                                   ((= depth 0)
                                    (rread rread (cdr input) depth
                                           (cons (car input) str)))
                                   ((= (car input) 10)
                                    (cons (cdr input) (parse str)))
                                   ('t (rread rread (cdr input) depth
                                              (cons (car input) str)))))))
              (fn (input) (rread rread input 0 '()))))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Evaluate a lambda expression ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (eval (fn (expr env) expr))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Print a lambda expression ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (print (fn (expr) expr))

      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      ;; Print a message and call the return continuation ;;
      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      (print_msg
        (let ((rprint (fn (rmain rprint message input)
                          (cond ((atom message) (rmain rmain input))
                                ('t (cons (car message)
                                          (rprint rmain rprint (cdr message)
                                                  input)))))))
          (fn (rmain message input) (rprint rmain rprint message input))))

      ;; Do stuff...
      (rmain (fn (rmain input)
                 (cond ((atom input) '())
                       ('t (let (((other_input status expr) (read input))
                                 (message (cond ((= status 'error)
                                                 "Bad input")
                                                ('t (print (eval expr '()))))))
                             (print_msg rmain (append message "\nInput> ")
                                        other_input)))))))
  (fn (args . input) (print_msg rmain "Welcome! Input> " input)))
