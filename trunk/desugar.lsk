;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Losak compiler                                                  ;;
;;                                                                 ;;
;; This front-end to the compiler removes syntactic sugar and      ;;
;; warns about potential programming errors.                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Copyright (C) 2004 - 2011 by Omar Jarjur                        ;;
;;                                                                 ;;
;; This program is free software; you can redistribute it and/or   ;;
;; modify it under the terms of version 2 of the GNU General       ;;
;; Public License as published by the Free Software Foundation.    ;;
;;                                                                 ;;
;; This program is distributed in the hope that it will be useful, ;;
;; but WITHOUT ANY WARRANTY; without even the implied warranty of  ;;
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ;;
;; GNU General Public License for more details.                    ;;
;;                                                                 ;;
;; You should have received a copy of the GNU General Public       ;;
;; License along with this program; if not, write to the Free      ;;
;; Software Foundation, Inc.,                                      ;;
;; 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (caar x) (car (car x)))
(define (cdar x) (cdr (car x)))
(define (cadr x) (car (cdr x)))
(define (cddr x) (cdr (cdr x)))
(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))

(define (id x) x)
(define (list . args) args)
(define (apply op args) (op . args))
(define (recurse op)
  ((fn (this) (op (fn args ((this this) . args))))
   (fn (this) (op (fn args ((this this) . args))))))
(define (walk head tail test merge ret)
  (fn (tree)
      (cond ((test tree) (ret tree))
            ('t (merge (head tree)
                       ((walk head tail test merge ret)
                        (tail tree)))))))
(define (rreverse list result return)
  (cond ((atom list) (return result))
        ('t (rreverse (cdr list) (cons (car list) result) return))))
(define (reverse list) (rreverse list '() id))
(define (foldl merge end)
  (fn (list)
      (cond ((atom list) end)
            ('t ((foldl merge (merge (car list) end)) (cdr list))))))
(define (foldr merge end)
  (fn (list) (rreverse list '() (foldl merge end))))
(define (append . args) ((foldr (fn (x xs)
                                    (cond ((= xs '()) x)
                                          ('t ((foldr cons xs) x))))
                                '()) args))
(define (equal x y)
  (cond ((atom x) (= x y))
        ((atom y) '())
        ((equal (car x) (car y)) (equal (cdr x) (cdr y)))
        ('t '())))
(define (map op list) ((foldr (fn (x xs) (cons (op x) xs)) '()) list))
(define (or . args) ((foldr (fn (t ts) (cond (t t) ('t ts))) '()) args))
(define (and . args) ((foldr (fn (t ts) (cond (t ts) ('t '()))) 't) args))
(define (not test) (cond (test '()) ('t 't)))
(define (member item list)
  (cond ((atom list) '())
        ((equal item (car list)) list)
        ('t (member item (cdr list)))))

;;;;;;;;;;;;;;;;;;;;
;; Error handling ;;
;;;;;;;;;;;;;;;;;;;;
(define map-to-stderr
  (foldr (fn (char output) (cons (list (cons 2 char)) output)) ()))
(define (print-warnings line-number warnings)
  (cond (warnings (map-to-stderr (append "WARNING; "
                                         "In expression beginning on line "
                                         (print line-number) ": " warnings
                                         "\n")))
        ('t ())))
(define (print-error msg) (map-to-stderr (append "Error; "msg "\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper functions for parsing ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (escape-char char)
  (cond ((= char 116) 9)
        ((= char 114) 13)
        ((= char 110) 10)
        ('t char)))
(define (build-num chars)
  ((foldl (fn (c n) (+ (* 10 n) (- c 48))) 0) chars))
(define (quote-value expr) (list 'quote expr))
(define (quasiquote-value expr) (list 'quasiquote expr))
(define (unquote-value expr) (list 'unquote expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Parser combinators that simplify the process of writting an LL(1) ;;
;; grammar.                                                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Each parser takes a return continuation, an error continuation,   ;;
;; and a current line number. They implement a function that takes   ;;
;; input one character at a time (in curried form), parses the input ;;
;; string, and passes the tree and updated line number to the        ;;
;; return, or "fails" and passes a message to the error.             ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (fail return error line-num) (error line-num))
(define (done return error line-num) (return () line-num))
(define (pop return error line-num)
  (fn (char)
      (cond ((= char '()) (pop return error line-num))
            ((not (number char)) (error line-num))
            ((= char 10) (return char (+ 1 line-num)))
            ('t (return char line-num)))))
(define (check test)
  (fn (return error line-num)
      (pop (fn (val line-num)
               (cond ((test val) (return val line-num))
                     ('t ((error line-num) val))))
           error line-num)))
(define (match char) (check (fn (val) (= val char))))
(define (default parser) (fn (else) parser))
(define (case test then)
  (fn (else)
      (fn (return error line-num)
          (test (fn (val line-num)
                    (then return error line-num))
                (fn (symbols) (else return error line-num))
                line-num))))
(define (choice . args) ((foldr (fn (c cs) (c cs)) fail) args))
(define (post-process parser op)
  (fn (return error line-num)
      (parser (fn (val line-num) (return (op val) line-num))
              error line-num)))
(define (seq parser1 parser2)
  (fn (return error line-num)
      (parser1 (fn (head line-num)
                   (parser2 (fn (tail line-num)
                                (return (cons head tail) line-num))
                            error line-num))
               error line-num)))
(define (escape parser) (seq (post-process pop escape-char) parser))
(define (use parser) (seq pop parser))
(define (peek parser)
  (fn (return error line-num)
      (parser (fn (val new-line-num)
                  ((return val line-num) val))
              error line-num)))
(define (interval start end)
  (check (fn (val) (and (> val (- start 1)) (< val (+ end 1))))))
(define (skip parser) (post-process (use parser) cdr))
(define (first parser1 parser2) (post-process (seq parser1 parser2) car))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to parse an s-expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (parse-num . args)
  (apply (choice (case (peek (interval 48 57)) (use parse-num))
                 (default done))
         args))
(define (read-num . args) (apply (post-process parse-num build-num) args))
(define (parse-symbol . args)
  (apply (choice (case (interval 0 32) done)
                 (case (peek (interval 39 41)) done)
                 (case (peek (match 46)) done)
                 (case (peek (match 59)) done)
                 (default (use parse-symbol)))
         args))
(define (read-symbol . args)
  (apply (post-process parse-symbol string->symbol) args))
(define (parse-string . args)
  (apply (choice (case (match 34) done)
                 (case (match 92) (escape parse-string))
                 (default (use parse-string)))
         args))
(define (quote-parser parser) (post-process parser quote-value))
(define (quasiquote-parser parser) (post-process parser quasiquote-value))
(define (unquote-parser parser) (post-process parser unquote-value))
(define (comment parser)
  (fn args (apply (choice (case (match 10) parser)
                          (case (match 13) parser)
                          (default (skip (comment parser))))
                  args)))
(define (parse-paren . args)
  (apply (choice (case (interval 1 32) parse-paren)
                 (case (match 59) (comment parse-paren))
                 (case (match 41) done))
         args))
(define (parse-pair . args)
  (apply (choice (case (interval 1 32) parse-pair)
                 (case (match 59) (comment parse-pair))
                 (case (match 41) done)
                 (case (match 46) (first parse-expr parse-paren))
                 (default (seq parse-expr parse-pair)))
         args))
(define (parse-expr . args)
  (apply (choice (case (interval 1 32) parse-expr)
                 (case (match 34) (quote-parser parse-string))
                 (case (match 39) (quote-parser parse-expr))
                 (case (match 96) (quasiquote-parser parse-expr))
                 (case (match 44) (unquote-parser parse-expr))
                 (case (match 40) parse-pair)
                 (case (match 41) fail)
                 (case (match 46) fail)
                 (case (match 59) (comment parse-expr))
                 (case (peek (interval 48 57)) read-num)
                 (default read-symbol))
         args))
(define (read-expr cont line-number)
  (parse-expr cont (fn (end-line)
                       (print-error (append "Parse error, line "
                                            (print-num line-number)
                                            " -> line "
                                            (print-num end-line)
                                            "\n")))
              line-number))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to print s-expressions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (build-num-str num)
  ((walk (fn (n) (% n 10))
         (fn (n) (/ n 10))
         (fn (n) (= n 0))
         (fn (d op) (fn (str) (op (cons (+ d 48) str))))
         (fn (x) id))
   num))
(define (print-num num)
  (cond ((< num 0) (cons 45 ((build-num-str (- num)) "")))
        ((= num 0) "0")
        ('t ((build-num-str num) ""))))
(define (print-atom expr)
  (cond ((number expr) (print-num expr))
        ((symbol? expr) (symbol->string expr))
        ('t "<INTERNAL ERROR>")))
(define (print-tail expr suffix)
  (cond ((= expr '()) (append ")" suffix))
        ((atom expr) (append " . " (print-atom expr) ")" suffix))
        ('t (append " " (print-with-suffix (car expr)
                                           (print-tail (cdr expr) suffix))))))
(define (print-with-suffix expr suffix)
  (cond ((= expr '()) (append "()" suffix))
        ((atom expr) (append (print-atom expr) suffix))
        ('t (append "(" (print-with-suffix (car expr)
                                           (print-tail (cdr expr) suffix))))))
(define (print-with-newline expr) (print-with-suffix expr "\n"))
(define (print expr) (print-with-suffix expr ""))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to remove syntactic sugar ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define special-forms
  '(quote quasiquote unquote let if define cond fn))
(define supported-builtins
  '(cons car cdr atom number function = < > + - * / % ~ & | ^ >> >>> <<
         symbol? symbol->string string->symbol))
(define (flatten input-tree output-list)
  (cond ((= input-tree '()) output-list)
        ((symbol? input-tree) (cons input-tree output-list))
        ((atom input-tree) (cons input-tree output-list))
        ('t (flatten (car input-tree)
                     (flatten (cdr input-tree) output-list)))))
(define (escape-symbols expr)
  (cond ((atom expr)
         (cond ((member expr special-forms) expr)
               ((member expr supported-builtins) expr)
               ((symbol? expr) (string->symbol (append "_" (symbol->string expr))))
               ('t expr)))
        ('t (cons (escape-symbols (car expr))
                  (escape-symbols (cdr expr))))))

(define (compile-find var env globals next-id return)
  (cond ((member var (flatten env globals))
         (return '() (escape-symbols var) "" next-id))
        ((member var supported-builtins)
         (return '() var "" next-id))
        ((member var special-forms)
         (return '() var "" next-id))
        ('t (return '() '()
                    (append "Unknown var \""
                            (symbol->string var)
                            "\" will evaluate to NIL.")
                    next-id))))

(define (rewrite-quote expression)
  (cond ((= expression '()) expression)
        ((number expression) expression)
        ((atom expression) (list 'quote expression))
        ('t (list 'cons
                  (rewrite-quote (car expression))
                  (rewrite-quote (cdr expression))))))
(define (compile-quote expr next-id return)
  (let ((literal-symbol (string->symbol (append "l_" (print next-id)))))
    (return `((define ,literal-symbol ,expr))
            literal-symbol
            ""
            (+ 1 next-id))))
(define (rewrite-quasiquote expression depth env globals next-id return)
  (cond ((number expression) (return '() expression "" next-id))
        ((atom expression)
         (return '() (list 'quote expression) "" next-id))
        ((= (car expression) 'unquote)
         (cond ((= depth 0)
                (compile-expr (cadr expression) env globals next-id return))
               ('t (rewrite-quasiquote (cadr expression) (- depth 1)
                                       env globals next-id
                                       (fn (definitions body warnings next-id)
                                           (return definitions
                                                   (list 'unquote body)
                                                   warnings
                                                   next-id))))))
        ((= (car expression) 'quasiquote)
         (rewrite-quasiquote (cadr expression) (+ depth 1)
                             env globals next-id
                             (fn (definitions body warnings next-id)
                                 (return definitions
                                         (list 'quasiquote body)
                                         warnings
                                         next-id))))
        ('t (let (((car-definitions car-body car-warnings next-id)
                   (rewrite-quasiquote (car expression) depth env globals
                                       next-id list))
                  ((cdr-definitions cdr-body cdr-warnings next-id)
                   (rewrite-quasiquote (cdr expression) depth env globals
                                       next-id list)))
              (return (append car-definitions cdr-definitions)
                      (list 'cons car-body cdr-body)
                      (append car-warnings cdr-warnings)
                      next-id)))))
(define (always-true expr)
  (cond ((symbol? expr) '())
        ((atom expr) expr)
        ((not (= (car expr) 'quote)) '())
        ((= (cdr expr) '()) '())
        ('t 't)))
(define (rewrite-cond cases env globals next-id return)
  (cond ((atom cases) (return '() '() "Unhandled cond default. " next-id))
        ((always-true (caar cases))
         (compile-expr (cadar cases) env globals next-id return))
        ('t (let (((test-definitions test-body test-warnings next-id)
                   (compile-expr (caar cases) env globals
                                 next-id list))
                  ((then-definitions then-body then-warnings next-id)
                   (compile-expr (cadar cases) env globals
                                 next-id list))
                  ((else-definitions else-body else-warnings next-id)
                   (rewrite-cond (cdr cases) env globals
                                 next-id list)))
              (return (append test-definitions
                              then-definitions
                              else-definitions)
                      (list 'if test-body then-body else-body)
                      (append test-warnings
                              then-warnings
                              else-warnings)
                      next-id)))))
(define (rewrite-let bindings expr)
  (cond ((atom bindings) expr)
        ('t (list (list 'fn (list (caar bindings))
                        (rewrite-let (cdr bindings) expr))
                  (cadar bindings)))))
(define (compile-args args env globals next-id return)
  (cond ((atom args) (compile-expr args env globals next-id return))
        ('t (let (((arg-definitions arg-body arg-warnings next-id)
                   (compile-expr (car args) env globals next-id list))
                  ((args-definitions args-body args-warnings next-id)
                   (compile-args (cdr args) env globals next-id list)))
              (return (append arg-definitions args-definitions)
                      (cons arg-body args-body)
                      (append arg-warnings args-warnings)
                      next-id)))))
(define (compile-expr expr env globals next-id return)
  (cond ((symbol? expr) (compile-find expr env globals next-id return))
        ((atom expr) (return '() expr "" next-id))
        ((= (car expr) 'quote) (compile-quote expr next-id return))
        ((= (car expr) 'quasiquote)
         (rewrite-quasiquote (cadr expr) 0 env globals
                             next-id return))
        ((= (car expr) 'unquote)
         (compile-expr (cadr expr) env globals next-id
                       (fn (definitions body warnings next-id)
                           (return definitions
                                   body
                                   (append "Unquote outside of quasiquote"
                                           warnings)
                                   next-id))))
        ((= (car expr) 'cond)
         (rewrite-cond (cdr expr) env globals next-id return))
        ((= (car expr) 'let)
         (compile-expr (rewrite-let (cadr expr) (caddr expr))
                       env globals next-id return))
        ((= (car expr) 'fn)
         (compile-expr (caddr expr) (cons (cadr expr) env)
                       globals next-id
                       (fn (definitions body warnings next-id)
                           (return definitions
                                   (list 'fn (escape-symbols (cadr expr)) body)
                                   warnings
                                   next-id))))
        ('t (compile-args expr env globals next-id return))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile expressions to coroutines ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (get-name (line-number . definition))
  (cond ((atom (cadr definition)) (cadr definition))
        ('t (caadr definition))))
(define (get-body (line-number . definition))
  (cond ((atom (cadr definition)) (caddr definition))
        ('t (list 'fn (cdr (cadr definition)) (caddr definition)))))
(define (compile-definition definition globals next-id return)
  (let ((line-number (car definition))
        (name (get-name definition))
        (body (get-body definition)))
    (compile-expr body '() globals next-id
                  (fn (definitions compiled-body warnings next-id)
                      (append (print-warnings line-number warnings)
                              (apply append
                                     (map print-with-newline definitions))
                              (print-with-newline `(define
                                                     ,(escape-symbols name)
                                                     ,compiled-body))
                              (return next-id))))))
(define (compile-definitions definitions globals next-id return)
  (if (atom definitions)
      (return next-id)
      (compile-definition (car definitions) globals next-id
                          (fn (next-id)
                              (compile-definitions (cdr definitions) globals
                                                   next-id return)))))
(define (compile definitions expr line-number)
  (let ((globals (map get-name definitions))
        ((body-definitions body-code warnings next-id)
         (compile-expr expr '() globals 1 list)))
    (compile-definitions definitions globals next-id
                         (fn (next-id)
                             (append (print-warnings line-number warnings)
                                     (apply append
                                            (map print-with-newline
                                                 body-definitions))
                                     (print-with-newline body-code))))))

;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the input ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (compile-source definitions start-line-number)
  (fn (value symbol-table end-line-number)
    (cond ((not value)
           (print-error "No main expression"))
          ((not (= (car value) 'define))
           (compile (reverse definitions) value start-line-number))
          ((not (or (atom (cadr value)) (atom (caadr value))))
           (print-error "Malformed define statement"))
          ('t (read-expr (compile-source (cons (cons start-line-number value)
                                               definitions)
                                         end-line-number)
                         end-line-number)))))
(fn (size arguments) (read-expr (compile-source '() 1) 1))
