;; Compiler from a simple lisp-dialect to C
;;
;; The basis for this compiler is the invariant* that for each type
;; of s-expression, that s-expression is compiled into C code that
;; stores the evaluated result of the s-expression into the C global
;; variable "val", while leaving the variables "args", "stack", and
;; "call_stack" with the same values before and after computation.
;;
;; (*May be violated if the system runs out of free memory)
;;
;; The following C types must be externally defined:
;;   pointer,      //HINT: typedef long int pointer;
;;   function_addr //HINT: typedef void (*function_addr)();
;;
;; The following C globals must be externally defined:
;;   int sign_mask
;;   pointer val, args, stack, call_stack, true
;;
;; The following C functions must be defined in another file:
;;   pointer cons(pointer expr1, pointer expr2)
;;   pointer car(pointer expr)
;;   pointer cdr(pointer expr)
;;
;;   pointer new_number(int value)
;;   int value(pointer n)
;;
;;   pointer new_function(function_addr addr, pointer binding_env)
;;   function_addr addr(pointer func)
;;   pointer binding_env(pointer func)
;;
;;   void increment_count(pointer expr)
;;   void decrement_count(pointer expr)
;;
;;   int eq(pointer expr1, pointer expr2)
;;   int length(pointer expr)
;;   int is_atom(pointer expr)
;;   int is_number(pointer expr)
;;   int is_function(pointer expr)
;;
;;   pointer eval_primitive(pointer op, pointer args)
;;
;;   void end_function()

(define (caar x) (car (car x)))
(define (cdar x) (cdr (car x)))
(define (cadr x) (car (cdr x)))
(define (cddr x) (cdr (cdr x)))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (id x) x)
(define (list . args) args)
(define (apply op args) (op . args))
(define (recurse op)
  ((fn (this) (op (fn args ((this this) . args))))
   (fn (this) (op (fn args ((this this) . args))))))
(define (walk head tail test merge ret)
  (fn (tree)
      (cond ((test tree) (ret tree))
            ('t (merge (head tree)
                       ((walk head tail test merge ret)
                        (tail tree)))))))
(define (rreverse list result return)
  (cond ((atom list) (return result))
        ('t (rreverse (cdr list) (cons (car list) result) return))))
(define (reverse list) (rreverse list '() id))
(define (foldl merge end)
  (fn (list)
      (cond ((atom list) end)
            ('t ((foldl merge (merge (car list) end)) (cdr list))))))
(define (foldr merge end)
  (fn (list) (rreverse list '() (foldl merge end))))
(define (append . args) ((foldr (fn (x xs)
                                    (cond ((= xs '()) x)
                                          ('t ((foldr cons xs) x))))
                                '()) args))
(define (equal x y)
        (cond ((atom x) (= x y))
              ((atom y) '())
              ((equal (car x) (car y)) (equal (cdr x) (cdr y)))
              ('t '())))
(define (map op list) ((foldr (fn (x xs) (cons (op x) xs)) '()) list))
(define (or . args) ((foldr (fn (t ts) (cond (t t) ('t ts))) '()) args))
(define (and . args) ((foldr (fn (t ts) (cond (t ts) ('t '()))) 't) args))
(define (not test) (cond (test '()) ('t 't)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for maintaining the symbol table ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (make-symbol id str) (fn (op) (op id str)))
(define (symbol->id symbol) (symbol (fn (id str) id)))
(define (symbol->string symbol) (symbol (fn (id str) str)))
(define (lookup string curr table count return)
  (cond ((atom curr) (return count (cons (cons string count) table)))
        ((equal (caar curr) string) (return (cdar curr) table))
        ('t (lookup string (cdr curr) table (+ count 1) return))))
(define (get-symbol string table return)
  (lookup string table table 4 ;; Symbols 0-3 are reserved for the compiler
          (fn (id new-table) (return (make-symbol id string) new-table))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper functions for parsing ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (escape-char char return symbols line-num)
  (return (cond ((= char 116) 9)
                ((= char 114) 13)
                ((= char 110) 10)
                ('t char))
          symbols line-num))
(define (build-num chars return symbols line-num)
  (return ((foldl (fn (c n) (+ (* 10 n) (- c 48))) 0) chars)
          symbols line-num))
(define (drop-first pair return symbols line-num)
  (return (cdr pair) symbols line-num))
(define (drop-second pair return symbols line-num)
  (return (car pair) symbols line-num))
(define (quote-value expr return symbols line-num)
  (return (list 'quote expr) symbols line-num))
(define (lookup-symbol chars return symbols line-num)
  (cond ((equal chars "cond") (return 'cond symbols line-num))
        ((equal chars "if") (return 'if symbols line-num))
        ((equal chars "let") (return 'let symbols line-num))
        ((equal chars "fn") (return 'fn symbols line-num))
        ((equal chars "quote") (return 'quote symbols line-num))
        ((equal chars "unquote") (return 'unquote symbols line-num))
        ((equal chars "quasiquote") (return 'quasiquote symbols line-num))
        ((equal chars "cons") (return 'cons symbols line-num))
        ((equal chars "car") (return 'car symbols line-num))
        ((equal chars "cdr") (return 'cdr symbols line-num))
        ((equal chars "atom") (return 'atom symbols line-num))
        ((equal chars "number") (return 'number symbols line-num))
        ((equal chars "function") (return 'function symbols line-num))
        ((equal chars "=") (return '= symbols line-num))
        ((equal chars "<") (return '< symbols line-num))
        ((equal chars ">") (return '> symbols line-num))
        ((equal chars "+") (return '+ symbols line-num))
        ((equal chars "-") (return '- symbols line-num))
        ((equal chars "*") (return '* symbols line-num))
        ((equal chars "/") (return '/ symbols line-num))
        ((equal chars "%") (return '% symbols line-num))
        ((equal chars "~") (return '~ symbols line-num))
        ((equal chars "&") (return '& symbols line-num))
        ((equal chars "|") (return '| symbols line-num))
        ((equal chars "^") (return '^ symbols line-num))
        ((equal chars ">>") (return '>> symbols line-num))
        ((equal chars ">>>") (return '>>> symbols line-num))
        ((equal chars "<<") (return '<< symbols line-num))
        ((equal chars "define") (return 'define symbols line-num))
        ('t (get-symbol chars symbols
                        (fn (id new-symbols)
                          (return id new-symbols line-num))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Parser combinators that simplify the process of writting an LL(1) ;;
;; grammar.                                                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Each parser takes a return continuation, an error continuation,   ;;
;; an input string, and a symbol table. They implement a function    ;;
;; that parses the string, and passes the tree, remaining chars, and ;;
;; new symbol table to the return, or "fails" and passes a message,  ;;
;; the remaining chars, and new symbol table to the error.           ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (fail return error symbols line-num) (error symbols))
(define (done return error symbols line-num)
  (return '() symbols line-num))
(define (pop return error symbols line-num)
  (fn (char)
      (cond ((not (number char)) (error symbols))
            ((= char 10)
             (return char symbols (+ 1 line-num)))
            ('t (return char symbols line-num)))))
(define (check test)
  (fn (return error symbols line-num)
      (pop (fn (val symbols line-num)
               (cond ((test val) (return val symbols line-num))
                     ('t ((error symbols) val))))
           error symbols line-num)))
(define (match char) (check (fn (val) (= val char))))
(define (default parser) (fn (else) parser))
(define (case test then)
  (fn (else)
      (fn (return error symbols line-num)
          (test (fn (val symbols line-num)
                    (then return error symbols line-num))
                (fn (symbols) (else return error symbols line-num))
                symbols line-num))))
(define (choice . args) ((foldr (fn (c cs) (c cs)) fail) args))
(define (post-process parser op)
  (fn (return error symbols line-num)
      (parser (fn (val symbols line-num)
                  (op val return symbols line-num))
              error symbols line-num)))
(define (seq parser1 parser2)
  (fn (return error symbols line-num)
      (parser1 (fn (head symbols line-num)
                   (parser2 (fn (tail symbols line-num)
                                (return (cons head tail) symbols line-num))
                            error symbols line-num))
               error symbols line-num)))
(define (escape parser) (seq (post-process pop escape-char) parser))
(define (use parser) (seq pop parser))
(define (peek parser)
  (fn (return error symbols line-num)
      (parser (fn (val symbols new-line-num)
                  ((return val symbols line-num) val))
              error symbols line-num)))
(define (interval start end)
  (check (fn (val) (and (> val (- start 1)) (< val (+ end 1))))))
(define (skip parser) (post-process (use parser) drop-first))
(define (first parser1 parser2)
  (post-process (seq parser1 parser2) drop-second))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to parse an s-expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (parse-num . args)
  (apply (choice (case (peek (interval 48 57)) (use parse-num))
                 (default done))
         args))
(define (read-num . args) (apply (post-process parse-num build-num) args))
(define (parse-symbol . args)
  (apply (choice (case (peek (interval 0 32)) done)
                 (case (peek (interval 39 41)) done)
                 (case (peek (match 46)) done)
                 (case (peek (match 59)) done)
                 (default (use parse-symbol)))
         args))
(define (read-symbol . args)
  (apply (post-process parse-symbol lookup-symbol) args))
(define (parse-string . args)
  (apply (choice (case (match 34) done)
                 (case (match 92) (escape parse-string))
                 (default (use parse-string)))
         args))
(define (quote-parser parser) (post-process parser quote-value))
(define (comment parser)
  (fn args (apply (choice (case (match 10) parser)
                          (case (match 13) parser)
                          (default (skip (comment parser))))
                  args)))
(define (parse-paren . args)
  (apply (choice (case (interval 1 32) parse-paren)
                 (case (match 59) (comment parse-paren))
                 (case (match 41) done))
         args))
(define (parse-pair . args)
  (apply (choice (case (interval 1 32) parse-pair)
                 (case (match 59) (comment parse-pair))
                 (case (match 41) done)
                 (case (match 46) (first parse-expr parse-paren))
                 (default (seq parse-expr parse-pair)))
         args))
(define (parse-expr . args)
  (apply (choice (case (interval 1 32) parse-expr)
                 (case (match 34) (quote-parser parse-string))
                 (case (match 39) (quote-parser parse-expr))
                 (case (match 40) parse-pair)
                 (case (match 41) fail)
                 (case (match 46) fail)
                 (case (match 59) (comment parse-expr))
                 (case (peek (interval 48 57)) read-num)
                 (default read-symbol))
         args))
(define (read-expr cont symbol-table line-number)
  (parse-expr cont (fn (symbols)
                       (print-error (append "Parse error, line "
                                            (number->string line-number)
                                            "\n")))
              symbol-table line-number))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for structuring the generated code ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (code_block . lines)
  (fn (prefix postfix)
      ((foldr (fn (block postfix)
                  (cond ((function block) (block prefix postfix))
                        ('t (append prefix block "\n" postfix))))
              postfix)
       lines)))
(define (indent . code)
  (fn (prefix postfix)
      (let ((new-prefix (append "  " prefix)))
        ((foldr (fn (block postfix)
                    (cond ((function block) (block new-prefix postfix))
                          ('t (append new-prefix block "\n" postfix))))
                postfix)
         code))))
(define (build_num_str n)
  (((walk (fn (n) (% n 10))
          (fn (n) (/ n 10))
          (fn (n) (= n 0))
          (fn (d op) (fn (str) (op (cons (+ d 48) str))))
          (fn (x) id))
    n)
   ""))
(define (number->string num)
  (cond ((< num 0) (cons 45 (build_num_str (- num))))
        ((= num 0) '(48))
        ('t (build_num_str num))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Variables for maintaining the symbol table ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (compile_symbol sym)
  (cond ((= sym 'cons) "CONS")
        ((= sym 'car) "CAR")
        ((= sym 'cdr) "CDR")
        ((= sym 'cond) "COND")
        ((= sym 'if) "IF")
        ((= sym 'atom) "ATOM")
        ((= sym 'number) "NUMBER")
        ((= sym 'function) "FUNCTION")
        ((= sym 'quote) "QUOTE")
        ((= sym 'quasiquote) "QUASIQUOTE")
        ((= sym 'unquote) "UNQUOTE")
        ((= sym 'fn) "FN")
        ((= sym 'let) "LET")
        ((= sym '=) "EQ")
        ((= sym '<) "LT")
        ((= sym '>) "GT")
        ((= sym '+) "PLUS")
        ((= sym '-) "MINUS")
        ((= sym '*) "MULT")
        ((= sym '/) "DIV")
        ((= sym '%) "MOD")
        ((= sym '~) "BNEG")
        ((= sym '&) "BAND")
        ((= sym '|) "BOR")
        ((= sym '^) "BXOR")
        ((= sym '>>) "SRSHIFT")
        ((= sym '>>>) "URSHIFT")
        ((= sym '<<) "LSHIFT")
        ((= sym 'define) "DEFINE")
        ((= sym '()) "NIL")
        ('t "/** Internal Error: unknown symbol */NIL")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function to compile compile-time data ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (compile-literal-list expr cont)
  (cond ((atom expr) (code_block (compile-literal expr)
                                 "push_args();"
                                 "args = val;"
                                 cont))
        ('t (compile-literal-list (cdr expr)
                                  (code_block (compile-literal (car expr))
                                              "args = cons(val, args);"
                                              cont)))))
(define (compile-literal expr)
  (cond ((number expr)
         (append "val = new_number(" (number->string expr) ");"))
        ((function expr)
         (append "val = " (number->string (- (- 34) (symbol->id expr))) ";"))
        ((atom expr) (append "val = " (compile_symbol expr) ";"))
        ('t (compile-literal-list expr (code_block "val = args;"
                                                   "args = NIL;"
                                                   "pop_args();")))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for handling primitives ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (is_primitive expr)
  (or (= expr 'car) (= expr 'cdr) (= expr 'cons) (= expr 'atom)
      (= expr 'number) (= expr 'function) (= expr '=) (= expr '<)
      (= expr '>) (= expr '+) (= expr '-) (= expr '*) (= expr '/)
      (= expr '%) (= expr '~) (= expr '&) (= expr '|) (= expr '^)
      (= expr '>>) (= expr '>>>) (= expr '<<)))
(define (compile_primitive op)
  (cond ((or (= op 'car) (= op 'cdr) (= op 'atom)
             (= op 'number) (= op 'function) (= op '~))
         (code_block
          "if (length(args) == 1) {"
          (indent (cond ((= op 'atom)
                         (code_block
                          "if (is_atom(car(args))) {"
                          (indent "increment_count(val = true); ")
                          "} else { val = NIL; }"))
                        ((= op 'number)
                         (code_block
                          "if (is_number(car(args))) {"
                          (indent "increment_count(val = true);")
                          "} else { val = NIL; }"))
                        ((= op 'function)
                         (code_block
                          "if (is_function(car(args))) {"
                          (indent "increment_count(val = true);")
                          "} else { val = NIL; }"))
                        ((= op '~)
                         (code_block
                          "if (is_number(car(args))) {"
                          (indent "val = new_number(~(value(car(args))));")
                          "} else { val = NIL; }"))
                        ('t (code_block
                             "if (! is_atom(car(args))) {"
                             (cond ((= op 'car)
                                    "increment_count(val = car(car(args)));")
                                   ('t ;; (= op 'cdr)
                                    "increment_count(val = cdr(car(args)));"))
                             "} else { val = NIL; }"))))
          "} else { val = NIL; }"))
                  ((or (= op '+) (= op '*) (= op '/) (= op '%)
             (= op '&) (= op '|) (= op '^) (= op '>>)
             (= op '<<) (= op '>>>) (= op '>) (= op '<))
         (code_block
          "if ((length(args) == 2) &&"
          "    (is_number(car(args))) &&"
          "    (is_number(car(cdr(args))))) {"
          (indent (cond ((= op '+)
                         "val = new_number(value(car(args)) + value(car(cdr(args)))); ")
                        ((= op '*)
                         "val = new_number(value(car(args)) * value(car(cdr(args)))); ")
                        ((= op '/)
                         (code_block
                          "if (value(car(cdr(args))) == 0) {"
                          (indent "val = NIL;")
                          "} else {"
                          (indent "val = new_number(value(car(args)) / "
                                  "                 value(car(cdr(args))));")
                          "}"))
                        ((= op '%)
                         (code_block
                          "if (value(car(cdr(args))) == 0) {"
                          (indent "val = NIL;")
                          "} else {"
                          (indent "val = new_number(value(car(args)) %"
                                  "                 value(car(cdr(args))));")
                          "}"))
                        ((= op '&)
                         "val = new_number(value(car(args)) & value(car(cdr(args)))); ")
                        ((= op '|)
                         "val = new_number(value(car(args)) | value(car(cdr(args)))); ")
                        ((= op '^)
                         "val = new_number(value(car(args)) ^ value(car(cdr(args)))); ")
                        ((= op '>>)
                         (code_block "val = new_number(value(car(args)) >> "
                                     "                 value(car(cdr(args))));"))
                        ((= op '>>>)
                         (code_block "val = new_number(((sign_mask >> "
                                     "                   value(car(cdr(args))) - 1) ^ -1) & "
                                     "                 (value(car(args)) >> "
                                     "                  value(car(cdr(args))))); "))
                        ((= op '<<)
                         (code_block "val = new_number(value(car(args)) << "
                                     "                 value(car(cdr(args)))); "))
                        ((= op '>)
                         (code_block
                          "if (value(car(args)) > value(car(cdr(args)))) {"
                          (indent "increment_count(val = true);")
                          "} else { val = NIL; }"))
                        ('t ;; (= op '<)
                         (code_block
                          "if (value(car(args)) < value(car(cdr(args)))) {"
                          (indent "increment_count(val = true);")
                          "} else { val = NIL; }"))))
          "} else { val = NIL; }"))
        ((= op '-)
         (code_block "if (is_number(car(args))) {"
                     (indent "if ((length(args) == 2) &&"
                             "    is_number(car(cdr(args)))) {"
                             (indent "val = new_number(value(car(args)) - "
                                     "                 value(car(cdr(args))));")
                             "} else if (length(args) == 1) {"
                             (indent "val = new_number(-value(car(args)));")
                             "} else { val = NIL; }")
                     "} else { val = NIL; }"))
        ((= op '=)
         (code_block "if ((length(args) == 2) &&"
                     "    (is_atom(car(args))) &&"
                     "    (is_atom(car(cdr(args)))) &&"
                     "    eq(car(args), car(cdr(args)))) {"
                     (indent "increment_count(val = true);")
                     "} else { val = NIL; }"))
        ((= op 'cons)
         (code_block "if (length(args) == 2) {"
                     (indent "increment_count(car(args));"
                             "increment_count(car(cdr(args)));"
                             "val = cons(car(args), car(cdr(args)));")
                     "} else { val = NIL; }"))
        ('t "/** Internal Error: unknown primitive */ val = NIL;")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile an if expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (then-else-block then-code else-code)
  (code_block "if (val != NIL) {"
              (indent "decrement_count(val);" then-code)
              "} else {"
              (indent else-code)
              "}"))
(define (compile_if test then else env cont return_cont labels methods return)
  (compile_expr then env cont labels methods
                (fn (then-code labels methods)
                    (compile_expr else env cont labels methods
                                  (fn (else-code labels methods)
                                      (let ((new_cont
                                             (then-else-block then-code
                                                              else-code)))
                                        (compile_expr test env new_cont
                                                      labels methods
                                                      return)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile a list of arguments ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (compile_args args env cont labels methods return)
  (cond ((atom args)
         (let ((new_cont (code_block "args = val;" cont)))
           (compile_expr args env new_cont labels methods return)))
        ('t (compile_expr (car args) env
                          (code_block "args = cons(val, args);" cont)
                          labels methods
                          (fn (new_cont labels methods)
                            (compile_args (cdr args) env new_cont
                                          labels methods return))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile a function body ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (add_method_return return)
  (fn (function_name methods labels)
    (return (code_block "increment_count(env);"
                        (append "val = new_function(" function_name ", env);"))
            labels
            methods)))
(define (compile_fn body env labels methods return)
  (cond ((or (atom body) (atom (cdr body)))
         (return "/** Warning, malformed function */ val = NIL;"
                 labels methods))
        ('t (let ((local_env (bind (car body) env))
                  (expr (car (cdr body))))
              (compile_expr expr local_env '() labels methods
                            (fn (compiled_body labels methods)
                              (add_function compiled_body labels methods
                                            (add_method_return return))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the application of an unknown function to a list of arguments. ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (apply_return op arg_list env top_level call_cont methods labels return)
  (compile_expr op env call_cont labels methods
                (fn (call_body labels methods)
                    (compile_args arg_list env call_body labels methods
                                  (fn (apply_body labels methods)
                                      (return (code_block "push_args();"
                                                          apply_body)
                                              labels
                                              methods))))))
(define (compile_apply op args env return_cont top_level labels methods return)
  (cond (top_level (apply_return op args env top_level "top_level_apply();"
                                 methods labels return))
        ('t (add_function return_cont labels methods
                          (fn (return_body methods labels)
                              (apply_return op args env top_level
                                            (append "apply(" return_body ");")
                                            methods labels return))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the application of a primitive operation to a list of arguments, ;;
;; when the operation applied is known at compile-time.                     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (compile_apply_primitive op args env cont labels methods return)
  (let ((return_body (code_block (compile_primitive op)
                                 "pop_args();"
                                 cont)))
    (compile_args args env return_body labels methods
                  (fn (apply_body labels methods)
                    (return (code_block "push_args();" apply_body)
                            labels
                            methods)))))

;;;;;;;;;;;;;;;;;;;;
;; Compile a pair ;;
;;;;;;;;;;;;;;;;;;;;
(define (compile_pair op expr env cont return_cont labels methods return)
  (cond ((= op 'if)
         (compile_if (car expr) (cadr expr) (caddr expr)
                     env cont return_cont labels methods return))
        ((= op 'quote)
         (return (code_block (compile-literal (car expr)) return_cont)
                 labels
                 methods))
        ((= op 'fn)
         (compile_fn expr env labels methods
                     (fn (fn_call labels methods)
                       (return (code_block fn_call return_cont)
                               labels methods))))
        ((= op 'define) (print-error "Illegal, nested define statement"))
        ((is_primitive op)
         (compile_apply_primitive op expr env return_cont labels methods return))
        ('t (compile_apply op expr env return_cont (= cont '())
                           labels methods return))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile an expression using a series of global function definitions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (definition-names definitions)
  ((foldr (fn (def names) (cons (cadr def) names)) '()) definitions))
(define (definition-bodies definitions)
  ((foldr (fn (def bodies) (cons (caddr def) bodies)) '()) definitions))
(define (build-declarations names)
  ((foldr (fn (name decls)
              (code_block (append "pointer global_"
                                  (number->string (symbol->id name))
                                  " = NIL;") decls))
         '())
   names))
(define (compile-defs names bodies labels methods main_block return)
  (cond ((atom names) (return main_block labels methods))
        ('t (compile_expr (car bodies) '()
                          (code_block (append "global_"
                                              (number->string (symbol->id (car names))) " = val;")
                                      main_block)
                          labels methods
                          (fn (code labels methods)
                              (compile-defs (cdr names) (cdr bodies) labels
                                            methods code return))))))
(define (compile-definitions definitions expr labels methods return)
  (let ((names (definition-names definitions))
        (bodies (definition-bodies definitions))
        (prefix (build-declarations names)))
    (compile_expr expr '() '() labels
                  (cons prefix methods)
                  (fn (code labels methods)
                      (compile-defs names bodies labels
                                    methods code return)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile an s-expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (compile_expr expr env cont labels methods return)
  (let ((return_cont (cond ((= cont '()) "pop_function();")
                           ('t cont))))
    (cond ((function expr)
           (return (code_block (find expr env labels) return_cont)
                   labels methods))
          ((not (atom expr))
           (compile_pair (car expr) (cdr expr) env cont
                         return_cont labels methods return))
          ('t (return (code_block (compile-literal expr) return_cont)
                      labels methods)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Variables for maintaining the list of function headers/bodies ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (empty_labels initial)
  (fn (op) (op initial '())))
(define (get_next_label labels)
  (labels (fn (label-count label-map) label-count)))
(define (get_label_map labels)
  (labels (fn (label-count label-map) label-map)))
(define (add_label labels)
  (let ((label_count (+ (get_next_label labels) 1))
        (label_map (get_label_map labels)))
    (fn (op) (op label_count label_map))))
(define (next_label->string labels)
  (number->string (get_next_label labels)))
(define (add_function body labels methods return)
  (return (append "(&function_" (next_label->string labels) ")")
          (cons (code_block (append "void function_"
                                    (next_label->string labels)
                                    "() {")
                            (indent body)
                            "}")
                methods)
          (add_label labels)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; The skeleton of the code generation ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (main_body apply_main function_name)
  (code_block "#ifdef BARE_HARDWARE"
              "void main (unsigned long magic, multiboot_data* boot_data) {"
              (indent "int i = 0;"
                      "if ((magic == BOOT_MAGIC) &&"
                      "    getFlag(boot_data->flags, 0)) {"
                      (indent "init_mem((void*)0x200000, ((boot_data->mem_upper*1024) - 0x100000));"
                              "init_io();"
                              "init_eval();"
                              "arguments = get_cmd(boot_data->flags, (char*)(boot_data->cmd_line));"
                              (append "call_stack = "
                                      "cons(new_function((&top_level), NIL),"
                                      " call_stack);")
                              (append "call_stack = "
                                      "cons(new_function("
                                      apply_main ", NIL),"
                                      " call_stack);")
                              (append "return_location = "
                                      function_name ";")
                              "while (return_location != (&end_function)) {"
                              (indent "(*return_location)();")
                              "}"
                              "end_function();")
                      "} else {"
                      "  error(ERR_BAD_BOOT);"
                      "}")
               "}"
              "#else"
              "int main(int argc, char** argv) {"
              (indent "pointer memory_limit = 64 * 1024 * 1024;"
                      "void* memory = malloc(memory_limit);"
                      "init_mem(memory, memory_limit);"
                      "init_io();"
                      "init_eval();"
                      (append "call_stack = "
                              "cons(new_function((&top_level), NIL),"
                              " call_stack);")
                      (append "call_stack = "
                              "cons(new_function(" apply_main ", NIL),"
                              " call_stack);")   
                      (append "return_location = "
                              function_name ";")
                      "while (return_location != (&end_function)) {"
                      (indent "(*return_location)();")
                      "}"
                      "end_function();"
                      "end_io();")
              "}"
              "#endif"))
(define (compile_return apply_main)
  (fn (main_expr labels methods)
    (add_function main_expr labels methods
                  (fn (function_name methods labels)
                    (add-code-header (cons (main_body apply_main function_name)
                                           methods))))))
(define (add-code-header methods)
  (cons (code_block "#ifdef BARE_HARDWARE"
                    "#include \"multiboot.h\""
                    "#else"
                    "#include <stdlib.h>"
                    "#endif"
                    "#include \"io.h\""
                    "#include \"mem.h\""
                    "#include \"eval.h\""
                    "pointer arguments = NIL;"
                    "#ifdef BARE_HARDWARE"
                    "pointer get_cmd(unsigned long flags, char* command) {"
                    "  pointer r = NIL;"
                    "  int i = 0;"
                    "  if (getFlag(flags,2) != 0) {"
                    "    while ((command > 0) && (command[i] != '\\0')) {"
                    "      i++;"
                    "    }"
                    "    while (i > 0) {"
                    "      i--;"
                    "      r = cons(new_number(command[i]), r);"
                    "    }"
                    "  }"
                    "  return r;"
                    "}"
                    "#endif"
                    "inline void pop_function() {"
                    (indent "decrement_count(env);"
                            "temp = car(call_stack);"
                            "if (is_function(temp)) {"
                            (indent "env = environment(temp);"
                                    "increment_count(env);"
                                    "return_location = address(temp);")
                            "} else {"
                            (indent "error(ERR_INTERNAL);"
                                    "env = NIL;"
                                    "return_location = (&end_function);")
                            "}"
                            "increment_count(temp = cdr(call_stack));"
                            "decrement_count(call_stack);"
                            "call_stack = temp;")
                    "}"
                    "inline void push_args() {"
                    (indent "stack = cons(args, stack);")
                    "}"
                    "inline void pop_args() {"
                    (indent "decrement_count(args);"
                            "increment_count(args = car(stack));"
                            "increment_count(temp = cdr(stack));"
                            "decrement_count(stack);"
                            "stack = temp;")
                    "}"
                    "inline void top_level_apply() {"
                    (indent "if (is_function(val)) {"
                            (indent "decrement_count(env);"
                                    "return_location = address(val);"
                                    "increment_count(env = environment(val));"
                                    "decrement_count(val);"
                                    "increment_count(args);"
                                    "env = cons(args, env);")
                            "} else {"
                            (indent "if (is_primitive(val)) {"
                                    (indent "val = eval_primitive(val, args);")
                                    "} else {"
                                    (indent "decrement_count(val);"
                                            "val = NIL;")
                                    "}"
                                    "pop_function();")
                            "}"
                            "pop_args();")
                    "}"
                    "inline void apply(function_addr func) {"
                    (indent "if (is_function(val)) {"
                            (indent "call_stack = cons(new_function(func, env), call_stack);"
                                    "return_location = address(val);"
                                    "increment_count(env = environment(val));"
                                    "decrement_count(val);"
                                    "increment_count(args);"
                                    "env = cons(args, env);")
                            "} else {"
                            (indent "if (is_primitive(val)) {"
                                    (indent "val = eval_primitive(val, args);")
                                    "} else {"
                                    (indent "decrement_count(val);"
                                            "val = NIL;")
                                    "}"
                                    "return_location = func;")
                            "}"
                            "pop_args();")
                    "}")
        (reverse methods)))
(define (compile definitions expr)
  (let ((end_cont (code_block "if (is_function(val)) {"
                              (indent "increment_count(env=environment(val));"
                                      "env = cons(cons(free_memory_size(),"
                                      "               cons(arguments,NIL)),"
                                      "           env);"
                                      "return_location = address(val);"
                                      "decrement_count(val);")
                              "} else {"
                              (indent "error(ERR_NO_OS);"
                                      "env = NIL;"
                                      "return_location = (&end_function);")
                              "}"))
        (labels (empty_labels 0)))
    (add_function end_cont labels '()
                  (fn (apply_main methods labels)
                    (cond ((atom definitions)
                           (compile_expr expr '() '() labels methods
                                         (compile_return apply_main)))
                          ('t (compile-definitions definitions expr
                                                   labels methods
                                                   (compile_return apply_main))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function for maintaining the binding environment ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (bind args env) (cons args env))
(define (rfind var env expr)
  (cond ((function env)
         (cond ((= (symbol->id var) (symbol->id env)) expr)
               ('t '())))
        ((atom env) (cond ((= var env) expr) ('t '())))
        ('t (let ((find_var (rfind var (car env) (append "car(" expr ")"))))
              (cond ((= find_var '())
                     (rfind var (cdr env) (append "cdr(" expr ")")))
                    ('t find_var))))))
(define (find expr env labels)
  (let ((expr_str (rfind expr env "env")))
    (cond ((= expr_str '())
           (append "increment_count(val = global_"
                   (number->string (symbol->id expr))
                   ");"))
          ('t (append "increment_count(val = " expr_str ");")))))

;;;;;;;;;;;;;;;;;;;;
;; Error handling ;;
;;;;;;;;;;;;;;;;;;;;
(define (print-error msg) (append msg "\n"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function for printing the generated code ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (printer prefix postfix)
  (foldr (fn (block printed-code) (block prefix printed-code)) postfix))

;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the input ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (compile-source definitions start-line-number)
  (fn (value symbol-table end-line-number)
    (cond ((not value)
           (print-error "No main expression"))
          ((not (= (car value) 'define))
           ((printer '() '()) (compile definitions value)))
          ((not (or (atom (cadr value)) (atom (caadr value))))
           (print-error "Malformed define statement"))
          ('t (read-expr (compile-source (cons value definitions)
                                         end-line-number)
                         symbol-table
                         end-line-number)))))
(fn (size arguments) (read-expr (compile-source '() 1) '() 1))
