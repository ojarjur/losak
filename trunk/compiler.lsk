;; Compiler from a simple lisp-dialect to C
;;
;; The basis for this compiler is the invariant* that for each type
;; of s-expression, that s-expression is compiled into C code that
;; stores the evaluated result of the s-expression into the C global
;; variable "val", while leaving the variables "args", "stack", and
;; "call_stack" with the same values before and after computation.
;;
;; (*May be violated if the system runs out of free memory)
;;
;; The following C types must be externally defined:
;;   pointer,      //HINT: typedef long int pointer;
;;   function_addr //HINT: typedef void (*function_addr)();
;;
;; The following C globals must be externally defined:
;;   int sign_mask
;;   pointer val, args, stack, call_stack, true
;;
;; The following C functions must be defined in another file:
;;   pointer cons(pointer expr1, pointer expr2)
;;   pointer car(pointer expr)
;;   pointer cdr(pointer expr)
;;
;;   pointer new_number(int value)
;;   int value(pointer n)
;;
;;   pointer new_function(function_addr addr, pointer binding_env)
;;   function_addr addr(pointer func)
;;   pointer binding_env(pointer func)
;;
;;   void increment_count(pointer expr)
;;   void decrement_count(pointer expr)
;;
;;   int eq(pointer expr1, pointer expr2)
;;   int length(pointer expr)
;;   int is_atom(pointer expr)
;;   int is_number(pointer expr)
;;   int is_function(pointer expr)
;;
;;   pointer eval_primitive(pointer op, pointer args)
;;
;;   void end_function()

(define (caar x) (car (car x)))
(define (cdar x) (cdr (car x)))
(define (cadr x) (car (cdr x)))
(define (cddr x) (cdr (cdr x)))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (id x) x)
(define (list . args) args)
(define (apply op args) (op . args))
(define (recurse op)
  ((fn (this) (op (fn args ((this this) . args))))
   (fn (this) (op (fn args ((this this) . args))))))
(define (walk head tail test merge ret)
  (fn (tree)
      (cond ((test tree) (ret tree))
            ('t (merge (head tree)
                       ((walk head tail test merge ret)
                        (tail tree)))))))
(define (rreverse list result return)
  (cond ((atom list) (return result))
        ('t (rreverse (cdr list) (cons (car list) result) return))))
(define (reverse list) (rreverse list '() id))
(define (foldl merge end)
  (fn (list)
      (cond ((atom list) end)
            ('t ((foldl merge (merge (car list) end)) (cdr list))))))
(define (foldr merge end)
  (fn (list) (rreverse list '() (foldl merge end))))
(define (append . args) ((foldr (fn (x xs)
                                    (cond ((= xs '()) x)
                                          ('t ((foldr cons xs) x))))
                                '()) args))
(define (equal x y)
  (cond ((atom x) (= x y))
        ((atom y) '())
        ((equal (car x) (car y)) (equal (cdr x) (cdr y)))
        ('t '())))
(define (map op list) ((foldr (fn (x xs) (cons (op x) xs)) '()) list))
(define (or . args) ((foldr (fn (t ts) (cond (t t) ('t ts))) '()) args))
(define (and . args) ((foldr (fn (t ts) (cond (t ts) ('t '()))) 't) args))
(define (not test) (cond (test '()) ('t 't)))
(define (member item list)
  (cond ((atom list) '())
        ((equal item (car list)) list)
        ('t (member item (cdr list)))))

;;;;;;;;;;;;;;;;;;;;
;; Error handling ;;
;;;;;;;;;;;;;;;;;;;;
(define map-to-stderr
  (foldr (fn (char output) (cons (list (cons 2 char)) output)) ()))
(define (print-warnings line-number warnings)
  (cond (warnings (map-to-stderr (append "WARNING; "
                                         "In expression beginning on line "
                                         (number->string line-number) ": "
                                         warnings
                                         "\n")))
        ('t ())))
(define (print-error msg) (map-to-stderr (append "Error; "msg "\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Helper functions for parsing ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (escape-char char)
  (cond ((= char 116) 9)
        ((= char 114) 13)
        ((= char 110) 10)
        ('t char)))
(define (build-num chars)
  ((foldl (fn (c n) (+ (* 10 n) (- c 48))) 0) chars))
(define (quote-value expr) (list 'quote expr))
(define (quasiquote-value expr) (list 'quasiquote expr))
(define (unquote-value expr) (list 'unquote expr))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Parser combinators that simplify the process of writting an LL(1) ;;
;; grammar.                                                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Each parser takes a return continuation, an error continuation,   ;;
;; and a current line number. They implement a function that takes   ;;
;; input one character at a time (in curried form), parses the input ;;
;; string, and passes the tree and updated line number to the        ;;
;; return, or "fails" and passes a message to the error.             ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (fail return error line-num) (error line-num))
(define (done return error line-num) (return () line-num))
(define (pop return error line-num)
  (fn (char)
      (cond ((= char '()) (pop return error line-num))
            ((not (number char)) (error line-num))
            ((= char 10) (return char (+ 1 line-num)))
            ('t (return char line-num)))))
(define (check test)
  (fn (return error line-num)
      (pop (fn (val line-num)
               (cond ((test val) (return val line-num))
                     ('t ((error line-num) val))))
           error line-num)))
(define (match char) (check (fn (val) (= val char))))
(define (default parser) (fn (else) parser))
(define (case test then)
  (fn (else)
      (fn (return error line-num)
          (test (fn (val line-num)
                    (then return error line-num))
                (fn (symbols) (else return error line-num))
                line-num))))
(define (choice . args) ((foldr (fn (c cs) (c cs)) fail) args))
(define (post-process parser op)
  (fn (return error line-num)
      (parser (fn (val line-num) (return (op val) line-num))
              error line-num)))
(define (seq parser1 parser2)
  (fn (return error line-num)
      (parser1 (fn (head line-num)
                   (parser2 (fn (tail line-num)
                                (return (cons head tail) line-num))
                            error line-num))
               error line-num)))
(define (escape parser) (seq (post-process pop escape-char) parser))
(define (use parser) (seq pop parser))
(define (peek parser)
  (fn (return error line-num)
      (parser (fn (val new-line-num)
                  ((return val line-num) val))
              error line-num)))
(define (interval start end)
  (check (fn (val) (and (> val (- start 1)) (< val (+ end 1))))))
(define (skip parser) (post-process (use parser) cdr))
(define (first parser1 parser2) (post-process (seq parser1 parser2) car))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions to parse an s-expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (parse-num . args)
  (apply (choice (case (peek (interval 48 57)) (use parse-num))
                 (default done))
         args))
(define (read-num . args) (apply (post-process parse-num build-num) args))
(define (parse-symbol . args)
  (apply (choice (case (interval 0 32) done)
                 (case (peek (interval 39 41)) done)
                 (case (peek (match 46)) done)
                 (case (peek (match 59)) done)
                 (default (use parse-symbol)))
         args))
(define (read-symbol . args)
  (apply (post-process parse-symbol string->symbol) args))
(define (parse-string . args)
  (apply (choice (case (match 34) done)
                 (case (match 92) (escape parse-string))
                 (default (use parse-string)))
         args))
(define (quote-parser parser) (post-process parser quote-value))
(define (quasiquote-parser parser) (post-process parser quasiquote-value))
(define (unquote-parser parser) (post-process parser unquote-value))
(define (comment parser)
  (fn args (apply (choice (case (match 10) parser)
                          (case (match 13) parser)
                          (default (skip (comment parser))))
                  args)))
(define (parse-paren . args)
  (apply (choice (case (interval 1 32) parse-paren)
                 (case (match 59) (comment parse-paren))
                 (case (match 41) done))
         args))
(define (parse-pair . args)
  (apply (choice (case (interval 1 32) parse-pair)
                 (case (match 59) (comment parse-pair))
                 (case (match 41) done)
                 (case (match 46) (first parse-expr parse-paren))
                 (default (seq parse-expr parse-pair)))
         args))
(define (parse-expr . args)
  (apply (choice (case (interval 1 32) parse-expr)
                 (case (match 34) (quote-parser parse-string))
                 (case (match 39) (quote-parser parse-expr))
                 (case (match 96) (quasiquote-parser parse-expr))
                 (case (match 44) (unquote-parser parse-expr))
                 (case (match 40) parse-pair)
                 (case (match 41) fail)
                 (case (match 46) fail)
                 (case (match 59) (comment parse-expr))
                 (case (peek (interval 48 57)) read-num)
                 (default read-symbol))
         args))
(define (read-expr cont line-number)
  (parse-expr cont (fn (end-line)
                       (print-error (append "Parse error, line "
                                            (number->string line-number)
                                            " -> line "
                                            (number->string end-line)
                                            "\n")))
              line-number))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for structuring the generated code ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (code_block . lines)
  (fn (prefix postfix)
      ((foldr (fn (block postfix)
                  (cond ((function block) (block prefix postfix))
                        (block (append prefix block "\n" postfix))
                        ('t postfix)))
              postfix)
       lines)))
(define (indent . code)
  (fn (prefix postfix)
      (let ((new-prefix (append "  " prefix)))
        ((foldr (fn (block postfix)
                    (cond ((function block) (block new-prefix postfix))
                          ('t (append new-prefix block "\n" postfix))))
                postfix)
         code))))
(define (build_num_str n)
  (((walk (fn (n) (% n 10))
          (fn (n) (/ n 10))
          (fn (n) (= n 0))
          (fn (d op) (fn (str) (op (cons (+ d 48) str))))
          (fn (x) id))
    n)
   ""))
(define (number->string num)
  (cond ((< num 0) (cons 45 (build_num_str (- num))))
        ((= num 0) '(48))
        ('t (build_num_str num))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Variables for maintaining the symbol table ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (find-builtin sym default)
  (cond ((= sym 'cons) "CONS")
        ((= sym 'car) "CAR")
        ((= sym 'cdr) "CDR")
        ((= sym 'atom) "ATOM")
        ((= sym 'number) "NUMBER")
        ((= sym 'function) "FUNCTION")
        ((= sym '=) "EQ")
        ((= sym '<) "LT")
        ((= sym '>) "GT")
        ((= sym '+) "PLUS")
        ((= sym '-) "MINUS")
        ((= sym '*) "MULT")
        ((= sym '/) "DIV")
        ((= sym '%) "MOD")
        ((= sym '~) "BNEG")
        ((= sym '&) "BAND")
        ((= sym '|) "BOR")
        ((= sym '^) "BXOR")
        ((= sym '>>) "SRSHIFT")
        ((= sym '>>>) "URSHIFT")
        ((= sym '<<) "LSHIFT")
        ('t default)))
(define (compile_symbol sym symbols return)
  (let ((builtin-name (find-builtin sym '())))
    (if builtin-name
        (return builtin-name symbols)
        (symbols sym (fn (symbol-id symbols)
                         (return (number->string symbol-id) symbols))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function to compile compile-time data ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (compile-literal-list expr cont symbols return)
  (cond ((atom expr)
         (compile-literal expr symbols
                          (fn (val-code symbols)
                              (return (code_block val-code
                                                  "push_args();"
                                                  "args = val;"
                                                  cont)
                                      symbols))))
        ('t (compile-literal
             (car expr) symbols
             (fn (literal-code symbols)
                 (compile-literal-list (cdr expr)
                                       (code_block literal-code
                                                   "args = cons(val, args);"
                                                   cont)
                                       symbols
                                       return))))))
(define (compile-literal expr symbols return)
  (cond ((= expr '()) (return (append "val = NIL;") symbols))
        ((number expr)
         (return (append "val = new_number(" (number->string expr) ");")
                 symbols))
        ((symbol? expr)
         (compile_symbol expr symbols
                         (fn (symbol-code symbols)
                             (return (append "val = " symbol-code ";")
                                     symbols))))
        ('t (compile-literal-list expr
                                  (code_block "val = args;"
                                              "args = NIL;"
                                              "pop_args();")
                                  symbols
                                  return))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for handling primitives ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (is_primitive expr)
  (or (= expr 'car) (= expr 'cdr) (= expr 'cons) (= expr 'atom)
      (= expr 'number) (= expr 'function) (= expr '=) (= expr '<)
      (= expr '>) (= expr '+) (= expr '-) (= expr '*) (= expr '/)
      (= expr '%) (= expr '~) (= expr '&) (= expr '|) (= expr '^)
      (= expr '>>) (= expr '>>>) (= expr '<<)))
(define (compile_primitive op)
  (cond ((or (= op 'car) (= op 'cdr) (= op 'atom)
             (= op 'number) (= op 'function) (= op '~))
         (code_block
          "if (length(args) == 1) {"
          (indent (cond ((= op 'atom)
                         (code_block
                          "if (is_atom(car(args))) {"
                          (indent "increment_count(val = true); ")
                          "} else { val = NIL; }"))
                        ((= op 'number)
                         (code_block
                          "if (is_number(car(args))) {"
                          (indent "increment_count(val = true);")
                          "} else { val = NIL; }"))
                        ((= op 'function)
                         (code_block
                          "if (is_function(car(args))) {"
                          (indent "increment_count(val = true);")
                          "} else { val = NIL; }"))
                        ((= op '~)
                         (code_block
                          "if (is_number(car(args))) {"
                          (indent "val = new_number(~(value(car(args))));")
                          "} else { val = NIL; }"))
                        ('t (code_block
                             "if (! is_atom(car(args))) {"
                             (cond ((= op 'car)
                                    "increment_count(val = car(car(args)));")
                                   ('t ;; (= op 'cdr)
                                    "increment_count(val = cdr(car(args)));"))
                             "} else { val = NIL; }"))))
          "} else { val = NIL; }"))
                  ((or (= op '+) (= op '*) (= op '/) (= op '%)
             (= op '&) (= op '|) (= op '^) (= op '>>)
             (= op '<<) (= op '>>>) (= op '>) (= op '<))
         (code_block
          "if ((length(args) == 2) &&"
          "    (is_number(car(args))) &&"
          "    (is_number(car(cdr(args))))) {"
          (indent (cond ((= op '+)
                         "val = new_number(value(car(args)) + value(car(cdr(args)))); ")
                        ((= op '*)
                         "val = new_number(value(car(args)) * value(car(cdr(args)))); ")
                        ((= op '/)
                         (code_block
                          "if (value(car(cdr(args))) == 0) {"
                          (indent "val = NIL;")
                          "} else {"
                          (indent "val = new_number(value(car(args)) / "
                                  "                 value(car(cdr(args))));")
                          "}"))
                        ((= op '%)
                         (code_block
                          "if (value(car(cdr(args))) == 0) {"
                          (indent "val = NIL;")
                          "} else {"
                          (indent "val = new_number(value(car(args)) %"
                                  "                 value(car(cdr(args))));")
                          "}"))
                        ((= op '&)
                         "val = new_number(value(car(args)) & value(car(cdr(args)))); ")
                        ((= op '|)
                         "val = new_number(value(car(args)) | value(car(cdr(args)))); ")
                        ((= op '^)
                         "val = new_number(value(car(args)) ^ value(car(cdr(args)))); ")
                        ((= op '>>)
                         (code_block "val = new_number(value(car(args)) >> "
                                     "                 value(car(cdr(args))));"))
                        ((= op '>>>)
                         (code_block "val = new_number(((sign_mask >> "
                                     "                   value(car(cdr(args))) - 1) ^ -1) & "
                                     "                 (value(car(args)) >> "
                                     "                  value(car(cdr(args))))); "))
                        ((= op '<<)
                         (code_block "val = new_number(value(car(args)) << "
                                     "                 value(car(cdr(args)))); "))
                        ((= op '>)
                         (code_block
                          "if (value(car(args)) > value(car(cdr(args)))) {"
                          (indent "increment_count(val = true);")
                          "} else { val = NIL; }"))
                        ('t ;; (= op '<)
                         (code_block
                          "if (value(car(args)) < value(car(cdr(args)))) {"
                          (indent "increment_count(val = true);")
                          "} else { val = NIL; }"))))
          "} else { val = NIL; }"))
        ((= op '-)
         (code_block "if (is_number(car(args))) {"
                     (indent "if ((length(args) == 2) &&"
                             "    is_number(car(cdr(args)))) {"
                             (indent "val = new_number(value(car(args)) - "
                                     "                 value(car(cdr(args))));")
                             "} else if (length(args) == 1) {"
                             (indent "val = new_number(-value(car(args)));")
                             "} else { val = NIL; }")
                     "} else { val = NIL; }"))
        ((= op '=)
         (code_block "if ((length(args) == 2) &&"
                     "    (is_atom(car(args))) &&"
                     "    (is_atom(car(cdr(args)))) &&"
                     "    eq(car(args), car(cdr(args)))) {"
                     (indent "increment_count(val = true);")
                     "} else { val = NIL; }"))
        ((= op 'cons)
         (code_block "if (length(args) == 2) {"
                     (indent "increment_count(car(args));"
                             "increment_count(car(cdr(args)));"
                             "val = cons(car(args), car(cdr(args)));")
                     "} else { val = NIL; }"))
        ('t "/** Internal Error: unknown primitive */ val = NIL;")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile an if expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (then-else-block then-code else-code)
  (code_block "if (val != NIL) {"
              (indent "decrement_count(val);" then-code)
              "} else {"
              (indent else-code)
              "}"))
(define (compile_if test then else env cont return_cont labels methods
                    declared-globals symbols return)
  (compile_expr then env cont labels methods declared-globals symbols
                (fn (then-code labels methods declared-globals symbols)
                    (compile_expr else env cont labels methods
                                  declared-globals symbols
                                  (fn (else-code labels methods
                                                 declared-globals symbols)
                                      (let ((new_cont
                                             (then-else-block then-code
                                                              else-code)))
                                        (compile_expr test env new_cont
                                                      labels methods
                                                      declared-globals
                                                      symbols
                                                      return)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile a list of arguments ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (compile_args args env cont labels methods declared-globals symbols return)
  (cond ((atom args)
         (let ((new_cont (code_block "args = val;" cont)))
           (compile_expr args env new_cont labels methods
                         declared-globals symbols return)))
        ('t (compile_expr (car args) env
                          (code_block "args = cons(val, args);" cont)
                          labels methods declared-globals symbols
                          (fn (new_cont labels methods declared-globals symbols)
                            (compile_args (cdr args) env new_cont labels methods
                                          declared-globals symbols return))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile a function body ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (add_method_return declared-globals symbols return)
  (fn (function_name methods labels)
    (return (code_block "increment_count(env);"
                        (append "val = new_function(" function_name ", env);"))
            labels methods declared-globals symbols)))
(define (compile_fn body env labels methods declared-globals symbols return)
  (cond ((or (atom body) (atom (cdr body)))
         (return "/** Warning, malformed function */ val = NIL;"
                 labels methods declared-globals symbols))
        ('t (let ((local_env (bind (car body) env))
                  (expr (car (cdr body))))
              (compile_expr expr local_env '() labels methods
                            declared-globals symbols
                            (fn (compiled_body labels methods
                                               declared-globals symbols)
                              (add_function compiled_body labels methods
                                            (add_method_return declared-globals
                                                               symbols
                                                               return))))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the application of an unknown function to a list of arguments. ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (apply_return op arg_list env top_level call_cont methods labels
                      declared-globals symbols return)
  (compile_expr op env call_cont labels methods declared-globals symbols
                (fn (call_body labels methods declared-globals symbols)
                    (compile_args arg_list env call_body labels
                                  methods declared-globals symbols
                                  (fn (apply_body labels methods
                                                  declared-globals symbols)
                                      (return (code_block "push_args();"
                                                          apply_body)
                                              labels
                                              methods
                                              declared-globals
                                              symbols))))))
(define (compile_apply op args env return_cont top_level labels methods
                       declared-globals symbols return)
  (cond (top_level (apply_return op args env top_level "top_level_apply();"
                                 methods labels declared-globals
                                 symbols return))
        ('t (add_function return_cont labels methods
                          (fn (return_body methods labels)
                              (apply_return op args env top_level
                                            (append "apply(" return_body ");")
                                            methods labels declared-globals
                                            symbols return))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the application of a primitive operation to a list of arguments, ;;
;; when the operation applied is known at compile-time.                     ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (compile_apply_primitive op args env cont labels methods
                                 declared-globals symbols return)
  (let ((return_body (code_block (compile_primitive op)
                                 "pop_args();"
                                 cont)))
    (compile_args args env return_body labels methods declared-globals symbols
                  (fn (apply_body labels methods declared-globals symbols)
                    (return (code_block "push_args();" apply_body)
                            labels
                            methods
                            declared-globals
                            symbols)))))

;;;;;;;;;;;;;;;;;;;;
;; Compile a pair ;;
;;;;;;;;;;;;;;;;;;;;
(define (compile_pair op expr env cont return_cont labels methods
                      declared-globals symbols return)
  (cond ((= op 'if)
         (compile_if (car expr) (cadr expr) (caddr expr) env
                     cont return_cont labels methods declared-globals
                     symbols return))
        ((= op 'quote)
         (compile-literal (car expr) symbols
                          (fn (literal-code symbols)
                              (return (code_block literal-code return_cont)
                                      labels
                                      methods
                                      declared-globals
                                      symbols))))
        ((= op 'fn)
         (compile_fn expr env labels methods declared-globals symbols
                     (fn (fn_call labels methods declared-globals symbols)
                       (return (code_block fn_call return_cont)
                               labels methods declared-globals symbols))))
        ((= op 'define) (print-error "Illegal, nested define statement"))
        ((is_primitive op)
         (compile_apply_primitive op expr env return_cont labels methods
                                  declared-globals symbols return))
        ('t (compile_apply op expr env return_cont (= cont '())
                           labels methods declared-globals symbols return))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function for maintaining the binding environment ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (escape-symbol-name symbol)
  ((foldr (fn (char chars) (append "c" (number->string char) chars)) "")
   (symbol->string symbol)))
(define (bind args env) (cons args env))
(define (rfind var env expr)
  (cond ((symbol? env) (if (= var env) expr '()))
        ((atom env) '())
        ('t (let ((find_var (rfind var (car env) (append "car(" expr ")"))))
              (cond ((= find_var '())
                     (rfind var (cdr env) (append "cdr(" expr ")")))
                    ('t find_var))))))
(define (find expr env labels methods declared-globals return)
  (let ((expr_str (rfind expr env "env")))
    (cond ((= expr_str '())
           (let ((global_name (append "global_" (escape-symbol-name expr)))
                 (already-declared (member expr declared-globals))
                 (methods (if already-declared
                              methods
                              (code_block (append "pointer " global_name " = "
                                                  (find-builtin expr "NIL")
                                                  "; /* "
                                                  (symbol->string expr)
                                                  " */")
                                          methods)))
                 (declared-globals (if already-declared
                                       declared-globals
                                       (cons expr declared-globals))))
             (return (append "increment_count(val = "
                             global_name
                             "); /* "
                             (symbol->string expr)
                             " */")
                     methods declared-globals)))
          ('t (return (append "increment_count(val = " expr_str ");")
                      methods declared-globals)))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile an s-expression ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (compile_expr expr env cont labels methods
                      declared-globals symbols return)
  (let ((return_cont (or cont "pop_function();")))
    (cond ((symbol? expr)
           (find expr env labels methods declared-globals
                 (fn (var-code methods declared-globals)
                     (return (code_block var-code return_cont) labels
                             methods declared-globals symbols))))
          ((not (atom expr))
           (compile_pair (car expr) (cdr expr) env cont return_cont
                         labels methods declared-globals symbols return))
          ('t (compile-literal expr symbols
                               (fn (literal-code symbols)
                                   (return (code_block literal-code return_cont)
                                           labels methods
                                           declared-globals
                                           symbols)))))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile a series of global definitions ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (definition-name definition) (cadr definition))
(define (definition-body definition) (caddr definition))

(define (definition-return name-string end-line-number definition-count)
  (fn (code labels methods declared-globals symbols)
      (let ((methods (code_block (append "void body_"
                                         (number->string (+ 1 definition-count))
                                         "();")
                                 methods
                                 (append "/* " name-string " */")
                                 (append "void body_"
                                         (number->string definition-count)
                                         "() {")
                                 (indent code)
                                 "}")))
        (append (print-code-block methods)
                (read-expr (compile-source end-line-number labels
                                           declared-globals
                                           (+ 1 definition-count)
                                           symbols)
                           end-line-number)))))
(define (compile-definition name body labels declared-globals
                            end-line-number definition-count symbols)
  (let ((already-declared (member name declared-globals))
        (methods (code_block (if already-declared '()
                                 (append "pointer global_"
                                         (escape-symbol-name name)
                                         ";"))))
        (declared-globals (if already-declared
                              declared-globals
                              (cons name declared-globals))))
    (compile_expr body '()
                  (code_block (append "global_"
                                      (escape-symbol-name name)
                                      " = val; /* "
                                      (symbol->string name)
                                      " */")
                              (append "return_location = (&body_"
                                      (number->string (+ definition-count 1))
                                      ");"))
                  labels methods declared-globals symbols
                  (definition-return (symbol->string name) end-line-number
                                     definition-count))))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Variables for maintaining the list of function headers/bodies ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (empty_labels initial)
  (fn (op) (op initial '())))
(define (get_next_label labels)
  (labels (fn (label-count label-map) label-count)))
(define (get_label_map labels)
  (labels (fn (label-count label-map) label-map)))
(define (add_label labels)
  (let ((label_count (+ (get_next_label labels) 1))
        (label_map (get_label_map labels)))
    (fn (op) (op label_count label_map))))
(define (next_label->string labels)
  (number->string (get_next_label labels)))
(define (add_function body labels methods return)
  (return (append "(&function_" (next_label->string labels) ")")
          (code_block methods
                      (append "void function_"
                              (next_label->string labels)
                              "() {")
                      (indent body)
                      "}")
          (add_label labels)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; The skeleton of the code generation ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (main_body methods apply_main)
  (code_block methods
              "#ifdef BARE_HARDWARE"
              "void main (unsigned long magic, multiboot_data* boot_data) {"
              (indent "int i = 0;"
                      "if ((magic == BOOT_MAGIC) &&"
                      "    getFlag(boot_data->flags, 0)) {"
                      (indent "init_mem((void*)0x200000, ((boot_data->mem_upper*1024) - 0x100000));"
                              "init_io();"
                              "init_eval();"
                              "arguments = get_cmd(boot_data->flags, (char*)(boot_data->cmd_line));"
                              (append "call_stack = "
                                      "cons(new_function((&top_level), NIL),"
                                      " call_stack);")
                              (append "call_stack = "
                                      "cons(new_function("
                                      apply_main ", NIL),"
                                      " call_stack);")
                              "return_location = (&body_0);"
                              "while (return_location != (&end_function)) {"
                              (indent "(*return_location)();")
                              "}"
                              "end_function();")
                      "} else {"
                      "  error(ERR_BAD_BOOT);"
                      "}")
               "}"
              "#else"
              "int main(int argc, char** argv) {"
              (indent "pointer memory_limit = 64 * 1024 * 1024;"
                      "void* memory = malloc(memory_limit);"
                      "init_mem(memory, memory_limit);"
                      "init_io();"
                      "init_eval();"
                      "arguments = NIL;"
                      "int i;"
                      "for (i = argc - 1; i >= 0; i--) {"
                      "  arguments = cons(make_string(argv[i]), arguments);"
                      "}"
                      (append "call_stack = "
                              "cons(new_function((&top_level), NIL),"
                              " call_stack);")
                      (append "call_stack = "
                              "cons(new_function(" apply_main ", NIL),"
                              " call_stack);")   
                      "return_location = (&body_0);"
                      "while (return_location != (&end_function)) {"
                      (indent "(*return_location)();")
                      "}"
                      "end_function();"
                      "end_io();")
              "}"
              "#endif"))
(define (compile_main_return apply_main definition-count)
  (fn (main_code labels methods declared-globals symbols)
      (let ((methods (code_block methods
                                 (append "void body_"
                                         (number->string definition-count)
                                         "() {")
                                 (indent main_code)
                                 "}")))
        (print-code-block (main_body methods apply_main)))))
(define (compile_main expr labels declared-globals definition-count symbols)
  (let ((end_cont (code_block "if (is_function(val)) {"
                              (indent "increment_count(env=environment(val));"
                                      "env = cons(cons(free_memory_size(),"
                                      "               cons(arguments,NIL)),"
                                      "           env);"
                                      "return_location = address(val);"
                                      "decrement_count(val);")
                              "} else {"
                              (indent "error(ERR_NO_OS);"
                                      "env = NIL;"
                                      "return_location = (&end_function);")
                              "}")))
    (add_function end_cont labels '()
                  (fn (apply_main methods labels)
                      (compile_expr expr '() '() labels methods
                                    declared-globals symbols
                                    (compile_main_return apply_main
                                                         definition-count))))))

(define (add-code-header continuation)
  (append (print-code-block
           (code_block "#ifdef BARE_HARDWARE"
                       "#include \"multiboot.h\""
                       "#else"
                       "#include <stdlib.h>"
                       "#endif"
                       "#include \"io.h\""
                       "#include \"mem.h\""
                       "#include \"eval.h\""
                       "pointer arguments = NIL;"
                       "pointer make_string(char* str) {"
                       (indent "pointer r = NIL;"
                               "int i = 0;"
                               "while ((str > 0) && (str[i] != '\\0')) {"
                               (indent "i++;")
                               "}"
                               "while (i > 0) {"
                               (indent "i--;"
                                       "r = cons(new_number(str[i]), r);")
                               "}"
                               "return r;")
                       "}"
                       "#ifdef BARE_HARDWARE"
                       "pointer get_cmd(unsigned long flags, char* command) {"
                       (indent "pointer r = NIL;"
                               "if (getFlag(flags,2) != 0) {"
                               (indent "r = make_string(command);")
                               "}"
                               "return r;")
                       "}"
                       "#endif"
                       "inline void pop_function() {"
                       (indent "decrement_count(env);"
                               "temp = car(call_stack);"
                               "if (is_function(temp)) {"
                               (indent "env = environment(temp);"
                                       "increment_count(env);"
                                       "return_location = address(temp);")
                               "} else {"
                               (indent "error(ERR_INTERNAL);"
                                       "env = NIL;"
                                       "return_location = (&end_function);")
                               "}"
                               "increment_count(temp = cdr(call_stack));"
                               "decrement_count(call_stack);"
                               "call_stack = temp;")
                       "}"
                       "inline void push_args() {"
                       (indent "stack = cons(args, stack);")
                       "}"
                       "inline void pop_args() {"
                       (indent "decrement_count(args);"
                               "increment_count(args = car(stack));"
                               "increment_count(temp = cdr(stack));"
                               "decrement_count(stack);"
                               "stack = temp;")
                       "}"
                       "inline void top_level_apply() {"
                       (indent "if (is_function(val)) {"
                               (indent "decrement_count(env);"
                                       "return_location = address(val);"
                                       "increment_count(env = environment(val));"
                                       "decrement_count(val);"
                                       "increment_count(args);"
                                       "env = cons(args, env);")
                               "} else {"
                               (indent "if (is_primitive(val)) {"
                                       (indent "val = eval_primitive(val, args);")
                                       "} else {"
                                       (indent "decrement_count(val);"
                                               "val = NIL;")
                                       "}"
                                       "pop_function();")
                               "}"
                               "pop_args();")
                       "}"
                       "inline void apply(function_addr func) {"
                       (indent "if (is_function(val)) {"
                               (indent "call_stack = cons(new_function(func, env), call_stack);"
                                       "return_location = address(val);"
                                       "increment_count(env = environment(val));"
                                       "decrement_count(val);"
                                       "increment_count(args);"
                                       "env = cons(args, env);")
                               "} else {"
                               (indent "if (is_primitive(val)) {"
                                       (indent "val = eval_primitive(val, args);")
                                       "} else {"
                                       (indent "decrement_count(val);"
                                               "val = NIL;")
                                       "}"
                                       "return_location = func;")
                               "}"
                               "pop_args();")
                       "}"))
          continuation))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Function for printing the generated code ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (print-code-block code-block)
  (if (function code-block)
      (code-block "" "")
      code-block))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Code for maintaining the compile-time symbol table ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (find-symbol-id symbol symbol-table default-id)
  (cond ((= (caar symbol-table) symbol) (cdar symbol-table))
        ((atom symbol-table) default-id)
        ('t (find-symbol-id symbol (cdr symbol-table) default-id))))
(define (make-symbols symbol-table next-symbol-id)
  (fn (symbol return)
      (let ((symbol-id (find-symbol-id symbol symbol-table next-symbol-id)))
        (return symbol-id
                (if (= symbol-id next-symbol-id)
                    (make-symbols (cons (cons symbol symbol-id) symbol-table)
                                  (- next-symbol-id 1))
                    (make-symbols symbol-table next-symbol-id))))))

;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the input ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (compile-source start-line-number labels declared-globals
                        definition-count symbols)
  (fn (value end-line-number)
    (cond ((not value)
           (print-error "No main expression"))
          ((not (= (car value) 'define))
           (compile_main value labels declared-globals
                         definition-count symbols))
          ((not (or (atom (cadr value)) (atom (caadr value))))
           (print-error "Malformed define statement"))
          ('t (let ((name (definition-name value))
                    (body (definition-body value)))
                (compile-definition name body labels declared-globals
                                    end-line-number definition-count
                                    symbols))))))
(fn (size arguments)
    (let ((start-line 1)
          (labels (empty_labels 0))
          (declared-globals '())
          (definition-count 0)
          (symbols (make-symbols '() (- 34))))
      (add-code-header (read-expr (compile-source start-line
                                                  labels
                                                  declared-globals
                                                  definition-count
                                                  symbols)
                                  '() 1))))
