;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Losak compiler                                                  ;;
;;                                                                 ;;
;; This front-end to the compiler adds standard library functions. ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Copyright (C) 2004 - 2011 by Omar Jarjur                        ;;
;;                                                                 ;;
;; This program is free software; you can redistribute it and/or   ;;
;; modify it under the terms of version 2 of the GNU General       ;;
;; Public License as published by the Free Software Foundation.    ;;
;;                                                                 ;;
;; This program is distributed in the hope that it will be useful, ;;
;; but WITHOUT ANY WARRANTY; without even the implied warranty of  ;;
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the   ;;
;; GNU General Public License for more details.                    ;;
;;                                                                 ;;
;; You should have received a copy of the GNU General Public       ;;
;; License along with this program; if not, write to the Free      ;;
;; Software Foundation, Inc.,                                      ;;
;; 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define standard-library-definitions
  '((define (caar x) (car (car x)))
    (define (cdar x) (cdr (car x)))
    (define (cadr x) (car (cdr x)))
    (define (cddr x) (cdr (cdr x)))
    (define (caaar x) (car (car (car x))))
    (define (caadr x) (car (car (cdr x))))
    (define (cadar x) (car (cdr (car x))))
    (define (caddr x) (car (cdr (cdr x))))
    (define (cdaar x) (cdr (car (car x))))
    (define (cdadr x) (cdr (car (cdr x))))
    (define (cddar x) (cdr (cdr (car x))))
    (define (cdddr x) (cdr (cdr (cdr x))))
    (define (caaaar x) (car (car (car (car x)))))
    (define (caaadr x) (car (car (car (cdr x)))))
    (define (caadar x) (car (car (cdr (car x)))))
    (define (caaddr x) (car (car (cdr (cdr x)))))
    (define (cadaar x) (car (cdr (car (car x)))))
    (define (cadadr x) (car (cdr (car (cdr x)))))
    (define (caddar x) (car (cdr (cdr (car x)))))
    (define (cadddr x) (car (cdr (cdr (cdr x)))))
    (define (cdaaar x) (cdr (car (car (car x)))))
    (define (cdaadr x) (cdr (car (car (cdr x)))))
    (define (cdadar x) (cdr (car (cdr (car x)))))
    (define (cdaddr x) (cdr (car (cdr (cdr x)))))
    (define (cddaar x) (cdr (cdr (car (car x)))))
    (define (cddadr x) (cdr (cdr (car (cdr x)))))
    (define (cdddar x) (cdr (cdr (cdr (car x)))))
    (define (cddddr x) (cdr (cdr (cdr (cdr x)))))

    (define (id x) x)
    (define (list . args) args)
    (define (apply op args) (op . args))
    (define (recurse op)
      ((fn (this) (op (fn args ((this this) . args))))
       (fn (this) (op (fn args ((this this) . args))))))
    (define (walk head tail test merge ret)
      (fn (tree)
          (if (test tree)
              (ret tree)
              (merge (head tree)
                     ((walk head tail test merge ret)
                      (tail tree))))))
    (define (rreverse list result return)
      (if (atom list)
          (return result)
          (rreverse (cdr list) (cons (car list) result) return)))
    (define (reverse list) (rreverse list '() id))
    (define (foldl merge end)
      (fn (list)
          (if (atom list)
              end
              ((foldl merge (merge (car list) end)) (cdr list)))))
    (define (foldr merge end)
      (fn (list) (rreverse list '() (foldl merge end))))
    (define (append . args) ((foldr (fn (x xs)
                                        (if (= xs '())
                                            x
                                            ((foldr cons xs) x)))
                                    '()) args))
    (define (equal x y)
      (if (atom x)
          (= x y)
          (if (atom y)
              '()
              (if (equal (car x) (car y))
                  (equal (cdr x) (cdr y))
                  '()))))
    (define (map op list) ((foldr (fn (x xs) (cons (op x) xs)) '()) list))
    (define (or . args) ((foldr (fn (t ts) (if t t ts)) '()) args))
    (define (and . args) ((foldr (fn (t ts) (if t ts '())) 't) args))
    (define (not test) (if test '() 't))
    (define (member item list)
      (if (atom list)
          '()
          (if (equal item (car list))
              list
              (member item (cdr list)))))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Helper functions for parsing ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (define (escape-char char)
      (if (= char 116)
          9
          (if (= char 114)
              13
              (if (= char 110)
                  10
                  char))))
    (define (build-num chars)
      ((foldl (fn (c n) (+ (* 10 n) (- c 48))) 0) chars))
    (define (quote-value expr) (list 'quote expr))
    (define (quasiquote-value expr) (list 'quasiquote expr))
    (define (unquote-value expr) (list 'unquote expr))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Parser combinators that simplify the process of writting an LL(1) ;;
    ;; grammar.                                                          ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Each parser takes a return continuation, an error continuation,   ;;
    ;; and a current line number. They implement a function that takes   ;;
    ;; input one character at a time (in curried form), parses the input ;;
    ;; string, and passes the tree and updated line number to the        ;;
    ;; return, or "fails" and passes a message to the error.             ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (define (fail error-message)
      (fn (return error line-num)
          (error error-message line-num)))
    (define (done return error line-num) (return () line-num))
    (define (pop return error line-num)
      (fn (char)
          (if char
              (if (number char)
                  (return char (if (= char 10) (+ 1 line-num) line-num))
                  (error "unexpected input" line-num))
              (pop return error line-num))))
    (define (check test)
      (fn (return error line-num)
          (pop (fn (val line-num)
                   (if (test val)
                       (return val line-num)
                       ((error (append "unexpected value: " (print val))
                               line-num)
                        val)))
               error line-num)))
    (define (match char) (check (fn (val) (= val char))))
    (define (default parser) (fn (else) parser))
    (define (case test then)
      (fn (else)
          (fn (return error line-num)
              (test (fn (val line-num) (then return error line-num))
                    (fn (error-message error-line) (else return error line-num))
                    line-num))))
    (define (choice . args)
      ((foldr (fn (c cs) (c cs)) (fail "found no matching parse options"))
       args))
    (define (post-process parser op)
      (fn (return error line-num)
          (parser (fn (val line-num) (return (op val) line-num))
                  error line-num)))
    (define (seq parser1 parser2)
      (fn (return error line-num)
          (parser1 (fn (head line-num)
                       (parser2 (fn (tail line-num)
                                    (return (cons head tail) line-num))
                                error line-num))
                   error line-num)))
    (define (escape parser) (seq (post-process pop escape-char) parser))
    (define (use parser) (seq pop parser))
    (define (peek parser)
      (fn (return error line-num)
          (parser (fn (val new-line-num)
                      ((return val line-num) val))
                  error line-num)))
    (define (interval start end)
      (check (fn (val) (and (> val (- start 1)) (< val (+ end 1))))))
    (define (skip parser) (post-process (use parser) cdr))
    (define (first parser1 parser2) (post-process (seq parser1 parser2) car))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Functions to parse an s-expression ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (define (parse-num . args)
      (apply (choice (case (interval 0 32) done)
                     (case (peek (interval 48 57)) (use parse-num))
                     (default done))
             args))
    (define (read-num . args) (apply (post-process parse-num build-num) args))
    (define (parse-symbol . args)
      (apply (choice (case (interval 0 32) done)
                     (case (peek (interval 39 41)) done)
                     (case (peek (match 46)) done)
                     (case (peek (match 59)) done)
                     (default (use parse-symbol)))
             args))
    (define (read-symbol . args)
      (apply (post-process parse-symbol string->symbol) args))
    (define (parse-string . args)
      (apply (choice (case (match 34) done)
                     (case (match 92) (escape parse-string))
                     (default (use parse-string)))
             args))
    (define (quote-parser parser) (post-process parser quote-value))
    (define (quasiquote-parser parser) (post-process parser quasiquote-value))
    (define (unquote-parser parser) (post-process parser unquote-value))
    (define (comment parser)
      (fn args (apply (choice (case (match 10) parser)
                              (case (match 13) parser)
                              (default (skip (comment parser))))
                      args)))
    (define (parse-paren . args)
      (apply (choice (case (interval 1 32) parse-paren)
                     (case (match 59) (comment parse-paren))
                     (case (match 41) done)
                     (default (fail "missing expected closing parenthesis")))
             args))
    (define (parse-pair . args)
      (apply (choice (case (interval 1 32) parse-pair)
                     (case (match 59) (comment parse-pair))
                     (case (match 41) done)
                     (case (match 46) (first parse-expr parse-paren))
                     (default (seq parse-expr parse-pair)))
             args))
    (define (parse-expr . args)
      (apply (choice (case (interval 1 32) parse-expr)
                     (case (match 34) (quote-parser parse-string))
                     (case (match 39) (quote-parser parse-expr))
                     (case (match 96) (quasiquote-parser parse-expr))
                     (case (match 44) (unquote-parser parse-expr))
                     (case (match 40) parse-pair)
                     (case (match 41)
                           (fail "found an unexpected closing parenthesis"))
                     (case (match 46) (fail "found an unexpected period"))
                     (case (match 59) (comment parse-expr))
                     (case (peek (interval 48 57)) read-num)
                     (default read-symbol))
             args))

    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    ;; Functions to print s-expressions ;;
    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    (define (build-num-str num)
      ((walk (fn (n) (% n 10))
             (fn (n) (/ n 10))
             (fn (n) (= n 0))
             (fn (d op) (fn (str) (op (cons (+ d 48) str))))
             (fn (x) id))
       num))
    (define (print-num num)
      (if (= num 0)
          "0"
          (if (< num 0)
              (cons 45 ((build-num-str (- num)) ""))
              ((build-num-str num) ""))))
    (define (print-atom expr)
      (if expr
          (if (number expr)
              (print-num expr)
              (if (symbol? expr)
                  (symbol->string expr)
                  (if (function expr)
                      "<FUNCTION>"
                      "<INTERNAL ERROR>")))
          "()"))
    (define (print-tail expr suffix)
      (if expr
          (if (atom expr)
              (append " . " (print-atom expr) ")" suffix)
              (append " " (print-with-suffix (car expr)
                                             (print-tail (cdr expr) suffix))))
          (append ")" suffix)))
    (define (print-with-suffix expr suffix)
      (if (atom expr)
          (append (print-atom expr) suffix)
          (append "(" (print-with-suffix (car expr)
                                         (print-tail (cdr expr) suffix)))))
    (define (print expr) (print-with-suffix expr ""))))

;;;;;;;;;;;;;;;;;;;;
;; Error handling ;;
;;;;;;;;;;;;;;;;;;;;
(define map-to-stderr
  (foldr (fn (char output) (cons (list (cons 2 char)) output)) ()))
(define (print-error msg) (map-to-stderr (append "Error; "msg "\n")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Functions for escaping symbols ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define supported-builtins
  '(cons car cdr atom number function = < > + - * / % ~ & | ^ >> >>> <<
         symbol? symbol->string string->symbol))
(define supported-library-procedures
  '(and append apply equal
    foldl foldr id list
    map member not or
    parse-expr print reverse
    caar cadr cdar cddr
    caaar caadr cadar caddr
    cdaar cdadr cddar cdddr
    caaaar caaadr caadar caaddr
    cadaar cadadr caddar cadddr
    cdaaar cdaadr cdadar cdaddr
    cddaar cddadr cdddar cddddr))
(define (escape-symbols expr)
  (cond ((atom expr)
         (cond ((member expr supported-builtins) expr)
               ((member expr supported-library-procedures) expr)
               ((symbol? expr)
                (string->symbol (append "_" (symbol->string expr))))
               ('t expr)))
        ('t (cons (escape-symbols (car expr))
                  (escape-symbols (cdr expr))))))
(define (escape-statement-list statements)
  (if (atom statements)
      (escape-statement statements)
      (cons (escape-statement (car statements))
            (escape-statement-list (cdr statements)))))
(define (escape-statement expr)
  (cond ((atom expr) (escape-symbols expr))
        ((= (car expr) 'quote) expr)
        ((= (car expr) 'if)
         `(if ,(escape-statement (cadr expr))
              ,(escape-statement (caddr expr))
              ,(escape-statement (cadr (cddr expr)))))
        ((= (car expr) 'fn)
         `(fn ,(escape-symbols (cadr expr)) ,(escape-statement (caddr expr))))
        ((= (car expr) 'define)
         `(define ,(escape-symbols (get-name expr))
            ,(escape-statement (get-body expr))))
        ('t (escape-statement-list expr))))

;;;;;;;;;;;;;;;;;;;;;;;
;; Compile the input ;;
;;;;;;;;;;;;;;;;;;;;;;;
(define (get-name definition)
  (cond ((atom (cadr definition)) (cadr definition))
        ('t (caadr definition))))
(define (get-body definition)
  (cond ((atom (cadr definition)) (caddr definition))
        ('t (list 'fn (cdr (cadr definition)) (caddr definition)))))
(define (find-definition name definitions)
  (cond ((atom definitions) '())
        ((= name (get-name (car definitions)))
         (car definitions))
        ('t (find-definition name (cdr definitions)))))
(define (flatten input-tree output-list)
  (cond ((= input-tree '()) output-list)
        ((symbol? input-tree) (cons input-tree output-list))
        ((atom input-tree) (cons input-tree output-list))
        ('t (flatten (car input-tree)
                     (flatten (cdr input-tree) output-list)))))
(define (args-required-globals args declared-globals definitions)
  (if (atom args)
      (required-globals args declared-globals definitions)
      (append (required-globals (car args) declared-globals definitions)
              (args-required-globals (cdr args)
                                     declared-globals
                                     definitions))))
(define (required-globals expr declared-globals definitions)
  (cond ((symbol? expr)
         (if (member expr declared-globals)
             '()
             (if (member expr supported-builtins)
                 '()
                 (let ((definition (find-definition expr definitions))
                       (declared-globals (cons expr declared-globals)))
                   (cons expr (required-globals definition
                                                declared-globals
                                                definitions))))))
        ((atom expr) '())
        ((= (car expr) 'quote) '())
        ((= (car expr) 'define)
         (required-globals (get-body expr) declared-globals definitions))
        ((= (car expr) 'fn)
         (required-globals (caddr expr)
                           (flatten (cadr expr) declared-globals)
                           definitions))
        ('t (args-required-globals expr declared-globals definitions))))
(define (extract-required-definitions required-globals definitions return)
  (if (atom definitions)
      (return '() '())
      (extract-required-definitions
       required-globals
       (cdr definitions)
       (if (member (get-name (car definitions)) required-globals)
           (fn (required-definitions remaining-definitions)
               (return (cons (car definitions)
                             required-definitions)
                       remaining-definitions))
           (fn (required-definitions remaining-definitions)
               (return required-definitions
                       (cons (car definitions)
                             remaining-definitions)))))))
(define (process expr declared-globals remaining-definitions return)
  (let ((expr-globals (required-globals expr
                                        declared-globals
                                        remaining-definitions)))
    (extract-required-definitions
     expr-globals remaining-definitions
     (fn (required-definitions remaining-definitions)
         ((foldr (fn (definition tail)
                     (append (print `(define ,(get-name definition)
                                       ,(get-body definition)))
                             tail))
                 (append (print expr)
                         (return remaining-definitions)))
          required-definitions)))))
(define (read-expr cont line-number)
  (parse-expr cont (fn (error-message end-line)
                       (print-error (append "Parse error, line "
                                            (print end-line)
                                            ": " error-message "\n")))
              line-number))
(define (main-loop declared-globals remaining-definitions)
  (fn (value end-line-number)
      (cond ((not value) "")
            ((not (= (car value) 'define))
             (process (escape-statement value)
                      declared-globals
                      remaining-definitions
                      (fn (remaining-definitions) "")))
            ('t (let ((name (get-name value))
                      (declared-globals (cons name declared-globals)))
                  (process (escape-statement value)
                           declared-globals
                           remaining-definitions
                           (fn (remaining-definitions)
                               (read-expr (main-loop declared-globals
                                                     remaining-definitions)
                                          end-line-number))))))))
(fn (size arguments)
    (read-expr (main-loop '() standard-library-definitions) 1))
