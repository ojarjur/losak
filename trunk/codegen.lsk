;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This program takes as input cps programs, and generates ;;
;; equivalent C programs.                                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Input language:                                                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; <PROGRAM> ::= (<DEFINITION>)* <EXPR>                                     ;;
;; <DEFINITION> ::= '(' 'define' <NAME> <EXPR> ')'                          ;;
;; <NAME> ::= (^['(', ')', '.', '"', '\'', 0..32])+                         ;;
;;                                                                          ;;
;; <EXPR> ::= <ATOM> | <APPLICATION> | <FUNCTION> | <IF> | <QUOTE>          ;;
;; <ATOM> ::= <NIL> | <NUMBER> | <NAME>                                     ;;
;; <NIL> ::= '(' ')'                                                        ;;
;; <NUMBER> ::= ['0'..'9']+                                                 ;;
;;                                                                          ;;
;; <QUOTE> ::= '(' 'quote' <S-EXPR> ')' | '\'' <S-EXPR>                     ;;
;; <S-EXPR> ::= <ATOM> | <PAIR>                                             ;;
;; <PAIR> ::= '(' (<S-EXPR>)+ ('.' <S-EXPR>)? ')'                           ;;
;;                                                                          ;;
;; <FUNCTION> ::= '(' 'fn' <PARAMS> <EXPR> ')'                              ;;
;; <PARAMS> ::= <NAME> | '(' (<PARAMS>)+ ('.' <PARAMS>)? ')'                ;;
;;                                                                          ;;
;; <APPLICATION> ::= '(' (<IMMEDIATE>)+ ')'                                 ;;
;; <IMMEDIATE> ::= <ATOM> | <PRIMITIVE_OP> | <FUNCTION>                     ;;
;; <PRIMITIVE_OP> ::= '(' (<UNARY_OP> | <BINARY_OP>) ')'                    ;;
;; <UNARY_EXPR> ::= <UNARY_OP> <PRIMITIVE>                                  ;;
;; <UNARY_OP> ::= ('-' | '~' | 'car' | 'cdr' | 'atom' )                     ;;
;; <BINARY_EXPR> ::= <BINARY_OP> <PRIMITIVE> <PRIMITIVE>                    ;;
;; <BINARY_OP> ::= ('+' | '-' | '*' | '%' | '/' | '=' | 'cons')             ;;
;;                                                                          ;;
;; <IF> ::= '(' 'if' <IMMEDIATE> <EXPR> <EXPR> ')'                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;
;; Output handling ;;
;;;;;;;;;;;;;;;;;;;;;
(define print-error
  (foldr (fn (char output) (cons (list (cons 2 char)) output)) ()))
(define (escape-symbol-name symbol)
  ((foldr (fn (char chars) (append "c" (print char) chars)) "")
   (symbol->string symbol)))
(define (print-symbol symbol)
  (append "symbol_" (escape-symbol-name symbol)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile-time symbol table ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (empty-symbol-table next-symbol-id)
  (fn (symbol return)
      (return next-symbol-id
              (add-symbol symbol next-symbol-id
                          (empty-symbol-table (- next-symbol-id 1))))))
(define (add-symbol symbol id symbol-table)
  (fn (sought-symbol return)
      (if (= sought-symbol symbol)
          (return id (add-symbol symbol id symbol-table))
          (symbol-table sought-symbol
                        (fn (found-id symbol-table)
                            (return found-id
                                    (add-symbol symbol id symbol-table)))))))
(define initial-symbol-table (empty-symbol-table (- 34)))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Expression compiler ;;
;;;;;;;;;;;;;;;;;;;;;;;;;
(define (is-primitive op)
  (or (= op 'cons) (= op 'car) (= op 'cdr)
      (= op 'atom) (= op 'number) (= op 'function)
      (= op '=) (= op '<) (= op '>) (= op '+)
      (= op '-) (= op '*) (= op '/) (= op '%)
      (= op '~) (= op '&) (= op '|) (= op '^)
      (= op '>>) (= op '>>>) (= op '<<)))
(define (find var env path return backtrack)
  (cond ((= var env) (return path))
        ((atom env) (backtrack))
        ('t (find var (car env)
                  (append "car(" path ")")
                  return
                  (fn () (find var (cdr env)
                               (append "cdr(" path ")")
                               return
                               backtrack))))))
(define (compile-global var declared-globals return)
  (let ((global-code (append "  increment_count(val = "
                             (print-symbol var) ");\n")))
    (if (member var declared-globals)
        (return global-code declared-globals)
      (return (append "  pointer " (print-symbol var) ";\n" global-code)
              (cons var declared-globals)))))
(define (compile-atom expr env declared-globals return)
  (cond ((number expr)
         (return (append "  val = new_number(" (print expr) ");\n")
                 declared-globals))
        ((symbol? expr)
         (find expr env "env"
               (fn (path)
                   (return (append "  increment_count(val = " path ");\n")
                           declared-globals))
               (fn () (compile-global expr declared-globals return))))
        ('t (return "  val = NIL;\n" declared-globals))))
(define (compile-args args env next-label symbol-table declared-globals return)
  (if (atom args)
      (compile-atom args env declared-globals
                    (fn (args-code declared-globals)
                        (return (append args-code "  args = val;\n")
                                next-label symbol-table declared-globals)))
      (let (((args-code next-label symbol-table declared-globals)
             (compile-args (cdr args) env next-label
                           symbol-table declared-globals list))
            ((arg-code next-label symbol-table declared-globals)
             (compile-expr (car args) env next-label
                           symbol-table declared-globals list)))
        (return (append args-code arg-code "  args = cons(val, args);\n")
                next-label symbol-table declared-globals))))
(define (compile-literal expr symbol-table return)
  (cond ((number expr)
         (return (append "new_number(" (print expr) ")") symbol-table))
        ((symbol? expr)
         (symbol-table expr (fn (symbol-id symbol-table)
                                (return (print symbol-id) symbol-table))))
        ((atom expr) (return "NIL" symbol-table))
        ('t (let (((head-code symbol-table)
                   (compile-literal (car expr) symbol-table list))
                  ((tail-code symbol-table)
                   (compile-literal (cdr expr) symbol-table list)))
              (return (append "cons(" head-code ", " tail-code ")")
                      symbol-table)))))
(define (compile-if test then else env next-label
                    symbol-table declared-globals return)
  (let (((test-code next-label symbol-table declared-globals)
         (compile-expr test env next-label symbol-table declared-globals list))
        ((then-code next-label symbol-table declared-globals)
         (compile-expr then env next-label symbol-table declared-globals list))
        ((else-code next-label symbol-table declared-globals)
         (compile-expr else env next-label symbol-table declared-globals list)))
    (return (append test-code
                    "if (val != NIL) {\n"
                    "  decrement_count(val);\n"
                    "  goto then_" (print next-label) ";\n"
                    "}\n"
                    else-code
                    "  goto result_" (print next-label) ";\n"
                    "then_" (print next-label) ":\n"
                    then-code
                    "result_" (print next-label) ":\n")
            (+ next-label 1) symbol-table declared-globals)))
(define (compile-fn params body env next-label
                    symbol-table declared-globals return)
  (compile-expr body (cons params env) next-label symbol-table declared-globals
                (fn (body-code next-label symbol-table declared-globals)
                    (return (append "  goto eval_" (print next-label) ";\n"
                                    "declare_" (print next-label) ":\n"
                                    body-code
                                    "  goto *return_location;\n"
                                    "eval_" (print next-label) ":\n"
                                    "  increment_count(env);\n"
                                    "  val = wrap_function(&&declare_"
                                    (print next-label)
                                    ", env);\n")
                            (+ next-label 1)
                            symbol-table
                            declared-globals))))
(define (compile-boolean test-code)
  (append "  val = (" test-code ")?new_number(1):NIL;\n"))
(define (unary-numeric op-code)
  (append "  val = (is_number(car(args)))?new_number("
          op-code
          " value(car(args))):NIL;\n"))
(define (binary-numeric op-code)
  (append "  val = (is_number(car(args)) && is_number(car(cdr(args))))?"
          "new_number(value(car(args)) "
          op-code
          " value(car(cdr(args)))):NIL;\n"))
(define (compile-primitive op)
  (cond ((= op '-)
         (append "  if (is_atom(cdr(args))) {\n"
                 (unary-numeric "-")
                 "  } else {\n"
                 (binary-numeric "-")
                 "  }\n"))
        ((= op 'car) "  increment_count(val = car(car(args)));\n")
        ((= op 'cdr) "  increment_count(val = cdr(car(args)));\n")
        ((= op 'atom) (compile-boolean "is_atom(car(args))"))
        ((= op 'number) (compile-boolean "is_number(car(args))"))
        ((= op 'function) (compile-boolean "is_function(car(args))"))
        ((= op '~) (unary-numeric "~"))
        ((= op 'cons)
         (append "  increment_count(car(args));\n"
                 "  increment_count(car(cdr(args)));\n"
                 "  val = cons(car(args), car(cdr(args)));\n"))
        ((= op '=) (compile-boolean "eq(car(args), car(cdr(args)))"))
        ((= op '<)
         (compile-boolean "(is_number(car(args)) && is_number(car(cdr(args))) && value(car(args)) < value(car(cdr(args))))"))
        ((= op '>)
         (compile-boolean "(is_number(car(args)) && is_number(car(cdr(args))) && value(car(args)) > value(car(cdr(args))))"))
        ((= op '+) (binary-numeric "+"))
        ((= op '*) (binary-numeric "*"))
        ((= op '/) (binary-numeric "/"))
        ((= op '%) (binary-numeric "%"))
        ((= op '&) (binary-numeric "&"))
        ((= op '|) (binary-numeric "|"))
        ((= op '^) (binary-numeric "^"))
        ((= op '>>) (binary-numeric ">>"))
        ((= op '>>>)
         (append "  val = new_number(((sign_mask >> "
                 "                     value(car(cdr(args))) - 1) ^ -1) & "
                 "                   (value(car(args)) >> "
                 "                    value(car(cdr(args))))); "))
        ('t (binary-numeric "<<"))))
(define (compile-pair op args env next-label
                      symbol-table declared-globals return)
  (cond ((= op 'quote)
         (compile-literal (car args) symbol-table
                          (fn (code symbol-table)
                              (return (append "  val = " code ";\n")
                                      next-label symbol-table
                                      declared-globals))))
        ((= op 'if)
         (compile-if (car args) (cadr args) (caddr args) env 
                     next-label symbol-table declared-globals return))
        ((= op 'fn)
         (compile-fn (car args) (cadr args) env
                     next-label symbol-table declared-globals return))
        ('t (let (((args-code next-label symbol-table declared-globals)
                   (compile-args args env next-label symbol-table
                                 declared-globals list)))
              (if (is-primitive op)
                  (return (append "  args_stack = cons(args, args_stack);\n"
                                  args-code
                                  (compile-primitive op)
                                  "  decrement_count(args);\n"
                                  "  increment_count(args = car(args_stack));\n"
                                  "  increment_count(temp = cdr(args_stack));\n"
                                  "  decrement_count(args_stack);\n"
                                  "  args_stack = temp;\n")
                          next-label symbol-table declared-globals)
                  (let (((op-code next-label symbol-table declared-globals)
                         (compile-expr op env next-label
                                       symbol-table declared-globals list)))
                    (return (append args-code
                                    op-code
                                    "  decrement_count(env);\n"
                                    "  increment_count("
                                    "temp = function_environment(val));\n"
                                    "  target = function_target(\n"
                                    "    val, &&end_function_addr);\n"
                                    "  decrement_count(val);\n"
                                    "  env = cons(args, temp);\n"
                                    "  goto *target;\n")
                            next-label symbol-table
                            declared-globals)))))))
(define (compile-expr expr env next-label
                      symbol-table declared-globals return)
  (if (atom expr)
      (compile-atom expr env declared-globals
                    (fn (code declared-globals)
                        (return code next-label symbol-table declared-globals)))
      (compile-pair (car expr) (cdr expr) env
                    next-label symbol-table declared-globals return)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Generated-code prefix ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define prefix
  (append "#ifdef BARE_HARDWARE\n"
          "#include \"multiboot.h\"\n"
          "#else\n"
          "#include <stdlib.h>\n"
          "#endif\n"
          "#include \"mem.h\"\n"
          "#include \"io.h\"\n"
          "pointer wrap_function(void* ptr, pointer env) {\n"
          "  return cons(FUN, cons(new_number((pointer)ptr), env));\n"
          "}\n"
          "void* function_target(pointer ptr, void* end_addr) {\n"
          "  return is_function(ptr)?\n"
          "    (void*)value(head(tail(ptr))):end_addr;\n"
          "}\n"
          "pointer function_environment(pointer ptr) {\n"
          "  return tail(tail(ptr));\n"
          "}\n"
          "pointer make_string(char* str) {\n"
          "  pointer r = NIL;\n"
          "  int i = 0;\n"
          "  while ((str > 0) && (str[i] != '\\0')) {\n"
          "    i++;\n"
          "  }\n"
          "  while (i > 0) {\n"
          "    i--;\n"
          "    r = cons(new_number(str[i]), r);\n"
          "  }\n"
          "  return r;\n"
          "}\n"
          "int build_sign_mask() {\n"
          "  int sign_mask;\n"
          "  int t = sign_mask = -1;\n"
          "  while (t < 0) {\n"
          "    sign_mask = t;\n"
          "    t = t << 1;\n"
          "  }\n"
          "  return sign_mask;\n"
          "}\n"
          "#ifdef BARE_HARDWARE\n"
          "pointer get_cmd(unsigned long flags, char* command) {\n"
          "  pointer r = NIL;\n"
          "  if (getFlag(flags,2) != 0) {\n"
          "    r = make_string(command);\n"
          "  }\n"
          "  return r;\n"
          "}\n"
          "void main(unsigned long magic,\n"
          "          multiboot_data* boot_data) {\n"
          "#else\n"
          "int main(int argc, char** argv) {\n"
          "  int return_value;\n"
          "#endif\n"
          "  function_addr target, return_location;\n"
          "  pointer val, args, env, temp, arguments, true, args_stack;\n"
          "  int sign_mask = build_sign_mask();\n"
          "#ifdef BARE_HARDWARE\n"
          "  int i = 0;\n"
          "  if ((magic != BOOT_MAGIC) ||\n"
          "      !getFlag(boot_data->flags, 0)) {\n"
          "    error(ERR_BAD_BOOT);\n"
          "    return;\n"
          "  }\n"
          ;; The makefile specifies that the binary should
          ;; start at 0x100000, so the start address for
          ;; the heap should be greater than the size of
          ;; the binary - 0x100000, and the memory size
          ;; should be reduced by the amount of space
          ;; reserved for the binary.
          "  init_mem((void*)0x500000,\n"
          "           ((boot_data->mem_upper*1024) - 0x400000));\n"
          "  init_io();\n"
          "  arguments = get_cmd(\n"
          "    boot_data->flags,\n"
          "    (char*)(boot_data->cmd_line));\n"
          "#else\n"
          "  pointer memory_limit = 64 * 1024 * 1024;\n"
          "  void* memory = malloc(memory_limit);\n"
          "  init_mem(memory, memory_limit);\n"
          "  init_io();\n"
          "  arguments = NIL;\n"
          "  int i;\n"
          "  for (i = argc - 1; i >= 0; i--) {\n"
          "    arguments = cons(make_string(argv[i]),\n"
          "                     arguments);\n"
          "  }\n"
          "#endif\n"
          "  true = new_number(1);\n"
          "  env = args_stack = NIL;\n"
          "  goto start;\n"
          "perform_io:\n"
          "  while (! is_atom(val)) {\n"
          "    execute(car(val));\n"
          "    increment_count(temp = cdr(val));\n"
          "    decrement_count(val);\n"
          "    val = temp;\n"
          "  }\n"
          "  if (is_function(val)) {\n"
          "    pointer input = get_input();\n"
          "    target = function_target(val, &&end_function_addr);\n"
          "    increment_count(env = function_environment(val));\n"
          "    decrement_count(val);\n"
          "    if (input != NIL) {\n"
          "      env = cons(cons(input, NIL), env);\n"
          "    } else {\n"
          "      env = cons(NIL, env);\n"
          "    }\n"
          "    return_location = &&perform_io;\n"
          "  } else {\n"
          "    target = &&end_function_addr;\n"
          "  }\n"
          "  goto *target;\n"
          "start:\n"))
(define suffix
  (append "apply_main:\n"
          "  if (is_function(val)) {\n"
          "    increment_count(env=function_environment(val));\n"
          "    env = cons(cons(free_memory_size(),\n"
          "                    cons(arguments,NIL)),\n"
          "               env);\n"
          "    target = function_target(val, &&end_function_addr);\n"
          "    decrement_count(val);\n"
          "    return_location = &&perform_io;\n"
          "  } else {\n"
          "    error(ERR_NO_OS);\n"
          "    env = NIL;\n"
          "    target = (&&end_function_addr);\n"
          "  }\n"
          "  goto *target;\n"
          "end_function_addr:\n"
          "#ifndef BARE_HARDWARE\n"
          "  end_io();\n"
          "#endif\n"
          "  if (is_number(val)) {\n"
          "#ifdef BARE_HARDWARE\n"
          "    if (cdr(val) == 0) {\n"
          "      halt();\n"
          "    } else if (cdr(val) == 1) {\n"
          "      reboot();\n"
          "    }\n"
          "  }\n"
          "  decrement_count(val);\n"
          "#else\n"
          "    return_value = value(val);\n"
          "  } else {\n"
          "    return_value = 0;\n"
          "  }\n"
          "  decrement_count(val);\n"
          "  return return_value;\n"
          "#endif\n"
          "}\n"))

;;;;;;;;;;;;;;;
;; Main loop ;;
;;;;;;;;;;;;;;;
(define (read-expr cont line-number)
  (parse-expr cont (fn (error-message end-line)
                       (print-error (append "Parse error, line "
                                            (print end-line)
                                            ": " error-message "\n")))
              line-number))
(define (compile-definition def space line-number next-id symbols globals)
  (let ((name (print-symbol (car def)))
        (expr (cadr def))
        (declared? (member (car def) globals))
        (globals (if declared? globals (cons (car def) globals))))
    (compile-expr expr '() next-id symbols globals
                  (fn (expr-code next-id symbols globals)
                      (append "  return_location = &&def_" name ";\n"
                              (if declared?
                                  ""
                                  (append "  pointer " name ";\n"))
                              expr-code
                              "def_" name ":\n"
                              "  " name " = val;\n"
                              (main space line-number next-id
                                    symbols (cons (car def) globals)))))))
(define (compile space start-line next-id symbols globals)
  (fn (expr line-number)
      (append "/* line number: " (print start-line) "*/\n"
              (if (= (car expr) 'define)
                  (compile-definition (cdr expr) space line-number
                                      next-id symbols globals)
                  (compile-expr expr '() next-id symbols globals
                                (fn (expr-code next-id symbols globals)
                                    (append "  return_location = "
                                            "&&apply_main;\n"
                                            expr-code
                                            suffix)))))))
(define (main space line-number next-id symbols globals)
  (if (> space 0)
      (read-expr (compile space line-number next-id symbols globals)
                 line-number)
      (print-error "ERROR: Out of memory")))
(fn (space args) (append prefix (main space 0 0 initial-symbol-table '())))
