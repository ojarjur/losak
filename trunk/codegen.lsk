;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; This program takes as input cps programs, and generates ;;
;; equivalent C programs.                                  ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Input language:                                                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; <PROGRAM> ::= (<DEFINITION>)* <EXPR>                                     ;;
;; <DEFINITION> ::= '(' 'define' <NAME> <EXPR> ')'                          ;;
;; <NAME> ::= (^['(', ')', '.', '"', '\'', 0..32])+                         ;;
;;                                                                          ;;
;; <EXPR> ::= <ATOM> | <APPLICATION> | <FUNCTION> | <IF> | <QUOTE>          ;;
;; <ATOM> ::= <NIL> | <NUMBER> | <NAME>                                     ;;
;; <NIL> ::= '(' ')'                                                        ;;
;; <NUMBER> ::= ['0'..'9']+                                                 ;;
;;                                                                          ;;
;; <QUOTE> ::= '(' 'quote' <S-EXPR> ')' | '\'' <S-EXPR>                     ;;
;; <S-EXPR> ::= <ATOM> | <PAIR>                                             ;;
;; <PAIR> ::= '(' (<S-EXPR>)+ ('.' <S-EXPR>)? ')'                           ;;
;;                                                                          ;;
;; <FUNCTION> ::= '(' 'fn' <PARAMS> <EXPR> ')'                              ;;
;; <PARAMS> ::= <NAME> | '(' (<PARAMS>)+ ('.' <PARAMS>)? ')'                ;;
;;                                                                          ;;
;; <APPLICATION> ::= '(' (<IMMEDIATE>)+ ')'                                 ;;
;; <IMMEDIATE> ::= <ATOM> | <PRIMITIVE_OP> | <FUNCTION>                     ;;
;; <PRIMITIVE_OP> ::= '(' (<UNARY_OP> | <BINARY_OP>) ')'                    ;;
;; <UNARY_EXPR> ::= <UNARY_OP> <PRIMITIVE>                                  ;;
;; <UNARY_OP> ::= ('-' | '~' | 'car' | 'cdr' | 'atom' )                     ;;
;; <BINARY_EXPR> ::= <BINARY_OP> <PRIMITIVE> <PRIMITIVE>                    ;;
;; <BINARY_OP> ::= ('+' | '-' | '*' | '%' | '/' | '=' | 'cons')             ;;
;;                                                                          ;;
;; <IF> ::= '(' 'if' <IMMEDIATE> <EXPR> <EXPR> ')'                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;;
;; Output handling ;;
;;;;;;;;;;;;;;;;;;;;;
(define print-error
  (foldr (fn (char output) (cons (list (cons 2 char)) output)) ()))
(define (escape-symbol-name symbol)
  ((foldr (fn (char chars) (append "c" (print char) chars)) "")
   (symbol->string symbol)))
(define (print-symbol symbol)
  (append "symbol_" (escape-symbol-name symbol)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Compile-time symbol table ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define (empty-symbol-table next-symbol-id)
  (fn (symbol return)
      (return next-symbol-id
              (add-symbol symbol next-symbol-id
                          (empty-symbol-table (- next-symbol-id 1))))))
(define (add-symbol symbol id symbol-table)
  (fn (sought-symbol return)
      (if (= sought-symbol symbol)
          (return id (add-symbol symbol id symbol-table))
          (symbol-table sought-symbol
                        (fn (found-id symbol-table)
                            (return found-id
                                    (add-symbol symbol id symbol-table)))))))
(define initial-symbol-table (empty-symbol-table (- 34)))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Expression compiler ;;
;;;;;;;;;;;;;;;;;;;;;;;;;
(define (is-primitive op)
  (or (= op 'cons) (= op 'car) (= op 'cdr)
      (= op 'atom) (= op 'number) (= op 'function)
      (= op '=) (= op '<) (= op '>) (= op '+)
      (= op '-) (= op '*) (= op '/) (= op '%)
      (= op '~) (= op '&) (= op '|) (= op '^)
      (= op '>>) (= op '>>>) (= op '<<)))
(define (find var env path return backtrack)
  (cond ((= var env) (return path))
        ((atom env) (backtrack))
        ('t (find var (car env)
                  (append "car(" path ")")
                  return
                  (fn () (find var (cdr env)
                               (append "cdr(" path ")")
                               return
                               backtrack))))))
(define (compile-global var declared-globals return)
  (let ((declared? (member var declared-globals))
        (declared-globals (if declared?
                              declared-globals
                              (cons var declared-globals)))
        (declarations (if declared?
                          ""
                          (append "  pointer " (print-symbol var) ";\n"))))
    (return (append "  increment_count(val = " (print-symbol var) ");\n")
            declarations
            declared-globals)))
(define (compile-atom expr env declared-globals return)
  (cond ((number expr)
         (return (append "  val = new_number(" (print expr) ");\n")
                 "" declared-globals))
        ((symbol? expr)
         (find expr env "env"
               (fn (path)
                   (return (append "  increment_count(val = " path ");\n")
                           "" declared-globals))
               (fn () (compile-global expr declared-globals return))))
        ('t (return "  val = NIL;\n" "" declared-globals))))
(define (compile-args args env declarations suffix next-label symbol-table
                      declared-globals return)
  (if (atom args)
      (compile-atom args env declared-globals
                    (fn (args-code args-declarations declared-globals)
                        (return (append args-code
                                        "  args = val;\n"
                                        suffix)
                                (append args-declarations declarations)
                                next-label symbol-table declared-globals)))
      (let (((arg-code arg-declarations next-label symbol-table declared-globals)
             (compile-expr (car args) env
                           (append "  args = cons(val, args);\n" suffix)
                           next-label symbol-table declared-globals '() list)))
        (compile-args (cdr args) env
                      (append arg-declarations declarations)
                      arg-code next-label symbol-table
                      declared-globals return))))
(define (compile-literal expr symbol-table return)
  (cond ((number expr)
         (return (append "new_number(" (print expr) ")") symbol-table))
        ((symbol? expr)
         (symbol-table expr (fn (symbol-id symbol-table)
                                (return (print symbol-id) symbol-table))))
        ((atom expr) (return "NIL" symbol-table))
        ('t (let (((head-code symbol-table)
                   (compile-literal (car expr) symbol-table list))
                  ((tail-code symbol-table)
                   (compile-literal (cdr expr) symbol-table list)))
              (return (append "cons(" head-code ", " tail-code ")")
                      symbol-table)))))
(define (compile-if test then else env suffix next-label
                    symbol-table declared-globals tail-call? return)
  (let ((return-label next-label)
        (next-label (+ next-label 1))
        ((else-code else-declarations next-label symbol-table declared-globals)
         (compile-expr else env
                       (append "result_" (print return-label) ":\n" suffix)
                       next-label symbol-table
                       declared-globals tail-call? list))
        ((then-code then-declarations next-label symbol-table declared-globals)
         (compile-expr then env
                       (append "  goto result_" (print return-label) ";\n"
                               "else_" (print return-label) ":\n"
                               else-code)
                       next-label symbol-table
                       declared-globals tail-call? list)))
    (compile-expr test env
                  (append "if (val == NIL) {\n"
                          "  goto else_" (print return-label) ";\n"
                          "}\n"
                          "  decrement_count(val);\n"
                          then-code)
                  next-label symbol-table declared-globals '()
                  (fn (code declarations next-label symbols globals)
                      (return code (append then-declarations
                                           else-declarations
                                           declarations)
                              next-label symbols globals)))))
(define (compile-fn params body env suffix next-label
                    symbol-table declared-globals return)
  (compile-expr body (cons params env)
                (append "  goto *return_location;\n"
                        "eval_" (print next-label) ":\n"
                        "  increment_count(env);\n"
                        "  val = wrap_function(&&declare_"
                        (print next-label)
                        ", env);\n"
                        suffix)
                (+ next-label 1) symbol-table declared-globals 't
                (fn (body-code declarations body-next-label
                               symbol-table declared-globals)
                    (return (append "  goto eval_" (print next-label) ";\n"
                                    "declare_" (print next-label) ":\n"
                                    body-code)
                            declarations
                            body-next-label
                            symbol-table
                            declared-globals))))
(define (compile-boolean test-code)
  (append "  val = (" test-code ")?new_number(1):NIL;\n"))
(define (unary-numeric op-code)
  (append "  val = (is_number(car(args)))?new_number("
          op-code
          " value(car(args))):NIL;\n"))
(define (binary-numeric op-code)
  (append "  val = (is_number(car(args)) && is_number(car(cdr(args))))?"
          "new_number(value(car(args)) "
          op-code
          " value(car(cdr(args)))):NIL;\n"))
(define (compile-primitive op)
  (cond ((= op '-)
         (append "  if (is_atom(cdr(args))) {\n"
                 (unary-numeric "-")
                 "  } else {\n"
                 (binary-numeric "-")
                 "  }\n"))
        ((= op 'car) "  increment_count(val = car(car(args)));\n")
        ((= op 'cdr) "  increment_count(val = cdr(car(args)));\n")
        ((= op 'atom) (compile-boolean "is_atom(car(args))"))
        ((= op 'number) (compile-boolean "is_number(car(args))"))
        ((= op 'function) (compile-boolean "is_function(car(args))"))
        ((= op '~) (unary-numeric "~"))
        ((= op 'cons)
         (append "  increment_count(car(args));\n"
                 "  increment_count(car(cdr(args)));\n"
                 "  val = cons(car(args), car(cdr(args)));\n"))
        ((= op '=) (compile-boolean "eq(car(args), car(cdr(args)))"))
        ((= op '<)
         (compile-boolean "(is_number(car(args)) && is_number(car(cdr(args))) && value(car(args)) < value(car(cdr(args))))"))
        ((= op '>)
         (compile-boolean "(is_number(car(args)) && is_number(car(cdr(args))) && value(car(args)) > value(car(cdr(args))))"))
        ((= op '+) (binary-numeric "+"))
        ((= op '*) (binary-numeric "*"))
        ((= op '/) (binary-numeric "/"))
        ((= op '%) (binary-numeric "%"))
        ((= op '&) (binary-numeric "&"))
        ((= op '|) (binary-numeric "|"))
        ((= op '^) (binary-numeric "^"))
        ((= op '>>) (binary-numeric ">>"))
        ((= op '>>>)
         (append "  val = new_number(((sign_mask >> "
                 "                     value(car(cdr(args))) - 1) ^ -1) & "
                 "                   (value(car(args)) >> "
                 "                    value(car(cdr(args))))); "))
        ('t (binary-numeric "<<"))))
(define (compile-operator op env suffix next-label
                          symbol-table declared-globals return)
  (if (is-primitive op)
      (return (append (compile-primitive op)
                      "  decrement_count(args);\n"
                      suffix)
              "" next-label symbol-table declared-globals)
      (compile-expr op env
                    (append "  decrement_count(env);\n"
                            "  increment_count("
                            "temp = function_environment(val));\n"
                            "  target = function_target(\n"
                            "    val, &&end_function_addr);\n"
                            "  decrement_count(val);\n"
                            "  env = cons(args, temp);\n"
                            "  goto *target;\n"
                            suffix)
                    next-label symbol-table declared-globals '() return)))
(define (compile-application op args env suffix next-label symbol-table
                             declared-globals tail-call? return)
  (let ((return-label next-label)
        (next-label (+ next-label 1))
        (cleanup-code (if tail-call?
                          suffix
                          (append (if (is-primitive op)
                                      ""
                                      (append "r_" (print return-label) ":\n"
                                              "  return_location "
                                              "= return_location_backup;\n"
                                              "  decrement_count(env);\n"
                                              "  env = env_backup;\n"))
                                  "  increment_count(args = car(args_stack));\n"
                                  "  increment_count(temp = cdr(args_stack));\n"
                                  "  decrement_count(args_stack);\n"
                                  "  args_stack = temp;\n"
                                  suffix)))
        ((op-code declarations next-label symbol-table declared-globals)
         (compile-operator op env cleanup-code next-label
                           symbol-table declared-globals list)))
    (compile-args args env declarations
                  (if (or tail-call? (is-primitive op))
                      op-code
                      (append "  increment_count(env_backup = env);\n"
                              "  return_location_backup = return_location;\n"
                              "  return_location = &&r_"
                              (print return-label) ";\n"
                              op-code))
                  next-label symbol-table declared-globals
                  (fn (args-code args-declarations next-label
                                 symbol-table declared-globals)
                      (return (if tail-call?
                                  args-code
                                  (append args-declarations
                                          "  args_stack = "
                                          "cons(args, args_stack);\n"
                                          args-code))
                              args-declarations next-label
                              symbol-table declared-globals)))))
(define (compile-pair op args env suffix next-label symbol-table
                      declared-globals tail-call? return)
  (cond ((= op 'quote)
         (compile-literal (car args) symbol-table
                          (fn (code symbol-table)
                              (return (append "  val = " code ";\n" suffix)
                                      "" next-label symbol-table
                                      declared-globals))))
        ((= op 'if)
         (compile-if (car args) (cadr args) (caddr args) env suffix
                     next-label symbol-table declared-globals
                     tail-call? return))
        ((= op 'fn)
         (compile-fn (car args) (cadr args) env suffix
                     next-label symbol-table declared-globals return))
        ('t (compile-application op args env suffix next-label symbol-table
                                 declared-globals tail-call? return))))
(define (compile-expr expr env suffix next-label
                      symbol-table declared-globals
                      tail-call? return)
  (if (atom expr)
      (compile-atom expr env declared-globals
                    (fn (code declarations declared-globals)
                        (return (append code suffix)
                                declarations next-label
                                symbol-table declared-globals)))
      (compile-pair (car expr) (cdr expr) env suffix
                    next-label symbol-table
                    declared-globals tail-call? return)))

;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Generated-code prefix ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define prefix
  (append "#ifdef BARE_HARDWARE\n"
          "#include \"multiboot.h\"\n"
          "#else\n"
          "#include <stdlib.h>\n"
          "#endif\n"
          "#include \"mem.h\"\n"
          "#include \"io.h\"\n"
          "pointer wrap_function(void* ptr, pointer env) {\n"
          "  return cons(FUN, cons(new_number((pointer)ptr), env));\n"
          "}\n"
          "void* function_target(pointer ptr, void* end_addr) {\n"
          "  return is_function(ptr)?\n"
          "    (void*)value(head(tail(ptr))):end_addr;\n"
          "}\n"
          "pointer function_environment(pointer ptr) {\n"
          "  return tail(tail(ptr));\n"
          "}\n"
          "pointer make_string(char* str) {\n"
          "  pointer r = NIL;\n"
          "  int i = 0;\n"
          "  while ((str > 0) && (str[i] != '\\0')) {\n"
          "    i++;\n"
          "  }\n"
          "  while (i > 0) {\n"
          "    i--;\n"
          "    r = cons(new_number(str[i]), r);\n"
          "  }\n"
          "  return r;\n"
          "}\n"
          "int build_sign_mask() {\n"
          "  int sign_mask;\n"
          "  int t = sign_mask = -1;\n"
          "  while (t < 0) {\n"
          "    sign_mask = t;\n"
          "    t = t << 1;\n"
          "  }\n"
          "  return sign_mask;\n"
          "}\n"
          "#ifdef BARE_HARDWARE\n"
          "pointer get_cmd(unsigned long flags, char* command) {\n"
          "  pointer r = NIL;\n"
          "  if (getFlag(flags,2) != 0) {\n"
          "    r = make_string(command);\n"
          "  }\n"
          "  return r;\n"
          "}\n"
          "void main(unsigned long magic,\n"
          "          multiboot_data* boot_data) {\n"
          "#else\n"
          "int main(int argc, char** argv) {\n"
          "  int return_value;\n"
          "#endif\n"
          "  function_addr target, return_location, return_location_backup;\n"
          "  pointer val, args, env, temp, arguments, true, args_stack, env_backup;\n"
          "  int sign_mask = build_sign_mask();\n"
          "#ifdef BARE_HARDWARE\n"
          "  int i = 0;\n"
          "  if ((magic != BOOT_MAGIC) ||\n"
          "      !getFlag(boot_data->flags, 0)) {\n"
          "    error(ERR_BAD_BOOT);\n"
          "    return;\n"
          "  }\n"
          ;; The makefile specifies that the binary should
          ;; start at 0x100000, so the start address for
          ;; the heap should be greater than the size of
          ;; the binary - 0x100000, and the memory size
          ;; should be reduced by the amount of space
          ;; reserved for the binary.
          "  init_mem((void*)0x500000,\n"
          "           ((boot_data->mem_upper*1024) - 0x400000));\n"
          "  init_io();\n"
          "  arguments = get_cmd(\n"
          "    boot_data->flags,\n"
          "    (char*)(boot_data->cmd_line));\n"
          "#else\n"
          "  pointer memory_limit = 64 * 1024 * 1024;\n"
          "  void* memory = malloc(memory_limit);\n"
          "  init_mem(memory, memory_limit);\n"
          "  init_io();\n"
          "  arguments = NIL;\n"
          "  int i;\n"
          "  for (i = argc - 1; i >= 0; i--) {\n"
          "    arguments = cons(make_string(argv[i]),\n"
          "                     arguments);\n"
          "  }\n"
          "#endif\n"
          "  true = new_number(1);\n"
          "  env = args_stack = NIL;\n"
          "  goto start;\n"
          "perform_io:\n"
          "  while (! is_atom(val)) {\n"
          "    execute(car(val));\n"
          "    increment_count(temp = cdr(val));\n"
          "    decrement_count(val);\n"
          "    val = temp;\n"
          "  }\n"
          "  if (is_function(val)) {\n"
          "    decrement_count(env);\n"
          "    pointer input = get_input();\n"
          "    target = function_target(val, &&end_function_addr);\n"
          "    increment_count(env = function_environment(val));\n"
          "    decrement_count(val);\n"
          "    if (input != NIL) {\n"
          "      env = cons(cons(input, NIL), env);\n"
          "    } else {\n"
          "      env = cons(NIL, env);\n"
          "    }\n"
          "    return_location = &&perform_io;\n"
          "  } else {\n"
          "    target = &&end_function_addr;\n"
          "  }\n"
          "  goto *target;\n"
          "start:\n"))
(define suffix
  (append "apply_main:\n"
          "  decrement_count(env);\n"
          "  if (is_function(val)) {\n"
          "    increment_count(env=function_environment(val));\n"
          "    env = cons(cons(free_memory_size(),\n"
          "                    cons(arguments,NIL)),\n"
          "               env);\n"
          "    target = function_target(val, &&end_function_addr);\n"
          "    decrement_count(val);\n"
          "    return_location = &&perform_io;\n"
          "  } else {\n"
          "    error(ERR_NO_OS);\n"
          "    env = NIL;\n"
          "    target = (&&end_function_addr);\n"
          "  }\n"
          "  goto *target;\n"
          "end_function_addr:\n"
          "#ifndef BARE_HARDWARE\n"
          "  end_io();\n"
          "#endif\n"
          "  if (is_number(val)) {\n"
          "#ifdef BARE_HARDWARE\n"
          "    if (cdr(val) == 0) {\n"
          "      halt();\n"
          "    } else if (cdr(val) == 1) {\n"
          "      reboot();\n"
          "    }\n"
          "  }\n"
          "  decrement_count(val);\n"
          "#else\n"
          "    return_value = value(val);\n"
          "  } else {\n"
          "    return_value = 0;\n"
          "  }\n"
          "  decrement_count(val);\n"
          "  return return_value;\n"
          "#endif\n"
          "}\n"))

;;;;;;;;;;;;;;;
;; Main loop ;;
;;;;;;;;;;;;;;;
(define (read-expr cont line-number)
  (parse-expr cont (fn (error-message end-line)
                       (print-error (append "Parse error, line "
                                            (print end-line)
                                            ": " error-message "\n")))
              line-number))
(define (compile-definition name expr space line-number next-id symbols globals)
  (let ((label (print-symbol name))
        (declared? (member name globals))
        (globals (if declared? globals (cons name globals)))
        (def-id next-id)
        (next-id (+ next-id 1))
        (suffix (append "def_" (print def-id) ":\n"
                        "  " label " = val;\n")))
    (compile-expr expr '() suffix next-id symbols globals 't
                  (fn (expr-code declarations next-id symbols globals)
                      (append "  return_location = &&def_" (print def-id) ";\n"
                              (if declared?
                                  ""
                                  (append "  pointer " label ";\n"))
                              declarations
                              expr-code
                              (main space line-number next-id
                                    symbols globals))))))
(define (compile space start-line next-id symbols globals)
  (fn (expr line-number)
      (append "/* line number: " (print start-line) "*/\n"
              (if (= (car expr) 'define)
                  (compile-definition (cadr expr) (caddr expr) space line-number
                                      next-id symbols globals)
                  (compile-expr expr '() suffix next-id symbols globals 't
                                (fn (expr-code declarations next-id
                                               symbols globals)
                                    (append "  return_location = "
                                            "&&apply_main;\n"
                                            declarations
                                            expr-code)))))))
(define (main space line-number next-id symbols globals)
  (if (> space 0)
      (read-expr (compile space line-number next-id symbols globals)
                 line-number)
      (print-error "ERROR: Out of memory")))
(fn (space args) (append prefix (main space 0 0 initial-symbol-table '())))
